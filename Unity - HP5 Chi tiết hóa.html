<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unity - HP5 Chi tiết hóa</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#giáo-án-chi-tiết-công-nghệ-game-với-unity---hp5">Giáo án chi tiết Công nghệ Game với Unity - HP5</a>
<ul>
<li><a href="#tóm-tắt-học-phần-2.1-tương-tác-vật-lý-3d-karting-microgame">Tóm tắt học phần 2.1: Tương tác vật lý 3D (Karting Microgame)</a></li>
<li><a href="#giáo-án-chi-tiết">Giáo án chi tiết</a>
<ul>
<li><a href="#giáo-án-buổi-học-2.1.1-khám-phá-vật-lý-3d-với-karting-microgame">Giáo án Buổi học 2.1.1: Khám phá Vật lý 3D với Karting Microgame</a></li>
<li><a href="#giáo-án-buổi-học-2.1.2-tinh-chỉnh-địa-hình-và-môi-trường-vật-lý">Giáo án Buổi học 2.1.2: Tinh chỉnh Địa hình và Môi trường Vật lý</a></li>
<li><a href="#giáo-án-buổi-học-2.1.3-scripting-cho-tương-tác-vật-lý-cơ-bản">Giáo án Buổi học 2.1.3: Scripting cho Tương tác Vật lý Cơ bản</a></li>
<li><a href="#giáo-án-buổi-học-2.1.4-lập-trình-điều-khiển-xe-đua">Giáo án Buổi học 2.1.4: Lập trình Điều khiển Xe Đua</a></li>
<li><a href="#giáo-án-buổi-học-2.1.5-giới-thiệu-class-và-object-trong-game-3d">Giáo án Buổi học 2.1.5: Giới thiệu Class và Object trong Game 3D</a></li>
<li><a href="#giáo-án-buổi-học-2.1.6-tổ-chức-mã-nguồn-với-class--object-thêm-hành-vi">Giáo án Buổi học 2.1.6: Tổ chức Mã Nguồn với Class & Object (Thêm Hành vi)</a></li>
<li><a href="#giáo-án-buổi-học-2.1.7-bổ-sung-animation-3d-cơ-bản">Giáo án Buổi học 2.1.7: Bổ sung Animation 3D cơ bản</a></li>
<li><a href="#giáo-án-buổi-học-2.1.8-tinh-chỉnh-hành-vi-và-chuyển-động-với-blend-tree">Giáo án Buổi học 2.1.8: Tinh chỉnh hành vi và chuyển động với Blend Tree</a></li>
<li><a href="#giáo-án-buổi-học-2.1.9-ôn-tập-kiểm-tra-và-rà-soát-dự-án">Giáo án Buổi học 2.1.9: Ôn tập, Kiểm tra và Rà soát Dự án</a></li>
<li><a href="#giáo-án-buổi-học-2.1.10-case-study---tối-ưu-hóa-và-hoàn-thiện-game">Giáo án Buổi học 2.1.10: Case Study - Tối ưu hóa và Hoàn thiện Game</a></li>
<li><a href="#giáo-án-buổi-học-2.1.11-case-study---hoàn-thiện-game-và-chuẩn-bị-trình-bày">Giáo án Buổi học 2.1.11: Case Study - Hoàn thiện Game và Chuẩn bị Trình bày</a></li>
<li><a href="#giáo-án-buổi-học-2.1.12-tổng-kết-dự-án-và-trình-bày">Giáo án Buổi học 2.1.12: Tổng Kết Dự Án và Trình Bày</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="giáo-án-chi-tiết-công-nghệ-game-với-unity---hp5">Giáo án chi tiết Công nghệ Game với Unity - HP5</h1>
<p>Link: <a href="https://docs.google.com/spreadsheets/d/1Tan-N8aVrvQ1H1-Ict9beZoIJ2aVUW4b/edit?gid=1043273961#gid=1043273961&amp;range=B57">Unity HP5 / HK2.1</a></p>
<p>Chi tiết hóa nội dung cho Học phần 2.1, tập trung vào “Karting Microgame”, vật lý 3D, C# (class/object), và animation, đồng thời liên kết với các mục tiêu của Unity Certified Associate (UCA).</p>
<p><strong>Học phần 2.1: Phát triển Game Đua Xe 3D với Vật lý và C# (Dựa trên Karting Microgame)</strong></p>
<p><strong>Đối tượng:</strong> Học sinh 15+ đã biết C# cơ bản.<br>
<strong>Thời lượng:</strong> 100 phút/buổi (Tổng cộng 12 buổi = 1200 phút)<br>
<strong>Nền tảng:</strong> Unity Karting Microgame (từ <a href="http://learn.unity.com">learn.unity.com</a>)<br>
<strong>Mục tiêu chung:</strong> Xây dựng và mở rộng game đua xe 3D “Karting Adventure”, tập trung vào tương tác vật lý, lập trình C# hướng đối tượng, và animation cơ bản, đồng thời làm quen với các khái niệm liên quan đến UCA.</p>
<hr>
<h2 id="tóm-tắt-học-phần-2.1-tương-tác-vật-lý-3d-karting-microgame">Tóm tắt học phần 2.1: Tương tác vật lý 3D (Karting Microgame)</h2>
<p><strong>Buổi 2.1.1: Khởi động với Vật lý 3D và Karting Microgame</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Tương tác môi trường vật lý 3D.</li>
<li>Làm quen với Karting Microgame và phác thảo ý tưởng mở rộng.</li>
<li>Giới thiệu dự án “Karting Adventure”.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu khái niệm không gian 3D (trục X, Y, Z) và các thành phần vật lý cơ bản trong Unity: Rigidbody, Collider.</li>
<li>Mở dự án Karting Microgame: Hướng dẫn khám phá các cửa sổ chính (Scene, Game, Hierarchy, Inspector, Project).</li>
<li>Chạy thử (Play) Microgame: Quan sát cách xe tương tác với đường đua, vật phẩm.</li>
<li>Phân tích cấu trúc project: Thư mục Assets, Scenes, Prefabs quan trọng (Xe đua, Đường đua).</li>
<li>Thảo luận ý tưởng mở rộng game: Thêm chướng ngại vật, thay đổi địa hình, tính năng mới.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Học sinh mở và chạy được Karting Microgame.</li>
<li>Xác định được các GameObject chính (Xe, Đường đua) và các component vật lý cơ bản trên chúng (Rigidbody, Collider) trong Inspector.</li>
<li>Có một vài ý tưởng ban đầu về cách mở rộng game.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Giải thích được vai trò cơ bản của Rigidbody và Collider trong tương tác vật lý 3D.</li>
<li>Điều hướng và xác định các thành phần cơ bản trong giao diện Unity Editor.</li>
<li>Nhận biết cấu trúc thư mục của một dự án Unity đơn giản.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 2.5 (Know Project View), 2.7 (Navigate Scene View), 2.10 (Understand Hierarchy), 2.11 (Understand Inspector), 2.13 (Utilize Inspector), 3.2 (Differentiate GameObjects), 3.3 (Distinguish components), 3.6 (Identify GameObjects), 12.1 (Colliders - Identify), 12.3 (Rigidbodies - Locate).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.2: Tinh chỉnh Địa hình và Môi trường Vật lý</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Tìm hiểu về tương tác vật lý 3D trong Unity.</li>
<li>Áp dụng kiến thức để điều chỉnh địa hình và môi trường trong game.</li>
<li>Điều chỉnh địa hình và môi trường trong game 3D.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu công cụ Terrain của Unity: Cách tạo và chỉnh sửa địa hình (nâng/hạ, làm mịn).</li>
<li>Sử dụng Terrain Tools trên đường đua có sẵn của Karting Microgame: Tạo thêm đồi dốc, khúc cua thử thách.</li>
<li>Giải thích cách Terrain Collider hoạt động và ảnh hưởng đến Rigidbody của xe.</li>
<li>Thêm các đối tượng môi trường đơn giản (ví dụ: đá, cây từ Standard Assets hoặc Asset Store) có Collider để tạo chướng ngại vật tĩnh.</li>
<li>Thử nghiệm lái xe trên địa hình đã chỉnh sửa để thấy sự khác biệt.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Một phiên bản đường đua Karting Microgame với địa hình được chỉnh sửa (thêm dốc, khúc cua, hoặc chướng ngại vật địa hình).</li>
<li>Một vài đối tượng môi trường tĩnh có Collider được đặt trên đường đua.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Sử dụng các công cụ cơ bản của Unity Terrain để thay đổi hình dạng địa hình.</li>
<li>Giải thích cách địa hình (có Terrain Collider) tương tác với các đối tượng Rigidbody.</li>
<li>Thêm các GameObject đơn giản vào Scene và đảm bảo chúng có Collider để tương tác vật lý.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 4.f (Scene View - Navigation/Manipulation), 12.1 (Colliders - Terrain Collider, Box/Sphere Collider for obstacles), 12.3 (Rigidbodies - how they react to terrain changes), 2.1 (Asset Management - Adding environment assets).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.3: Scripting cho Tương tác Vật lý Cơ bản</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Học cách viết và áp dụng script C# cho tương tác vật lý.</li>
<li>Tùy chỉnh chuyển động và hành vi của các đối tượng trong game.</li>
<li>Tạo chuyển động và hành vi của các đối tượng 3D.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Ôn lại cấu trúc cơ bản của một C# Script trong Unity (<code>MonoBehaviour</code>, <code>Start</code>, <code>Update</code>, <code>FixedUpdate</code>).</li>
<li>Tạo một script C# mới.</li>
<li>Lấy tham chiếu đến component Rigidbody (<code>GetComponent&lt;Rigidbody&gt;()</code>).</li>
<li>Sử dụng <code>FixedUpdate</code> cho các thao tác vật lý.</li>
<li>Áp dụng lực (<code>rigidbody.AddForce()</code>) để làm một đối tượng di chuyển (ví dụ: tạo một chướng ngại vật di chuyển đơn giản).</li>
<li>Giới thiệu sơ lược về phát hiện va chạm (<code>OnCollisionEnter</code>).</li>
<li>Gắn script vào một GameObject trong Scene và thử nghiệm.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Một C# script đơn giản điều khiển hành vi vật lý của một GameObject (ví dụ: tạo lực đẩy liên tục hoặc phản ứng khi va chạm).</li>
<li>Một GameObject trong Scene (ví dụ: một khối lập phương) được gắn script và thể hiện hành vi vật lý được lập trình.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Tạo, gắn và chỉnh sửa C# script cho GameObject.</li>
<li>Lấy tham chiếu đến các component khác (đặc biệt là Rigidbody) từ script.</li>
<li>Sử dụng <code>FixedUpdate</code> cho logic vật lý.</li>
<li>Áp dụng lực lên Rigidbody thông qua script.</li>
<li>Hiểu khái niệm cơ bản về xử lý sự kiện va chạm.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 13.2.a (GameObject Components), 13.3.a (Methods/Functions - Start, Update, FixedUpdate, OnCollisionEnter), 13.4.a/b (MonoBehaviour API - Awake, FixedUpdate), 13.8.a.2 (Create a new script), 12.3.a.1/4 (Explain Rigidbodies, Assess impact of forces).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.4: Lập trình Điều khiển Xe Đua</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Lập trình điều khiển xe đua (tăng tốc, phanh, rẽ).</li>
<li>Kiểm tra và điều chỉnh cảm giác lái xe.</li>
<li>Lập trình Điều khiển đối tượng Xe.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Phân tích script điều khiển xe có sẵn trong Karting Microgame (nếu có và phù hợp) hoặc xây dựng script mới.</li>
<li>Đọc input từ người chơi (<code>Input.GetAxis("Vertical")</code>, <code>Input.GetAxis("Horizontal")</code>).</li>
<li>Áp dụng lực về phía trước/sau (<code>AddForce</code>) dựa trên input “Vertical” để tăng tốc/phanh.</li>
<li>Áp dụng mô-men xoắn (<code>AddTorque</code>) dựa trên input “Horizontal” để rẽ trái/phải.</li>
<li>Tinh chỉnh các giá trị lực, mô-men xoắn, lực cản (<code>drag</code>, <code>angularDrag</code> trên Rigidbody) để tạo cảm giác lái mong muốn.</li>
<li>Debug và kiểm tra liên tục trong Play mode.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Một C# script (mới hoặc chỉnh sửa) điều khiển xe đua Kart dựa trên input của người chơi.</li>
<li>Xe đua trong game có thể tăng tốc, phanh và rẽ một cách cơ bản.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Lấy input từ bàn phím/gamepad trong Unity.</li>
<li>Áp dụng lực và mô-men xoắn lên Rigidbody để mô phỏng chuyển động của xe.</li>
<li>Điều chỉnh các thông số vật lý (lực, torque, drag) để thay đổi hành vi của đối tượng.</li>
<li>Debug các vấn đề cơ bản liên quan đến điều khiển và vật lý.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 13.4.b (FixedUpdate), 13.3.a (Methods), 12.3.a.1/3/4 (Explain/Differentiate/Assess Rigidbodies &amp; forces), 7.a.1 (Identify video game controls - relates to Input mapping), 4.d (Inspector - adjusting Rigidbody properties).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.5: Giới thiệu Class và Object trong Game 3D</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Giới thiệu về class và object trong C#.</li>
<li>Xây dựng các class cơ bản cho các đối tượng trong game.</li>
<li>Xây dựng các đối tượng trong game 3D (Xe, Chướng ngại vật).</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Ôn lại khái niệm Class (khuôn mẫu) và Object (thể hiện cụ thể).</li>
<li>Trong script C#, định nghĩa các biến thành viên (<code>fields</code>) để lưu trữ trạng thái của đối tượng (ví dụ: <code>public float speed;</code>, <code>public int health;</code>).</li>
<li>Tạo một class <code>KartController</code> (có thể là script điều khiển xe đã làm) và xác định các thuộc tính quan trọng của xe (tốc độ tối đa, khả năng tăng tốc,…).</li>
<li>Tạo một class <code>Obstacle</code> đơn giản (ví dụ: chứa thông tin về loại chướng ngại vật hoặc hiệu ứng khi va chạm).</li>
<li>Giải thích cách các Component trong Unity thực chất là các Object được tạo từ các Class (ví dụ: <code>Transform</code>, <code>Rigidbody</code>, <code>KartController</code> của bạn).</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Các C# script được cấu trúc lại để thể hiện rõ hơn các thuộc tính (fields) của đối tượng mà chúng đại diện (Xe, Chướng ngại vật).</li>
<li>Hiểu rõ hơn về mối liên hệ giữa Class (trong code) và Object/Component (trong Unity Editor).</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Giải thích khái niệm class và object trong ngữ cảnh lập trình game Unity.</li>
<li>Định nghĩa các biến thành viên (fields) trong một class C# để lưu trữ dữ liệu.</li>
<li>Nhận biết các component trong Unity là các thể hiện (object) của các class.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 13.5.a.1 (Recognize class definitions from provided code), 13.9 (Variables - Define variables: Float, Int, Vector3 within classes), 13.2.a (GameObject Components - recognizing them as objects).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.6: Tổ chức Mã Nguồn với Class &amp; Object</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Phát triển và mở rộng các class.</li>
<li>Áp dụng kiến thức về class và object để tổ chức mã nguồn.</li>
<li>Phát triển các chức năng phức tạp hơn như hệ thống điểm.</li>
<li>Tổ chức Mã Nguồn theo Class &amp; Object.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu các phương thức (<code>methods</code>) trong class để đóng gói hành vi (ví dụ: <code>KartController.Accelerate()</code>, <code>Obstacle.ApplyEffect(KartController kart)</code>).</li>
<li>Sử dụng các access modifiers (<code>public</code>, <code>private</code>) để kiểm soát truy cập vào fields và methods.</li>
<li>Tạo một class <code>GameManager</code> đơn giản để quản lý trạng thái game (ví dụ: điểm số, thời gian).</li>
<li>Lập trình tương tác giữa các object: Xe va chạm vào chướng ngại vật, gọi phương thức của chướng ngại vật; Chướng ngại vật hoặc vật phẩm gọi phương thức của GameManager để cập nhật điểm.</li>
<li>Refactor (tái cấu trúc) code điều khiển xe và xử lý va chạm để sử dụng các phương thức mới tạo.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Mã nguồn C# được tổ chức tốt hơn, sử dụng các phương thức trong class để thực hiện các hành động cụ thể.</li>
<li>Một hệ thống điểm số hoặc cơ chế tương tác cơ bản giữa Xe và Chướng ngại vật/Vật phẩm.</li>
<li>Một class <code>GameManager</code> sơ khai.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Viết và gọi các phương thức trong class C#.</li>
<li>Sử dụng <code>public</code> và <code>private</code> để đóng gói dữ liệu và hành vi.</li>
<li>Thiết kế sự tương tác cơ bản giữa các object thông qua việc gọi phương thức.</li>
<li>Tổ chức mã nguồn game một cách logic hơn bằng cách sử dụng các class riêng biệt cho các vai trò khác nhau (Player, Obstacle, Manager).</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 13.3.a.1 (Explain the purpose of methods), 13.5.a (OOP), 13.8.a.1 (Differentiate public variable within code), 13.2.a.1 (Finalize specific lines of code - applying method calls).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.7: Bổ sung Animation 3D cơ bản</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Tạo animation cho nhân vật và xe.</li>
<li>Học cách sử dụng Animator trong Unity.</li>
<li>Bổ sung 3D Animation cho nhân vật và xe.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu cửa sổ Animation và Animator.</li>
<li>Tạo một Animator Controller asset.</li>
<li>Tìm hiểu về States (trạng thái animation) và Transitions (chuyển đổi giữa các trạng thái).</li>
<li>Sử dụng các animation clips có sẵn trong Karting Microgame (ví dụ: idle, driving, turning).</li>
<li>Tạo các state trong Animator Controller tương ứng với các animation clips.</li>
<li>Tạo các Parameters (ví dụ: <code>Speed</code> kiểu float, <code>IsTurning</code> kiểu bool) để điều khiển transitions.</li>
<li>Thiết lập transitions giữa các state dựa trên giá trị của parameters.</li>
<li>Gắn Animator Controller vào GameObject Xe hoặc Nhân vật.</li>
<li>Viết code C# đơn giản để cập nhật giá trị parameters trong Animator dựa trên trạng thái của xe (ví dụ: <code>animator.SetFloat("Speed", currentSpeed)</code>).</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Một Animator Controller được gắn vào xe/nhân vật.</li>
<li>Xe/nhân vật có thể chuyển đổi giữa các animation cơ bản (ví dụ: đứng yên và lái xe) dựa trên hành động của người chơi.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Sử dụng cửa sổ Animator để tạo và quản lý các trạng thái animation.</li>
<li>Tạo và sử dụng Parameters để điều khiển việc chuyển đổi giữa các trạng thái animation.</li>
<li>Kết nối animation với logic game bằng cách cập nhật Animator Parameters từ script C#.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 1.1.a (Animator Controller Asset - Examine, Apply, Create), 1.1.b (States - Define parameter types, Differentiate states, Create states), 1.1.c (Transitions - Explain conditions, Differentiate properties, Create transitions).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.8: Tinh chỉnh Animation với Blend Tree</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Tìm hiểu và áp dụng Blend Tree cho các animation phức tạp.</li>
<li>Tinh chỉnh hành vi và chuyển động của nhân vật.</li>
<li>Tinh chỉnh hành vi và chuyển động của nhân vật với Blend Tree.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giải thích tại sao cần Blend Tree: Trộn mượt mà nhiều animation dựa trên các giá trị liên tục (ví dụ: kết hợp animation lái thẳng, rẽ trái, rẽ phải dựa trên góc lái).</li>
<li>Tạo một Blend Tree state trong Animator Controller.</li>
<li>Thiết lập Blend Tree: Chọn loại (1D hoặc 2D).</li>
<li>Đối với 1D Blend Tree: Chọn Parameter điều khiển (ví dụ: <code>TurnAngle</code>), thêm các animation clips (lái thẳng, rẽ trái tối đa, rẽ phải tối đa) và thiết lập các ngưỡng (thresholds) tương ứng.</li>
<li>(Tùy chọn nâng cao) Giới thiệu 2D Blend Tree (ví dụ: kết hợp tốc độ và góc lái).</li>
<li>Cập nhật script C# để cung cấp giá trị chính xác cho Parameter điều khiển Blend Tree.</li>
<li>Kiểm tra và tinh chỉnh Blend Tree để animation chuyển động mượt mà theo điều khiển của người chơi.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Một Blend Tree được tích hợp vào Animator Controller của xe/nhân vật.</li>
<li>Animation rẽ lái của xe/nhân vật mượt mà hơn, phản ánh đúng góc lái thay vì chuyển đổi đột ngột.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Giải thích được lợi ích của việc sử dụng Blend Tree.</li>
<li>Tạo và cấu hình một 1D Blend Tree trong Unity Animator.</li>
<li>Kết hợp nhiều animation clip một cách mượt mà dựa trên giá trị Parameter.</li>
<li>Cập nhật giá trị Parameter cho Blend Tree từ script.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 1.1.b (States - Blend Tree là một loại state phức tạp), 1.1.a (Animator Controller), 1.1.c (Transitions - vào/ra khỏi Blend Tree state). <em>Blend Tree không được liệt kê rõ ràng nhưng là phần nâng cao của việc làm chủ States và Transitions.</em></li>
</ul>
<hr>
<p><strong>Buổi 2.1.9: Ôn tập và Hoàn thiện Lý thuyết</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Đánh giá kiến thức về Unity, C#, và tương tác vật lý 3D.</li>
<li>Rà soát và giải đáp thắc mắc.</li>
<li>Kiểm tra lý thuyết và hoàn thiện đề tài.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Ôn tập các khái niệm chính đã học: Rigidbody, Collider, <code>FixedUpdate</code>, <code>AddForce</code>, <code>AddTorque</code>, Class, Object, Method, Animation States, Transitions, Parameters, Blend Trees.</li>
<li>Thực hiện bài kiểm tra lý thuyết ngắn (trắc nghiệm, câu hỏi ngắn) bao gồm các khái niệm trên và liên hệ với UCA objectives.</li>
<li>Phiên Hỏi &amp; Đáp (Q&amp;A) để giải đáp thắc mắc của học sinh.</li>
<li>Học sinh trình bày ngắn gọn tiến độ dự án “Karting Adventure” của mình, nêu khó khăn và kế hoạch hoàn thiện.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Kết quả bài kiểm tra lý thuyết của học sinh.</li>
<li>Danh sách các vấn đề/khó khăn học sinh đang gặp phải trong dự án.</li>
<li>Kế hoạch sơ bộ cho các buổi tiếp theo để hoàn thiện game.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Hệ thống hóa lại các kiến thức đã học trong học phần.</li>
<li>Xác định được các điểm mạnh và yếu của bản thân trong việc áp dụng kiến thức.</li>
<li>Trình bày được tiến độ và kế hoạch cho dự án cá nhân.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> Tổng hợp các objectives đã đề cập từ 2.1.1 đến 2.1.8. Tập trung vào việc hiểu và giải thích các khái niệm.</li>
</ul>
<hr>
<p><strong>Buổi 2.1.10: Case Study - Tối ưu hóa và Hoàn thiện Game</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Cải tiến mã nguồn, rà soát các lỗi khi chơi game.</li>
<li>Tối ưu hóa hiệu suất và khắc phục lỗi.</li>
<li>Thêm các chi tiết cuối cùng như âm thanh và UI.</li>
<li>Case Study - Tối ưu Game.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu cửa sổ Profiler: Cách đọc các thông số cơ bản (CPU Usage, Rendering). Chạy game và quan sát Profiler.</li>
<li>Thảo luận các kỹ thuật tối ưu hóa đơn giản (không đi sâu): Sử dụng Prefabs hiệu quả, Collision Layer Matrix (giảm kiểm tra va chạm không cần thiết), tối ưu hóa script (tránh <code>GetComponent</code> trong <code>Update</code>).</li>
<li>Thêm <code>AudioSource</code> vào xe: Gắn các audio clips cho tiếng động cơ, tiếng va chạm (<code>Play</code>, <code>PlayOneShot</code>).</li>
<li>Xây dựng giao diện người dùng (UI) cơ bản: Sử dụng Canvas, Text để hiển thị điểm số hoặc thời gian (lấy dữ liệu từ GameManager).</li>
<li>Playtesting tập trung: Tìm và sửa các lỗi logic, lỗi vật lý, lỗi điều khiển còn sót lại.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Game “Karting Adventure” có thêm hiệu ứng âm thanh cơ bản.</li>
<li>Giao diện UI đơn giản hiển thị thông tin game (điểm/thời gian).</li>
<li>Một số lỗi được khắc phục, game chạy mượt mà hơn (có thể).</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Sử dụng Profiler để xác định các điểm có thể gây chậm game (ở mức cơ bản).</li>
<li>Áp dụng một vài kỹ thuật tối ưu hóa đơn giản.</li>
<li>Thêm và điều khiển AudioSource từ script.</li>
<li>Tạo và cập nhật các thành phần UI cơ bản (Text).</li>
<li>Thực hiện quy trình playtest và sửa lỗi một cách có hệ thống hơn.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 12.2 (Optimization and Debugging - Conceptual understanding), 3.1/3.1.a (Audio Source/Properties), 16.2 (Canvas), 16.3 (Image/Text - implied), 16.4 (Rect Tool), 16.5 (Slider - maybe for sound volume), 14.a/b (Project Management - Layers/Tags for optimization). 19.5 (Understand the build process - conceptual introduction to optimization).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.11: Case Study - Hoàn thiện và Đánh bóng Game</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Hoàn thiện các chi tiết cuối cùng và chuẩn bị cho buổi trình bày dự án.</li>
<li>Case Study - Hoàn thiện game.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Tập trung vào “Game Feel”: Tinh chỉnh lại các thông số vật lý của xe (mass, drag, friction), camera theo dõi (nếu có script camera riêng), độ nhạy điều khiển.</li>
<li>Rà soát UI: Đảm bảo dễ nhìn, thông tin chính xác. Thêm các màn hình đơn giản (Menu chính, Game Over) nếu có thời gian.</li>
<li>Kiểm tra lại âm thanh: Âm lượng phù hợp, đúng thời điểm.</li>
<li>Playtesting lần cuối: Chơi game từ đầu đến cuối, đảm bảo không có lỗi nghiêm trọng.</li>
<li>Chuẩn bị bản build (Web GL hoặc Windows/Mac) để trình bày (hướng dẫn các bước Build Settings).</li>
<li>Chuẩn bị nội dung trình bày: Giới thiệu game, các tính năng đã làm, khó khăn gặp phải, bài học kinh nghiệm.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Phiên bản game “Karting Adventure” hoàn chỉnh nhất có thể trong thời gian cho phép.</li>
<li>(Tùy chọn) Một bản build chạy được của game.</li>
<li>Dàn ý cho bài trình bày cuối khóa.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Tinh chỉnh các thông số để cải thiện trải nghiệm người chơi.</li>
<li>Thực hiện các bước cuối cùng để hoàn thiện một dự án game nhỏ.</li>
<li>Build dự án Unity thành một ứng dụng chạy được (ở mức cơ bản).</li>
<li>Chuẩn bị và cấu trúc một bài trình bày về dự án của mình.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> Tổng hợp các objectives liên quan đến Physics (12), Programming (13), Animation (1), Audio (3), UI (16). Đặc biệt: 19.2 (Build a game), 19.4 (Refine build settings).</li>
</ul>
<hr>
<p><strong>Buổi 2.1.12: Tổng Kết Dự Án và Trình Bày</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Tổng Kết Dự Án.</li>
<li>Học sinh trình bày sản phẩm game “Karting Adventure” của mình.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Lần lượt từng học sinh (hoặc nhóm) trình bày dự án game của mình:
<ul>
<li>Chạy demo game.</li>
<li>Giới thiệu các tính năng chính đã phát triển/thay đổi so với Microgame gốc.</li>
<li>Chia sẻ về quá trình thực hiện, những khó khăn và cách giải quyết.</li>
<li>Nêu những bài học kinh nghiệm rút ra.</li>
</ul>
</li>
<li>Phiên góp ý từ giáo viên và các bạn học sinh khác.</li>
<li>Giáo viên tổng kết lại toàn bộ học phần, nhấn mạnh các kiến thức và kỹ năng cốt lõi đã học, liên hệ lại với các mục tiêu UCA.</li>
<li>Khuyến khích học sinh tiếp tục phát triển dự án hoặc khám phá các chủ đề mới trong Unity.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Các dự án game “Karting Adventure” được trình bày.</li>
<li>Phản hồi, góp ý cho từng dự án.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Trình bày và giới thiệu sản phẩm kỹ thuật của mình một cách rõ ràng.</li>
<li>Tiếp nhận và đưa ra phản hồi mang tính xây dựng.</li>
<li>Tổng kết được quá trình học tập và những kỹ năng đã đạt được trong học phần.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 5.1.a.1 (Define “critique” in the context of video game development - through giving/receiving feedback). Tổng hợp và củng cố hiểu biết về các objectives đã học qua việc trình bày và xem sản phẩm thực tế.</li>
</ul>
<hr>
<h2 id="giáo-án-chi-tiết">Giáo án chi tiết</h2>
<h3 id="giáo-án-buổi-học-2.1.1-khám-phá-vật-lý-3d-với-karting-microgame">Giáo án Buổi học 2.1.1: Khám phá Vật lý 3D với Karting Microgame</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>Học sinh (HS) nhận biết và mô tả được các khái niệm cơ bản về môi trường vật lý 3D trong Unity (Rigidbody, Collider).</li>
<li>HS làm quen với giao diện Unity Editor thông qua Karting Microgame, xác định được các cửa sổ chính (Scene, Game, Hierarchy, Inspector, Project).</li>
<li>HS thực hiện thành công các bước cài đặt, mở Karting Microgame template theo tài liệu hướng dẫn.</li>
<li>HS bắt đầu hình thành ý tưởng sơ bộ để mở rộng hoặc tùy chỉnh dự án Karting Microgame.</li>
<li>Giới thiệu tổng quan về dự án “Karting Adventure” sẽ thực hiện trong học phần.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính cài đặt sẵn Unity Hub cho mỗi HS.</li>
<li>Kết nối Internet ổn định.</li>
<li>Máy chiếu và máy tính cho Giáo viên (GV).</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Hướng dẫn cài đặt và Khám phá Karting Microgame” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>Video ngắn giới thiệu Karting Microgame hoặc một game đua xe vật lý 3D hấp dẫn (tùy chọn).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Hướng dẫn cài đặt và Khám phá Karting Microgame"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Mục tiêu của tài liệu là giúp bạn cài đặt và mở dự án Karting Microgame trong Unity.</li>
<li><strong>Yêu cầu:</strong> Đã cài đặt Unity Hub.</li>
<li><strong>Bước 1: Mở Unity Hub:</strong> Hướng dẫn cách khởi chạy Unity Hub.</li>
<li><strong>Bước 2: Tìm Karting Microgame:</strong>
<ul>
<li>Trong Unity Hub, điều hướng đến tab “Projects” -&gt; “New project”.</li>
<li>Chọn phiên bản Unity Editor phù hợp (ví dụ: 2021.3 LTS hoặc theo khuyến nghị của GV).</li>
<li>Trong danh sách Templates, tìm và chọn “Karting Microgame”. <em>(Có thể cần cuộn xuống hoặc tìm trong mục Learning Templates)</em>.</li>
<li><em>Hình ảnh minh họa vị trí template.</em></li>
</ul>
</li>
<li><strong>Bước 3: Tạo Dự án Mới:</strong>
<ul>
<li>Đặt tên cho dự án (ví dụ: “MyKartingAdventure”).</li>
<li>Chọn vị trí lưu dự án trên máy tính.</li>
<li>Nhấn nút “Create project”.</li>
<li><em>Lưu ý: Quá trình này có thể mất vài phút để tải và nhập assets.</em></li>
</ul>
</li>
<li><strong>Bước 4: Mở Dự án trong Unity Editor:</strong> Sau khi tạo xong, dự án sẽ tự động mở trong Unity Editor. Nếu không, bạn có thể mở lại từ Unity Hub.</li>
<li><strong>Bước 5: Khám phá ban đầu:</strong>
<ul>
<li>Xác định cửa sổ Project: Tìm thư mục <code>Scenes</code>. Mở Scene chính (thường có tên như <code>Karting</code>, <code>Main</code>, hoặc tương tự).</li>
<li>Xác định cửa sổ Scene: Quan sát không gian 3D của đường đua.</li>
<li>Xác định cửa sổ Game: Đây là nơi bạn sẽ thấy game khi chạy.</li>
<li>Xác định cửa sổ Hierarchy: Tìm GameObject có tên giống “Kart”, “PlayerKart” hoặc tương tự.</li>
<li>Xác định cửa sổ Inspector: Nhấp vào GameObject “Kart” trong Hierarchy và xem các thông tin hiển thị trong Inspector.</li>
</ul>
</li>
<li><strong>Bước 6: Chạy thử Game:</strong>
<ul>
<li>Nhấn nút Play (hình tam giác) ở phía trên trung tâm màn hình Editor.</li>
<li>Sử dụng các phím mũi tên (hoặc WASD) để lái thử xe trong cửa sổ Game.</li>
<li>Nhấn lại nút Play để dừng game.</li>
</ul>
</li>
<li><strong>Troubleshooting (Gỡ rối thường gặp):</strong>
<ul>
<li>Không tìm thấy template: Đảm bảo chọn đúng phiên bản Editor, kiểm tra kết nối mạng.</li>
<li>Dự án mở ra báo lỗi: Thử khởi động lại Unity, kiểm tra console log (Window -&gt; General -&gt; Console). Báo cho GV nếu không tự khắc phục được.</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chiếu một đoạn video ngắn (1-2 phút) giới thiệu Karting Microgame hoặc một game đua xe 3D vui nhộn, nhấn mạnh vào các yếu tố vật lý (va chạm, nhảy, drift…).</li>
<li>Đặt câu hỏi gợi mở:
<ul>
<li>“Điều gì làm cho chiếc xe trong game có vẻ ‘thật’ khi nó va chạm hay bay lên không?”</li>
<li>“Làm thế nào game biết được khi nào xe chạm vào tường?”</li>
<li>“Chúng ta sẽ cùng tìm hiểu cách tạo ra những tương tác vật lý thú vị này trong Unity!”</li>
</ul>
</li>
<li>GV giới thiệu ngắn gọn về dự án “Karting Adventure” sẽ xây dựng dựa trên Karting Microgame, nơi HS sẽ tự tay chỉnh sửa, thêm tính năng và lập trình cho game đua xe của riêng mình.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo hứng thú, kết nối với trải nghiệm chơi game của HS, giới thiệu chủ đề vật lý 3D và dự án học phần.</li>
</ul>
<p><strong>2. Explore (Khám phá - 35 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Hướng dẫn cài đặt và Khám phá Karting Microgame”</strong> và yêu cầu HS mở tài liệu này (trên máy tính hoặc bản in nếu có).</li>
<li>HS tự thực hiện theo các bước trong tài liệu để:
<ul>
<li>Tìm và tạo dự án mới từ template Karting Microgame qua Unity Hub.</li>
<li>Mở dự án trong Unity Editor.</li>
<li>Xác định các cửa sổ chính (Scene, Game, Hierarchy, Inspector, Project).</li>
<li>Tìm và mở Scene chính.</li>
<li>Nhấn Play và lái thử xe trong cửa sổ Game.</li>
<li>Tìm GameObject chiếc xe (“Kart”) trong Hierarchy.</li>
<li>Quan sát các thành phần (Components) của chiếc xe trong Inspector.</li>
</ul>
</li>
<li>GV đóng vai trò người hướng dẫn:
<ul>
<li>Quan sát tiến trình của HS.</li>
<li>Hỗ trợ cá nhân những HS gặp khó khăn trong quá trình cài đặt hoặc tìm kiếm (dựa trên tài liệu hướng dẫn và mục troubleshooting).</li>
<li>Khuyến khích HS tự tìm tòi, khám phá giao diện trước khi giải thích chi tiết. <em>Tránh giải thích sâu về khái niệm ở giai đoạn này.</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp, làm quen với quy trình tạo dự án từ template, tự mình khám phá giao diện và các thành phần cơ bản của Microgame. HS thực hành kỹ năng đọc hiểu và làm theo hướng dẫn kỹ thuật.</li>
</ul>
<p><strong>3. Explain (Giải thích - 30 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp lại, sử dụng máy chiếu để demo trên Unity Editor đã mở sẵn Karting Microgame.</li>
<li><strong>Thảo luận có hướng dẫn &amp; Demo:</strong>
<ul>
<li>“Khi khám phá, các bạn đã sử dụng những cửa sổ nào? Chức năng chính của chúng là gì?” -&gt; GV hệ thống lại tên và chức năng cơ bản của 5 cửa sổ chính:
<ul>
<li><strong>Hierarchy:</strong> Liệt kê tất cả đối tượng (GameObjects) trong Scene hiện tại. (UCA 2.10)</li>
<li><strong>Scene:</strong> Nơi sắp xếp, xây dựng thế giới 3D của game. (UCA 2.7)</li>
<li><strong>Game:</strong> Khung nhìn của người chơi khi game chạy. (UCA 2.3)</li>
<li><strong>Project:</strong> Nơi chứa tất cả tài nguyên (assets) của dự án (scripts, models, textures, scenes…). (UCA 2.5, 2.12)</li>
<li><strong>Inspector:</strong> Hiển thị thông tin chi tiết và các thành phần (Components) của GameObject đang được chọn. (UCA 2.11, 2.13)</li>
</ul>
</li>
<li>“Khi các bạn chọn chiếc xe (Kart) trong Hierarchy, các bạn thấy gì trong Inspector?” -&gt; Giới thiệu khái niệm <strong>GameObject</strong> (Đối tượng trong game - UCA 3.2, 3.6) và <strong>Component</strong> (Thành phần chức năng gắn vào GameObject - UCA 3.3).</li>
<li>GV chỉ vào Component <code>Transform</code> (luôn có) và yêu cầu HS tìm 2 component quan trọng liên quan đến vật lý:
<ul>
<li><strong>Rigidbody:</strong> Thành phần giúp GameObject tuân theo các định luật vật lý (trọng lực, lực tác động, va chạm). <em>Đây là thứ làm xe ‘rơi’, ‘bay’, ‘lăn’</em>. (UCA 12.3)</li>
<li><strong>Collider (Box Collider, Sphere Collider, Mesh Collider…):</strong> Định nghĩa hình dạng vật lý của GameObject để hệ thống biết khi nào xảy ra va chạm. <em>Đây là thứ giúp xe ‘chạm’ vào đường đua, tường…</em> (UCA 12.1)</li>
</ul>
</li>
<li>GV nhấn mạnh sự khác biệt: Rigidbody để <em>phản ứng</em> vật lý, Collider để <em>phát hiện</em> va chạm.</li>
<li>Liên hệ C#: “Chúng ta sẽ dùng C# để ‘nói chuyện’ với các Component này, ví dụ như bảo Rigidbody ‘chạy tới’ hay thay đổi thông số của Collider.”</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Hệ thống hóa kiến thức HS đã tự khám phá, giới thiệu và giải thích các thuật ngữ quan trọng (GameObject, Component, Rigidbody, Collider, các cửa sổ Editor), liên kết với các mục tiêu của UCA.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Think-Pair-Share):</strong>
<ul>
<li><strong>Think (Cá nhân - 3 phút):</strong> “Dựa trên những gì đã thấy, hãy nghĩ ra 2-3 ý tưởng đơn giản để làm cho game Karting này thú vị hơn hoặc khác đi một chút. Ví dụ: thêm một đoạn đường nhảy, một chướng ngại vật mới, thay đổi màu xe…” Viết ra giấy hoặc ghi chú nhanh.</li>
<li><strong>Pair (Theo cặp - 5 phút):</strong> Chia sẻ ý tưởng với bạn ngồi cạnh. Thảo luận xem ý tưởng nào khả thi, ý tưởng nào cần đến vật lý, ý tưởng nào cần đến lập trình.</li>
<li><strong>Share (Cả lớp - 7 phút):</strong> GV mời một vài cặp chia sẻ ý tưởng nổi bật của họ. GV có thể gợi ý nhẹ nhàng về việc ý tưởng đó liên quan đến việc thêm/thay đổi GameObject, Collider, hay cần script C# (sẽ học sau).</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích tư duy sáng tạo, áp dụng hiểu biết ban đầu về cấu trúc game để lên ý tưởng mở rộng, chuẩn bị cho các buổi học tiếp theo.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Câu hỏi nhanh / Exit Ticket (viết ra giấy hoặc trả lời miệng):</strong>
<ol>
<li>Component nào trong Unity giúp một vật thể chịu tác động của trọng lực và lực đẩy? (Đáp án: Rigidbody)</li>
<li>Để hai vật thể có thể va chạm vào nhau, chúng cần có component gì? (Đáp án: Collider)</li>
<li>Kể tên 2 cửa sổ Unity Editor bạn đã sử dụng hôm nay và chức năng chính của chúng. (Ví dụ: Hierarchy - liệt kê đối tượng; Inspector - xem chi tiết đối tượng).</li>
</ol>
</li>
<li><strong>Quan sát:</strong> GV đánh giá mức độ tham gia của HS trong các hoạt động, khả năng hoàn thành các bước trong tài liệu hướng dẫn, và mức độ hiểu qua các câu trả lời/ý tưởng chia sẻ.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Kiểm tra nhanh mức độ nắm bắt các khái niệm cốt lõi (Rigidbody, Collider, các cửa sổ Editor). Đánh giá khả năng làm theo hướng dẫn và mức độ tham gia của HS.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt nhanh những gì đã học: làm quen Unity Editor, Karting Microgame, khái niệm vật lý cơ bản.</li>
<li>Nhắc nhở về dự án “Karting Adventure” và giới thiệu sơ lược nội dung buổi học tiếp theo (điều chỉnh địa hình).</li>
<li>Khuyến khích HS tự khám phá thêm về Karting Microgame nếu có thời gian ở nhà.</li>
</ul>
<hr>
<p><strong>Lưu ý về Đa dạng hóa:</strong></p>
<ul>
<li><strong>Vận động:</strong> Trong giai đoạn Explore, GV có thể yêu cầu HS đứng dậy và di chuyển để hỗ trợ bạn khác nếu hoàn thành sớm.</li>
<li><strong>Thị giác:</strong> Sử dụng nhiều hình ảnh minh họa trong tài liệu hướng dẫn và khi trình bày trên máy chiếu.</li>
<li><strong>Tương tác:</strong> Hoạt động Pair-Share và thảo luận cả lớp tăng cường tương tác.</li>
<li><strong>Cá nhân hóa:</strong> GV hỗ trợ riêng cho HS gặp khó khăn, HS hoàn thành sớm có thể được khuyến khích thử thay đổi một vài giá trị đơn giản trong Inspector (ví dụ: Mass của Rigidbody) và quan sát kết quả khi Play.</li>
<li><strong>Tài liệu đọc:</strong> Cung cấp tài liệu rõ ràng, có cấu trúc giúp HS tự chủ hơn trong việc học và thực hành các bước kỹ thuật.</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.2-tinh-chỉnh-địa-hình-và-môi-trường-vật-lý">Giáo án Buổi học 2.1.2: Tinh chỉnh Địa hình và Môi trường Vật lý</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành buổi 2.1.1.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS sử dụng được các công cụ cơ bản của Unity Terrain (Raise/Lower, Smooth) để chỉnh sửa địa hình có sẵn.</li>
<li>HS thêm được các đối tượng 3D nguyên thủy (Primitive) vào Scene và gắn Collider phù hợp để tạo chướng ngại vật tĩnh.</li>
<li>HS giải thích được vai trò của Terrain Collider và cách nó tương tác với Rigidbody của xe đua.</li>
<li>HS nhận thức được tầm quan trọng của việc Playtesting thường xuyên khi điều chỉnh các yếu tố vật lý trong môi trường game.</li>
<li>HS áp dụng kiến thức để tạo ra những thay đổi có chủ đích trên đường đua Karting Microgame, ảnh hưởng đến trải nghiệm lái xe.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Microgame từ buổi trước cho mỗi HS.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Hướng dẫn sử dụng Unity Terrain cơ bản và Thêm chướng ngại vật” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Hình ảnh hoặc video ngắn về các loại địa hình thú vị trong game đua xe (dốc, khúc cua, chướng ngại vật).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Hướng dẫn sử dụng Unity Terrain cơ bản và Thêm chướng ngại vật"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Mục tiêu là giúp bạn làm quen với công cụ Terrain của Unity để thay đổi đường đua và thêm các vật cản đơn giản.</li>
<li><strong>Bước 1: Chọn đối tượng Terrain:</strong>
<ul>
<li>Trong cửa sổ Hierarchy, tìm và chọn GameObject đại diện cho đường đua/mặt đất (thường có tên chứa “Terrain”).</li>
<li>Quan sát cửa sổ Inspector, bạn sẽ thấy component “Terrain”.</li>
</ul>
</li>
<li><strong>Bước 2: Làm quen với Công cụ Terrain:</strong>
<ul>
<li>Trong Inspector, tìm thanh công cụ của component Terrain (các biểu tượng như cây cọ, núi…).</li>
<li><em>Hình ảnh minh họa thanh công cụ Terrain.</em></li>
</ul>
</li>
<li><strong>Bước 3: Nâng/Hạ Địa hình:</strong>
<ul>
<li>Nhấp vào biểu tượng thứ hai (thường là hình ngọn núi hoặc mũi tên lên/xuống) - “Paint Terrain” -&gt; Chọn “Raise or Lower Terrain” từ menu thả xuống.</li>
<li>Chọn một loại “Brush” (cọ vẽ) và điều chỉnh “Brush Size” (kích thước), “Opacity” (độ mạnh).</li>
<li>Di chuyển chuột vào cửa sổ Scene, bạn sẽ thấy hình tròn biểu thị cọ vẽ.</li>
<li><strong>Nhấp và kéo chuột trái:</strong> Để nâng địa hình lên.</li>
<li><strong>Giữ phím Shift + Nhấp và kéo chuột trái:</strong> Để hạ địa hình xuống.</li>
<li>Thử tạo một vài đồi nhỏ hoặc hố trên đường đua.</li>
<li><em>Hình ảnh minh họa chọn công cụ và thao tác.</em></li>
</ul>
</li>
<li><strong>Bước 4: Làm Mịn Địa hình:</strong>
<ul>
<li>Vẫn trong “Paint Terrain”, chọn “Smooth Height” từ menu thả xuống.</li>
<li>Sử dụng cọ vẽ này để làm mượt các góc cạnh hoặc chỗ gồ ghề bạn vừa tạo.</li>
<li><em>Hình ảnh minh họa chọn công cụ làm mịn.</em></li>
</ul>
</li>
<li><strong>Bước 5: Playtest!</strong>
<ul>
<li>Sau khi chỉnh sửa, <em>hãy nhấn Play ngay</em> và lái thử xe qua khu vực bạn vừa thay đổi. Cảm nhận sự khác biệt! Đây là bước rất quan trọng.</li>
</ul>
</li>
<li><strong>Bước 6: Thêm Chướng ngại vật tĩnh:</strong>
<ul>
<li>Trên thanh Menu chính của Unity, chọn <code>GameObject</code> -&gt; <code>3D Object</code> -&gt; <code>Cube</code> (hoặc Sphere, Cylinder…).</li>
<li>Một khối Cube sẽ xuất hiện trong Scene và Hierarchy.</li>
<li>Sử dụng các công cụ Transform (Move Tool - phím W, Rotate Tool - E, Scale Tool - R) để di chuyển, xoay và thay đổi kích thước khối Cube, đặt nó ở vị trí bạn muốn trên đường đua để làm chướng ngại vật.</li>
<li><em>Quan trọng:</em> Chọn khối Cube trong Hierarchy, nhìn vào Inspector. Đảm bảo nó có một component <code>Box Collider</code> (hoặc Sphere Collider nếu bạn chọn Sphere). Component này giúp xe va chạm được với nó. Nếu chưa có, nhấn “Add Component” và tìm “Box Collider”.</li>
<li><em>Hình ảnh minh họa thêm Cube và kiểm tra Collider.</em></li>
</ul>
</li>
<li><strong>Bước 7: Playtest lần nữa!</strong>
<ul>
<li>Nhấn Play và thử lái xe va chạm vào chướng ngại vật bạn vừa tạo.</li>
</ul>
</li>
<li><strong>Lưu ý:</strong>
<ul>
<li>Terrain Collider là một component đặc biệt tự động được tạo cùng Terrain, nó định nghĩa hình dạng vật lý cho toàn bộ địa hình.</li>
<li>Luôn lưu Scene (Ctrl + S / Cmd + S) sau khi chỉnh sửa.</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV bắt đầu bằng câu hỏi: “Ở buổi trước, chúng ta đã thấy chiếc xe tương tác với đường đua. Theo các bạn, nếu đường đua không bằng phẳng mà có dốc, có ổ gà thì chuyện gì sẽ xảy ra với chiếc xe?”</li>
<li>(Tùy chọn) Chiếu một vài hình ảnh/video ngắn về các màn đua xe có địa hình phức tạp (đường dốc nhảy, khúc cua nghiêng, chướng ngại vật…).</li>
<li>GV dẫn dắt: “Hôm nay, chúng ta sẽ không chỉ lái xe trên đường đua có sẵn mà còn tự tay ‘nặn’ lại đường đua đó, tạo ra những thử thách mới bằng cách thay đổi độ cao và thêm các vật cản. Hãy xem việc này ảnh hưởng đến vật lý của xe như thế nào!”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Kích thích sự tò mò về ảnh hưởng của môi trường lên vật lý, kết nối với bài học trước, tạo hứng thú cho việc tự tay chỉnh sửa môi trường game.</li>
</ul>
<p><strong>2. Explore (Khám phá - 40 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Hướng dẫn sử dụng Unity Terrain cơ bản và Thêm chướng ngại vật”</strong>.</li>
<li>HS mở dự án Karting Microgame từ buổi trước và thực hiện theo các bước trong tài liệu:
<ul>
<li>Chọn đối tượng Terrain.</li>
<li>Sử dụng công cụ “Raise or Lower Terrain” để tạo đồi/hố.</li>
<li>Sử dụng công cụ “Smooth Height” để làm mịn.</li>
<li><strong>Thực hiện Playtest thường xuyên</strong> sau mỗi vài thay đổi nhỏ để cảm nhận sự khác biệt khi lái xe qua địa hình mới.</li>
<li>Tạo các GameObject 3D Primitive (Cube, Sphere…).</li>
<li>Sử dụng Move/Rotate/Scale Tool để đặt chúng làm chướng ngại vật.</li>
<li>Kiểm tra và đảm bảo các chướng ngại vật có Collider.</li>
<li>Playtest việc va chạm với chướng ngại vật.</li>
</ul>
</li>
<li>GV di chuyển quanh lớp:
<ul>
<li>Quan sát HS thao tác với Terrain Tools và các công cụ Transform.</li>
<li>Hỗ trợ HS gặp khó khăn khi tìm công cụ hoặc khi đối tượng không hoạt động như mong đợi (ví dụ: quên thêm Collider).</li>
<li><em>Quan trọng:</em> Nhắc nhở HS liên tục Playtest. Hỏi các câu hỏi gợi ý trong lúc HS làm: “Em thấy xe phản ứng thế nào khi leo dốc em vừa tạo?”, “Tại sao xe lại đi xuyên qua tảng đá đó?” (Nếu quên Collider).</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp các công cụ chỉnh sửa môi trường, trải nghiệm mối quan hệ nhân quả giữa việc thay đổi môi trường và phản ứng vật lý của xe, rèn luyện kỹ năng sử dụng các công cụ Transform và tầm quan trọng của Playtesting.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, sử dụng máy chiếu demo lại các thao tác chính HS vừa thực hiện.</li>
<li><strong>Thảo luận và Giải thích:</strong>
<ul>
<li>“Các bạn đã dùng những công cụ nào để thay đổi địa hình?” -&gt; GV review nhanh công cụ Raise/Lower, Smooth trong Terrain Inspector.</li>
<li>“Điều gì quyết định hình dạng vật lý của cả khu vực địa hình rộng lớn đó?” -&gt; Giới thiệu kỹ hơn về <strong>Terrain Collider</strong>, nhấn mạnh nó là một loại Collider đặc biệt, hiệu quả cho địa hình. So sánh nó với các Collider đơn giản hơn (Box, Sphere) dùng cho chướng ngại vật. (UCA 12.1)</li>
<li>“Tại sao chúng ta phải thêm Box Collider cho khối Cube làm chướng ngại vật?” -&gt; Củng cố lại vai trò của Collider trong việc phát hiện va chạm. Nếu không có Collider, hệ thống vật lý sẽ “không nhìn thấy” vật thể đó.</li>
<li>“Tại sao việc nhấn Play thường xuyên lại quan trọng khi chỉnh sửa địa hình và vật lý?” -&gt; Thảo luận về tầm quan trọng của <strong>Playtesting</strong>: Giúp cảm nhận trực tiếp “game feel”, phát hiện lỗi vật lý sớm (xe bị kẹt, bay lên trời…), điều chỉnh thông số cho phù hợp.</li>
<li>Liên hệ Rigidbody: “Khi địa hình thay đổi (dốc hơn, gồ ghề hơn), hoặc khi xe va vào đá, chính component Rigidbody trên xe là thứ tính toán và phản ứng lại với những thay đổi/va chạm đó dựa trên thông tin từ Terrain Collider và Box Collider.” (UCA 12.3)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Hệ thống hóa kiến thức về Terrain tools, Terrain Collider, các Collider cơ bản. Nhấn mạnh vai trò của Playtesting trong phát triển game, đặc biệt là với các yếu tố vật lý. Củng cố mối liên hệ giữa Collider và Rigidbody.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử thách nhỏ / Mini-Challenge):</strong>
<ul>
<li>GV đưa ra một vài thử thách nhỏ để HS áp dụng kỹ năng vừa học:
<ul>
<li>“Hãy tạo một đoạn dốc ngắn đủ để xe có thể ‘bay’ một chút khi đi qua.”</li>
<li>“Hãy dùng 3 khối Cube (hoặc Cylinder) để tạo thành một chướng ngại vật hình chữ U mà xe phải lách qua.”</li>
<li>“Hãy làm một khu vực đường hơi gồ ghề, mấp mô.”</li>
</ul>
</li>
<li>HS chọn 1 thử thách và thực hiện trên đường đua của mình.</li>
<li>Khuyến khích HS quan sát bạn khác làm và trao đổi cách thực hiện.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Áp dụng kiến thức vào việc tạo ra một yếu tố môi trường cụ thể có chủ đích, thúc đẩy giải quyết vấn đề và sáng tạo trong giới hạn công cụ đã học.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Show and Tell ngắn:</strong> GV mời 2-3 HS chia sẻ nhanh màn hình, demo thử thách nhỏ họ vừa thực hiện hoặc một thay đổi địa hình/chướng ngại vật mà họ tâm đắc. Yêu cầu HS giải thích ngắn gọn họ đã làm gì và nó ảnh hưởng đến xe như thế nào.</li>
<li><strong>Câu hỏi nhanh:</strong>
<ol>
<li>Công cụ nào dùng để làm mượt địa hình? (Đáp án: Smooth Height)</li>
<li>Loại Collider nào thường được dùng cho địa hình lớn? (Đáp án: Terrain Collider)</li>
<li>Tại sao cần Playtest thường xuyên khi làm game, đặc biệt là với vật lý? (Đáp án: Để cảm nhận, tìm lỗi, điều chỉnh sớm).</li>
</ol>
</li>
<li><strong>Quan sát:</strong> GV đánh giá khả năng hoàn thành thử thách, mức độ hiểu biết qua phần trình bày và trả lời câu hỏi.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng áp dụng công cụ Terrain và Collider vào mục đích cụ thể, kiểm tra việc ghi nhớ thuật ngữ và hiểu tầm quan trọng của Playtesting.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt các kỹ năng chính: Sử dụng Terrain tools, thêm vật thể có Collider, tầm quan trọng của Playtesting.</li>
<li>Nhấn mạnh rằng việc chỉnh sửa môi trường là một phần quan trọng để tạo ra gameplay thú vị.</li>
<li>Giới thiệu buổi học tiếp theo: “Chúng ta đã thay đổi môi trường tĩnh, buổi sau chúng ta sẽ bắt đầu dùng C# để làm cho các đối tượng ‘sống’ và tương tác với nhau phức tạp hơn.”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.3-scripting-cho-tương-tác-vật-lý-cơ-bản">Giáo án Buổi học 2.1.3: Scripting cho Tương tác Vật lý Cơ bản</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành buổi 2.1.2.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS tạo và gắn được một C# script mới vào một GameObject trong Unity.</li>
<li>HS lấy được tham chiếu đến component Rigidbody từ bên trong script bằng <code>GetComponent&lt;Rigidbody&gt;()</code>.</li>
<li>HS sử dụng được <code>FixedUpdate()</code> để viết mã lệnh liên quan đến vật lý.</li>
<li>HS áp dụng được lực (<code>Rigidbody.AddForce()</code>) lên một đối tượng thông qua script để làm nó di chuyển.</li>
<li>HS sử dụng được <code>Debug.Log()</code> và hàm <code>OnCollisionEnter()</code> để phát hiện và ghi nhận thông tin va chạm cơ bản.</li>
<li>HS hiểu được vai trò của <code>MonoBehaviour</code> và các hàm sự kiện cơ bản (<code>Start</code>, <code>FixedUpdate</code>, <code>OnCollisionEnter</code>).</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Microgame (hoặc dự án HS đang làm) từ buổi trước.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Scripting Vật lý Cơ bản trong Unity với C#” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Một đoạn video ngắn hoặc GIF minh họa một vật thể được điều khiển bằng script (ví dụ: tự di chuyển, phản ứng khi va chạm).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Scripting Vật lý Cơ bản trong Unity với C#"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li>
<p><strong>Giới thiệu:</strong> Mục tiêu là hướng dẫn bạn tạo script C# đầu tiên để điều khiển vật lý của một đối tượng trong Unity, làm cho nó tự di chuyển và phát hiện va chạm.</p>
</li>
<li>
<p><strong>Bước 1: Tạo GameObject để thử nghiệm:</strong></p>
<ul>
<li>Trong Scene, tạo một đối tượng 3D đơn giản: <code>GameObject</code> -&gt; <code>3D Object</code> -&gt; <code>Cube</code>.</li>
<li>Đặt tên cho nó là “MovingCube”.</li>
<li>Chọn “MovingCube” trong Hierarchy.</li>
<li><strong>Quan trọng:</strong> Trong Inspector, nhấn “Add Component”, tìm và thêm “Rigidbody”. Điều này cần thiết để script vật lý có thể hoạt động.</li>
</ul>
</li>
<li>
<p><strong>Bước 2: Tạo C# Script:</strong></p>
<ul>
<li>Trong cửa sổ Project, tìm hoặc tạo một thư mục tên là “Scripts”.</li>
<li>Trong thư mục “Scripts”, nhấp chuột phải -&gt; <code>Create</code> -&gt; <code>C# Script</code>.</li>
<li>Đặt tên cho script là “Mover” (Lưu ý: Tên file phải trùng với tên class bên trong script). Nhấn Enter.</li>
<li><em>Hình ảnh minh họa tạo script.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 3: Gắn Script vào GameObject:</strong></p>
<ul>
<li>Kéo thả file script “Mover” từ cửa sổ Project vào GameObject “MovingCube” trong cửa sổ Hierarchy (hoặc vào Inspector của “MovingCube” khi nó đang được chọn).</li>
<li>Chọn “MovingCube”, kiểm tra trong Inspector xem component “Mover (Script)” đã xuất hiện chưa.</li>
<li><em>Hình ảnh minh họa gắn script.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 4: Viết Code trong Script:</strong></p>
<ul>
<li>Nhấp đúp vào file script “Mover” trong cửa sổ Project để mở nó trong trình soạn thảo code (Visual Studio, VS Code…).</li>
<li>Xóa nội dung mặc định và thay bằng đoạn code sau:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span> <span class="token comment">// Luôn cần dòng này để sử dụng các hàm của Unity</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mover</span> <span class="token punctuation">:</span> MonoBehaviour <span class="token comment">// Tên class phải trùng tên file. Kế thừa từ MonoBehaviour</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> moveSpeed <span class="token operator">=</span> <span class="token number">10f</span><span class="token punctuation">;</span> <span class="token comment">// Biến public để chỉnh tốc độ trong Inspector</span>
    <span class="token keyword">private</span> Rigidbody rb<span class="token punctuation">;</span> <span class="token comment">// Biến private để lưu trữ component Rigidbody</span>

    <span class="token comment">// Hàm Start() chạy một lần khi game bắt đầu và đối tượng được kích hoạt</span>
    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Lấy component Rigidbody gắn cùng trên GameObject này</span>
        rb <span class="token operator">=</span> <span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>Rigidbody<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Mover script started on: "</span> <span class="token operator">+</span> gameObject<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// In ra Console để kiểm tra</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Hàm FixedUpdate() chạy đều đặn theo chu kỳ vật lý (mặc định 50 lần/giây)</span>
    <span class="token comment">// *** Đây là nơi tốt nhất để viết code xử lý vật lý ***</span>
    <span class="token keyword">void</span> <span class="token function">FixedUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Kiểm tra xem rb đã được gán chưa (tránh lỗi)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rb <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// Thêm một lực về phía trước (trục Z dương)</span>
            <span class="token comment">// Vector3.forward là viết tắt của (0, 0, 1)</span>
            rb<span class="token punctuation">.</span><span class="token function">AddForce</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span>forward <span class="token operator">*</span> moveSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Hàm OnCollisionEnter() được gọi khi Collider của đối tượng này va chạm</span>
    <span class="token comment">// với một Collider của đối tượng khác (có Rigidbody)</span>
    <span class="token keyword">void</span> <span class="token function">OnCollisionEnter</span><span class="token punctuation">(</span>Collision collisionInfo<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// In ra tên của đối tượng mà chúng ta vừa va chạm</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Ouch! MovingCube hit: "</span> <span class="token operator">+</span> collisionInfo<span class="token punctuation">.</span>gameObject<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// collisionInfo chứa nhiều thông tin về vụ va chạm (vị trí, lực...)</span>
        <span class="token comment">// Ví dụ: Lấy điểm va chạm</span>
        <span class="token comment">// Debug.Log("Hit point: " + collisionInfo.contacts[0].point);</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích nhanh các phần chính (sẽ được GV giải thích kỹ hơn):</strong>
<ul>
<li><code>using UnityEngine;</code>: Khai báo sử dụng thư viện Unity.</li>
<li><code>public class Mover : MonoBehaviour</code>: Khai báo class, kế thừa <code>MonoBehaviour</code> để Unity nhận diện.</li>
<li><code>public float moveSpeed</code>: Biến public có thể chỉnh trong Inspector.</li>
<li><code>Rigidbody rb;</code>: Biến để giữ tham chiếu tới Rigidbody.</li>
<li><code>Start()</code>: Lấy Rigidbody, chạy 1 lần.</li>
<li><code>FixedUpdate()</code>: Nơi áp dụng lực, chạy đều đặn cho vật lý.</li>
<li><code>GetComponent&lt;Rigidbody&gt;()</code>: Hàm tìm component Rigidbody.</li>
<li><code>rb.AddForce()</code>: Hàm tác dụng lực lên Rigidbody. <code>Vector3.forward</code> là hướng.</li>
<li><code>OnCollisionEnter(Collision collisionInfo)</code>: Hàm xử lý khi va chạm bắt đầu.</li>
<li><code>Debug.Log()</code>: In thông điệp ra cửa sổ Console của Unity.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 5: Lưu Script và Quay lại Unity:</strong></p>
<ul>
<li>Lưu file script (Ctrl + S / Cmd + S).</li>
<li>Quay lại cửa sổ Unity Editor. Chờ một chút để Unity biên dịch lại code.</li>
</ul>
</li>
<li>
<p><strong>Bước 6: Mở Console và Playtest:</strong></p>
<ul>
<li>Mở cửa sổ Console: <code>Window</code> -&gt; <code>General</code> -&gt; <code>Console</code>. Cửa sổ này sẽ hiển thị các thông điệp từ <code>Debug.Log()</code>.</li>
<li>Nhấn nút Play.</li>
<li>Quan sát “MovingCube” trong cửa sổ Scene/Game. Nó có tự di chuyển về phía trước không?</li>
<li>Quan sát cửa sổ Console. Bạn có thấy thông điệp “Mover script started…” không?</li>
<li>Đặt một vật thể khác (ví dụ: một Cube tĩnh có Collider) trên đường đi của “MovingCube”. Khi chúng va chạm, bạn có thấy thông điệp “Ouch! MovingCube hit…” trong Console không?</li>
<li>Thử chọn “MovingCube” khi game đang chạy, tìm component “Mover” trong Inspector và thay đổi giá trị “Move Speed”. Quan sát sự thay đổi tốc độ.</li>
<li>Nhấn Play lần nữa để dừng.</li>
</ul>
</li>
<li>
<p><strong>Troubleshooting:</strong></p>
<ul>
<li>Cube không di chuyển: Đảm bảo đã thêm Rigidbody, đã gắn script, code <code>AddForce</code> đúng. Kiểm tra Console xem có lỗi đỏ nào không.</li>
<li>Không thấy thông điệp Console: Đảm bảo đã mở cửa sổ Console, code <code>Debug.Log</code> đúng.</li>
<li>Va chạm không được ghi nhận: Đảm bảo cả hai vật thể đều có Collider, ít nhất một trong hai có Rigidbody (vật thể di chuyển phải có Rigidbody).</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV đặt câu hỏi nối tiếp bài trước: “Chúng ta đã tạo ra các chướng ngại vật tĩnh. Nhưng sẽ thế nào nếu chúng ta muốn một tảng đá tự lăn qua đường, hoặc một cánh cửa tự mở khi xe đến gần? Làm sao để ra lệnh cho chúng di chuyển hay phản ứng?”</li>
<li>GV nhấn mạnh: “Việc điều khiển hành vi động của đối tượng chính là lúc chúng ta cần đến ‘bộ não’ của chúng - đó là các đoạn mã lệnh, hay còn gọi là Scripts!”</li>
<li>(Tùy chọn) Cho xem một GIF/video ngắn về một vật thể đơn giản được script điều khiển (tự di chuyển, đổi màu khi chạm…).</li>
<li>GV giới thiệu mục tiêu: “Hôm nay, chúng ta sẽ viết script C# đầu tiên để làm một khối hộp tự di chuyển và ‘cảm nhận’ được khi nó va vào vật khác.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo sự liên kết logic từ bài trước, nêu bật vai trò của scripting trong việc tạo hành vi động, giới thiệu mục tiêu cụ thể của buổi học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 40 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Scripting Vật lý Cơ bản trong Unity với C#”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li>Tạo Cube mới, thêm Rigidbody.</li>
<li>Tạo C# Script “Mover”.</li>
<li>Gắn script vào Cube.</li>
<li>Copy/paste hoặc gõ lại đoạn code mẫu vào script.</li>
<li>Lưu script và quay lại Unity.</li>
<li>Mở cửa sổ Console.</li>
<li>Nhấn Play và quan sát: Cube di chuyển, thông điệp <code>Start</code> trong Console.</li>
<li>Tạo vật cản tĩnh, cho Cube va chạm và quan sát thông điệp <code>OnCollisionEnter</code> trong Console.</li>
<li>Thử thay đổi giá trị <code>moveSpeed</code> trong Inspector khi game đang chạy.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp HS khắc phục lỗi cú pháp cơ bản nếu gõ sai code.</li>
<li>Giải đáp thắc mắc về các bước trong tài liệu.</li>
<li>Kiểm tra xem HS đã thêm Rigidbody, gắn script đúng chưa.</li>
<li>Khuyến khích HS đọc thông điệp lỗi (nếu có) trong Console.</li>
<li><em>Lưu ý:</em> Giai đoạn này tập trung vào việc <em>làm theo</em> để thấy kết quả, chưa cần hiểu sâu mọi dòng code.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành các bước cơ bản để tạo, gắn và chạy một script C# đơn giản điều khiển vật lý, trải nghiệm quy trình code-save-test, làm quen với cửa sổ Console và Debug.Log.</li>
</ul>
<p><strong>3. Explain (Giải thích - 30 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, mở script “Mover” trên máy chiếu và giải thích từng phần quan trọng trong code HS vừa sử dụng:
<ul>
<li><strong><code>using UnityEngine;</code></strong>: Tại sao cần? (Để dùng các lớp như <code>MonoBehaviour</code>, <code>Rigidbody</code>, <code>Vector3</code>, <code>Debug</code>).</li>
<li><strong><code>public class Mover : MonoBehaviour</code></strong>: <code>MonoBehaviour</code> là gì? (Lớp cơ sở cho mọi script Unity tương tác với game engine, cung cấp các hàm sự kiện như <code>Start</code>, <code>Update</code>, <code>FixedUpdate</code>…).</li>
<li><strong>Biến (<code>public float moveSpeed</code>, <code>private Rigidbody rb</code>)</strong>: Phân biệt <code>public</code> (hiện trong Inspector) và <code>private</code>. Tại sao cần biến <code>rb</code>? (Để lưu trữ tham chiếu, tránh gọi <code>GetComponent</code> nhiều lần).</li>
<li><strong><code>Start()</code></strong>: Chạy khi nào? Dùng để làm gì? (Khởi tạo, lấy tham chiếu ban đầu). <code>GetComponent&lt;Rigidbody&gt;()</code> hoạt động ra sao? (Tìm component cùng loại trên chính GameObject đó).</li>
<li><strong><code>FixedUpdate()</code> vs <code>Update()</code></strong>: Sự khác biệt? Tại sao dùng <code>FixedUpdate</code> cho vật lý? (Chạy đồng bộ với chu kỳ vật lý, đảm bảo tính toán vật lý ổn định).</li>
<li><strong><code>rb.AddForce(Vector3.forward * moveSpeed)</code></strong>: Giải thích <code>AddForce</code> (tác dụng lực), <code>Vector3.forward</code> (hướng Z dương cục bộ), phép nhân vector với số scalar (điều chỉnh độ lớn lực).</li>
<li><strong><code>OnCollisionEnter(Collision collisionInfo)</code></strong>: Hàm sự kiện được Unity tự động gọi khi nào? <code>Collision</code> là gì? (Chứa thông tin về va chạm). <code>collisionInfo.gameObject.name</code> lấy tên đối tượng va chạm.</li>
<li><strong><code>Debug.Log()</code></strong>: Công cụ cực kỳ quan trọng để kiểm tra giá trị, xem code chạy đến đâu.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giải thích rõ ràng ý nghĩa và mục đích của các thành phần code chính, các hàm sự kiện quan trọng của MonoBehaviour, và cách tương tác với Rigidbody thông qua script. Liên kết với các khái niệm UCA (MonoBehaviour API, GetComponent, AddForce, Collision events).</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử nghiệm nhanh):</strong>
<ul>
<li>GV yêu cầu HS thử một vài thay đổi nhỏ ngay trên script “Mover” của mình và quan sát kết quả khi Play:
<ul>
<li>Thay đổi <code>Vector3.forward</code> thành <code>Vector3.right</code> hoặc <code>transform.forward</code> (giải thích nhanh <code>transform.forward</code> là hướng trước của chính đối tượng). Lực tác động thay đổi thế nào?</li>
<li>Thêm một dòng <code>rb.AddTorque(Vector3.up * 10f);</code> vào <code>FixedUpdate()</code>. Điều gì xảy ra? (Đối tượng vừa đi vừa xoay).</li>
<li>Trong <code>OnCollisionEnter</code>, thay đổi <code>Debug.Log</code> thành <code>Destroy(gameObject);</code>. Điều gì xảy ra khi Cube va chạm? (Nó tự biến mất). <em>Lưu ý HS cẩn thận với Destroy.</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS thử nghiệm, tự điều chỉnh code để thấy ngay kết quả, củng cố hiểu biết về các hàm vừa học (<code>AddForce</code>, <code>AddTorque</code>, <code>Destroy</code>).</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh qua Code:</strong> GV yêu cầu HS giơ tay nếu đã làm được Cube tự di chuyển, giơ tay nếu thấy được log va chạm. Đi lướt qua xem nhanh code của một vài HS.</li>
<li><strong>Câu hỏi nhanh (Miệng hoặc viết):</strong>
<ol>
<li>Hàm nào của MonoBehaviour nên được dùng để xử lý vật lý? (<code>FixedUpdate</code>)</li>
<li>Lệnh nào dùng để lấy một component khác (ví dụ: Rigidbody) từ trong script? (<code>GetComponent&lt;T&gt;()</code>)</li>
<li>Lệnh nào dùng để tác dụng lực lên Rigidbody? (<code>AddForce</code>)</li>
<li>Hàm nào được gọi khi có va chạm xảy ra? (<code>OnCollisionEnter</code>)</li>
<li>Làm sao để in một thông điệp ra cửa sổ Console để kiểm tra? (<code>Debug.Log()</code>)</li>
</ol>
</li>
<li><strong>Quan sát:</strong> Mức độ hoàn thành các bước trong Explore, khả năng thử nghiệm trong Elaborate, câu trả lời cho các câu hỏi.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá mức độ nắm vững các hàm và khái niệm cốt lõi của việc scripting vật lý cơ bản.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt: Hôm nay chúng ta đã thành công viết script đầu tiên để điều khiển vật lý, làm đối tượng di chuyển và phát hiện va chạm.</li>
<li>Nhấn mạnh tầm quan trọng của <code>FixedUpdate</code>, <code>GetComponent</code>, <code>AddForce</code>, <code>OnCollisionEnter</code> và <code>Debug.Log</code>.</li>
<li>Giới thiệu buổi học tiếp theo: “Chúng ta đã biết cách ra lệnh cho đối tượng di chuyển, buổi sau sẽ áp dụng kiến thức này và input từ người chơi để lập trình điều khiển cho chính chiếc xe đua Kart!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.4-lập-trình-điều-khiển-xe-đua">Giáo án Buổi học 2.1.4: Lập trình Điều khiển Xe Đua</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành buổi 2.1.3.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS đọc và sử dụng được <code>Input.GetAxis("Horizontal")</code> và <code>Input.GetAxis("Vertical")</code> để nhận tín hiệu điều khiển từ bàn phím (hoặc gamepad).</li>
<li>HS áp dụng <code>Rigidbody.AddForce()</code> để tạo lực đẩy tiến/lùi cho xe dựa trên input “Vertical”.</li>
<li>HS áp dụng <code>Rigidbody.AddTorque()</code> để tạo mô-men xoắn làm xe rẽ trái/phải dựa trên input “Horizontal”.</li>
<li>HS điều chỉnh được các biến public (tốc độ, lực rẽ) trong Inspector để tinh chỉnh cảm giác lái (“game feel”).</li>
<li>HS thực hiện quy trình Playtest - điều chỉnh thông số - Playtest lặp đi lặp lại để đạt được cảm giác điều khiển mong muốn.</li>
<li>HS hiểu được sự cần thiết của việc tinh chỉnh các thông số vật lý (<code>Drag</code>, <code>Angular Drag</code> trên Rigidbody) ảnh hưởng đến hành vi của xe.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Microgame (hoặc dự án HS đang làm) từ buổi trước.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Lập trình Điều khiển Xe đua cơ bản với Input và Vật lý” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Tham khảo script điều khiển xe có sẵn trong Karting Microgame (nếu có và phù hợp để phân tích).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Lập trình Điều khiển Xe đua cơ bản với Input và Vật lý"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li>
<p><strong>Giới thiệu:</strong> Mục tiêu là giúp bạn viết script C# để điều khiển chiếc xe đua Kart bằng các phím mũi tên (hoặc WASD) thông qua việc đọc input và áp dụng lực vật lý.</p>
</li>
<li>
<p><strong>Bước 1: Chuẩn bị Xe đua và Script:</strong></p>
<ul>
<li>Tìm GameObject đại diện cho chiếc xe đua Kart trong Hierarchy (ví dụ: “PlayerKart”).</li>
<li>Đảm bảo xe Kart đã có component Rigidbody và các Collider cần thiết.</li>
<li>Tạo một C# Script mới trong thư mục “Scripts”, đặt tên là “KartController”.</li>
<li>Gắn script “KartController” vào GameObject xe Kart.</li>
<li><em>Kiểm tra lại:</em> Chọn xe Kart, xem trong Inspector đã có Rigidbody và script “KartController” chưa.</li>
</ul>
</li>
<li>
<p><strong>Bước 2: Viết Code Điều khiển cơ bản:</strong></p>
<ul>
<li>Mở script “KartController” và thay thế nội dung bằng code sau:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KartController</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> forwardSpeed <span class="token operator">=</span> <span class="token number">15f</span><span class="token punctuation">;</span> <span class="token comment">// Lực đẩy tới</span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> reverseSpeed <span class="token operator">=</span> <span class="token number">8f</span><span class="token punctuation">;</span>  <span class="token comment">// Lực đẩy lùi</span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> turnStrength <span class="token operator">=</span> <span class="token number">10f</span><span class="token punctuation">;</span> <span class="token comment">// Độ mạnh khi rẽ (mô-men xoắn)</span>

    <span class="token keyword">public</span> <span class="token keyword">float</span> dragOnGround <span class="token operator">=</span> <span class="token number">3f</span><span class="token punctuation">;</span>      <span class="token comment">// Lực cản khi xe trên mặt đất</span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> angularDragOnGround <span class="token operator">=</span> <span class="token number">2f</span><span class="token punctuation">;</span> <span class="token comment">// Lực cản xoay khi xe trên mặt đất</span>

    <span class="token keyword">private</span> Rigidbody rb<span class="token punctuation">;</span> <span class="token comment">// Tham chiếu tới Rigidbody của xe</span>
    <span class="token keyword">private</span> <span class="token keyword">float</span> horizontalInput<span class="token punctuation">;</span> <span class="token comment">// Lưu trữ giá trị input ngang (trái/phải)</span>
    <span class="token keyword">private</span> <span class="token keyword">float</span> verticalInput<span class="token punctuation">;</span>   <span class="token comment">// Lưu trữ giá trị input dọc (tiến/lùi)</span>

    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        rb <span class="token operator">=</span> <span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>Rigidbody<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Thiết lập lực cản ban đầu cho Rigidbody</span>
        rb<span class="token punctuation">.</span>drag <span class="token operator">=</span> dragOnGround<span class="token punctuation">;</span>
        rb<span class="token punctuation">.</span>angularDrag <span class="token operator">=</span> angularDragOnGround<span class="token punctuation">;</span>

        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"KartController script started!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// *** Đọc Input trong Update() vì nó nhạy hơn với các sự kiện nhấn phím ***</span>
        horizontalInput <span class="token operator">=</span> Input<span class="token punctuation">.</span><span class="token function">GetAxis</span><span class="token punctuation">(</span><span class="token string">"Horizontal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Trả về giá trị từ -1 (trái) đến 1 (phải)</span>
        verticalInput <span class="token operator">=</span> Input<span class="token punctuation">.</span><span class="token function">GetAxis</span><span class="token punctuation">(</span><span class="token string">"Vertical"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Trả về giá trị từ -1 (lùi) đến 1 (tiến)</span>

        <span class="token comment">// In giá trị input ra Console để kiểm tra (có thể xóa sau khi test)</span>
        <span class="token comment">// Debug.Log("Horizontal: " + horizontalInput + ", Vertical: " + verticalInput);</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">FixedUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// *** Áp dụng lực và mô-men xoắn trong FixedUpdate() cho ổn định vật lý ***</span>

        <span class="token comment">// 1. Xử lý lực đẩy Tiến/Lùi</span>
        <span class="token comment">// Sử dụng transform.forward để lấy hướng phía trước của xe</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>verticalInput <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// Nếu nhấn Tiến</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// Thêm lực về phía trước của xe</span>
            rb<span class="token punctuation">.</span><span class="token function">AddForce</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>forward <span class="token operator">*</span> forwardSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>verticalInput <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// Nếu nhấn Lùi</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// Thêm lực về phía sau của xe (ngược hướng transform.forward)</span>
             rb<span class="token punctuation">.</span><span class="token function">AddForce</span><span class="token punctuation">(</span><span class="token operator">-</span>transform<span class="token punctuation">.</span>forward <span class="token operator">*</span> reverseSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// Hoặc có thể dùng: rb.AddForce(transform.forward * -reverseSpeed);</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 2. Xử lý Rẽ Trái/Phải</span>
        <span class="token comment">// Sử dụng transform.up để lấy trục thẳng đứng của xe làm trục xoay</span>
        <span class="token comment">// Lực xoay (Torque) sẽ làm xe quay quanh trục này</span>
        <span class="token keyword">float</span> turn <span class="token operator">=</span> horizontalInput <span class="token operator">*</span> turnStrength<span class="token punctuation">;</span> <span class="token comment">// Tính toán độ mạnh xoay</span>
        rb<span class="token punctuation">.</span><span class="token function">AddTorque</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>up <span class="token operator">*</span> turn<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// (Nâng cao - Tùy chọn) Có thể thêm các điều kiện để giới hạn tốc độ tối đa</span>
        <span class="token comment">// hoặc chỉ cho phép rẽ khi xe đang di chuyển...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// (Tùy chọn) Thêm hàm để kiểm tra xe có chạm đất không để điều chỉnh lực cản sau này</span>
    <span class="token comment">// bool IsGrounded() { ... }</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích nhanh:</strong>
<ul>
<li>Các biến <code>public</code>: Để dễ dàng tinh chỉnh tốc độ, lực rẽ trong Inspector.</li>
<li>Các biến <code>private</code>: Lưu trữ Rigidbody và giá trị Input.</li>
<li><code>Start()</code>: Lấy Rigidbody và thiết lập lực cản ban đầu (<code>drag</code>, <code>angularDrag</code>).</li>
<li><code>Update()</code>: Nơi tốt nhất để đọc Input bằng <code>Input.GetAxis()</code>.</li>
<li><code>FixedUpdate()</code>: Nơi áp dụng lực (<code>AddForce</code>) và mô-men xoắn (<code>AddTorque</code>) dựa trên giá trị Input đã đọc.</li>
<li><code>transform.forward</code>: Hướng phía trước của đối tượng (xe). Lực đẩy theo hướng này.</li>
<li><code>transform.up</code>: Trục thẳng đứng của đối tượng (xe). Mô-men xoắn quanh trục này để rẽ.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 3: Lưu Script và Quay lại Unity:</strong></p>
<ul>
<li>Lưu script (Ctrl + S / Cmd + S).</li>
<li>Quay lại Unity Editor.</li>
</ul>
</li>
<li>
<p><strong>Bước 4: Thiết lập Input Manager (Kiểm tra):</strong></p>
<ul>
<li>Thông thường, “Horizontal” và “Vertical” đã được thiết lập mặc định cho phím mũi tên và WASD.</li>
<li>Để kiểm tra (hoặc thay đổi): Vào <code>Edit</code> -&gt; <code>Project Settings</code> -&gt; <code>Input Manager</code>. Mở rộng mục “Axes”. Tìm “Horizontal” và “Vertical” để xem các phím được gán (<code>Positive Button</code>, <code>Negative Button</code>, <code>Alt...</code>).</li>
<li><em>Hình ảnh minh họa Input Manager.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 5: Playtest và Tinh chỉnh:</strong></p>
<ul>
<li>Nhấn Play.</li>
<li>Thử nhấn các phím mũi tên (lên, xuống, trái, phải) hoặc WASD. Xe có di chuyển và rẽ không?</li>
<li><strong>Quan trọng:</strong> Chọn GameObject xe Kart <em>khi game đang chạy</em>. Trong Inspector, tìm component “Kart Controller”.</li>
<li><strong>Thử nghiệm thay đổi các giá trị:</strong>
<ul>
<li>Tăng/giảm <code>Forward Speed</code>: Ảnh hưởng đến tốc độ tiến.</li>
<li>Tăng/giảm <code>Reverse Speed</code>: Ảnh hưởng đến tốc độ lùi.</li>
<li>Tăng/giảm <code>Turn Strength</code>: Ảnh hưởng đến độ nhạy khi rẽ (rẽ gấp hay từ từ).</li>
</ul>
</li>
<li><strong>Thử nghiệm thay đổi thông số Rigidbody:</strong>
<ul>
<li>Tìm component Rigidbody trên xe Kart.</li>
<li>Tăng/giảm <code>Drag</code>: Lực cản thẳng. Drag cao làm xe dừng nhanh hơn khi thả ga. Drag thấp làm xe trượt đi xa hơn.</li>
<li>Tăng/giảm <code>Angular Drag</code>: Lực cản xoay. Angular Drag cao làm xe ngừng xoay nhanh hơn khi thả nút rẽ. Angular Drag thấp làm xe dễ bị trượt ngang (drift) hoặc xoay vòng.</li>
</ul>
</li>
<li><strong>Lặp lại:</strong> Chơi thử -&gt; Điều chỉnh thông số (trong Inspector) -&gt; Chơi thử lại. Tìm ra bộ thông số cho cảm giác lái mà bạn thích.</li>
<li><strong>Lưu ý:</strong> Các thay đổi trong Inspector khi game đang chạy sẽ bị mất khi bạn dừng game. Hãy ghi nhớ giá trị bạn thích và nhập lại khi đã dừng game.</li>
</ul>
</li>
<li>
<p><strong>Troubleshooting:</strong></p>
<ul>
<li>Xe không di chuyển/rẽ: Kiểm tra Console có lỗi không? Script đã gắn chưa? Rigidbody đã có chưa? Input Manager có thiết lập đúng không? Code <code>AddForce</code>/<code>AddTorque</code> có đúng không?</li>
<li>Xe di chuyển/rẽ quá nhanh/chậm: Điều chỉnh các biến tốc độ/lực rẽ trong Inspector.</li>
<li>Xe quá trơn trượt/khó dừng: Tăng <code>Drag</code> và <code>Angular Drag</code> trên Rigidbody.</li>
<li>Xe quá ì/khó rẽ: Giảm <code>Drag</code>/<code>Angular Drag</code>, tăng <code>Forward Speed</code>/<code>Turn Strength</code>.</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chiếu lại cảnh lái xe trong Karting Microgame (hoặc game mẫu). Hỏi: “Làm sao game biết được khi nào chúng ta nhấn nút tiến hay nút rẽ?”</li>
<li>GV dẫn dắt: “Ở buổi trước, chúng ta đã dùng script để làm khối hộp tự di chuyển. Hôm nay, chúng ta sẽ nâng cấp: dùng script để ‘lắng nghe’ tín hiệu từ bàn phím của người chơi và biến tín hiệu đó thành lực đẩy và lực xoay cho chiếc xe đua!”</li>
<li>GV nhấn mạnh: “Mục tiêu không chỉ là làm xe chạy được, mà còn là làm sao để cảm giác lái ‘đã tay’ - không quá nhạy cũng không quá ì. Đây là lúc việc tinh chỉnh thông số trở nên quan trọng.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo sự kết nối với việc điều khiển game, giới thiệu khái niệm đọc input từ người chơi và mục tiêu tinh chỉnh “game feel”.</li>
</ul>
<p><strong>2. Explore (Khám phá - 40 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Lập trình Điều khiển Xe đua cơ bản với Input và Vật lý”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li>Chuẩn bị xe Kart và tạo/gắn script <code>KartController</code>.</li>
<li>Viết hoặc copy/paste code điều khiển cơ bản vào script.</li>
<li>Lưu script, quay lại Unity.</li>
<li>(Tùy chọn) Kiểm tra nhanh Input Manager.</li>
<li>Nhấn Play và thử điều khiển xe bằng bàn phím.</li>
<li><strong>Thực hành Tinh chỉnh:</strong> Dành phần lớn thời gian ở bước này để HS tự do thay đổi các giá trị <code>public</code> trong script (Forward Speed, Turn Strength…) và các giá trị <code>Drag</code>, <code>Angular Drag</code> trên Rigidbody <em>khi game đang chạy</em> để cảm nhận sự khác biệt.</li>
<li>Khuyến khích HS thử nhiều bộ thông số khác nhau.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp sửa lỗi nếu xe không điều khiển được.</li>
<li>Giải thích lại ý nghĩa của từng thông số khi HS hỏi (“Em tăng cái này thì xe bị sao ạ?”).</li>
<li>Khuyến khích HS ghi lại các giá trị mà họ cảm thấy “lái tốt”.</li>
<li>Nhắc nhở HS lưu lại giá trị ưng ý sau khi dừng Play mode.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành viết code đọc input và áp dụng lực/mô-men xoắn, trải nghiệm trực tiếp quá trình tinh chỉnh thông số vật lý và script để thay đổi cảm giác lái.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, mở script <code>KartController</code> trên máy chiếu và giải thích kỹ hơn về các khái niệm mới:
<ul>
<li><strong><code>Input.GetAxis("Horizontal")</code> / <code>"Vertical"</code></strong>: Cách Unity quản lý Input qua các “trục” ảo. Trả về giá trị float từ -1 đến 1, mượt mà (có gia tốc/giảm tốc nhẹ), phù hợp cho điều khiển analog (lái xe, joystick). So sánh nhanh với <code>Input.GetKeyDown()</code> (chỉ nhận biết nhấn/không nhấn).</li>
<li><strong>Tại sao đọc Input trong <code>Update()</code> nhưng áp dụng lực trong <code>FixedUpdate()</code>?</strong>: <code>Update</code> chạy mỗi khung hình, nhạy với input. <code>FixedUpdate</code> chạy theo chu kỳ vật lý, ổn định cho tính toán lực. Tách riêng để đảm bảo không bỏ lỡ input và vật lý ổn định.</li>
<li><strong><code>transform.forward</code> và <code>transform.up</code></strong>: Hệ tọa độ cục bộ của GameObject. Tại sao dùng <code>transform.forward</code> để đẩy tới và <code>transform.up</code> làm trục xoay để rẽ? Giải thích trực quan trên hình ảnh xe.</li>
<li><strong><code>AddForce()</code> vs <code>AddTorque()</code></strong>: Một cái tạo chuyển động thẳng, một cái tạo chuyển động xoay.</li>
<li><strong>Vai trò của <code>Drag</code> và <code>Angular Drag</code></strong>: Giải thích lại cách chúng mô phỏng lực cản của không khí/ma sát, giúp kiểm soát tốc độ và độ ổn định khi xoay của xe. Nhấn mạnh tầm quan trọng của chúng đối với “game feel”.</li>
<li><strong>Quy trình tinh chỉnh</strong>: Nhấn mạnh việc thay đổi giá trị trong Inspector khi Play mode là cách nhanh nhất để thử nghiệm, nhưng phải nhớ lưu lại giá trị đó sau khi dừng game.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giải thích sâu về cách đọc Input trong Unity, lý do tách biệt <code>Update</code> và <code>FixedUpdate</code>, cách sử dụng hệ tọa độ cục bộ (<code>transform.forward/up</code>), và vai trò quan trọng của các thông số vật lý (Drag) trong việc định hình cảm giác lái.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thảo luận &amp; Thử nghiệm thêm):</strong>
<ul>
<li>GV đặt câu hỏi thảo luận: “Nếu chúng ta muốn xe drift (trượt bánh) nhiều hơn thì nên điều chỉnh thông số nào?” (Gợi ý: Giảm <code>Angular Drag</code>, có thể tăng <code>Turn Strength</code>).</li>
<li>“Nếu muốn xe phanh gấp hơn khi thả nút tiến thì sao?” (Gợi ý: Tăng <code>Drag</code>).</li>
<li>“Làm sao để giới hạn tốc độ tối đa của xe?” (Gợi ý nâng cao: Trong <code>FixedUpdate</code>, kiểm tra <code>rb.velocity.magnitude</code>, nếu lớn hơn tốc độ tối đa thì không <code>AddForce</code> nữa hoặc áp dụng lực cản ngược lại). -&gt; GV có thể code thử một ví dụ đơn giản về giới hạn tốc độ nếu có thời gian và lớp theo kịp.</li>
<li>HS dành thời gian còn lại để tiếp tục tinh chỉnh cảm giác lái theo ý muốn của mình, hoặc thử áp dụng một trong các ý tưởng thảo luận trên.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS suy luận về mối quan hệ giữa thông số và hành vi, áp dụng kiến thức để đạt được một hiệu ứng lái xe cụ thể, giới thiệu sơ bộ về các kỹ thuật điều khiển nâng cao hơn.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Lái thử và Chia sẻ:</strong> GV mời 2-3 HS lái thử xe của mình trên màn hình lớn và mô tả ngắn gọn cảm giác lái họ đã tạo ra (ví dụ: “Xe em hơi trượt khi rẽ”, “Xe em bám đường tốt và phanh nhanh”). Hỏi HS họ đã điều chỉnh thông số nào nhiều nhất để đạt được cảm giác đó.</li>
<li><strong>Câu hỏi nhanh:</strong>
<ol>
<li>Hàm nào dùng để đọc giá trị từ trục Input “Horizontal”? (<code>Input.GetAxis("Horizontal")</code>)</li>
<li>Nên đọc Input ở <code>Update</code> hay <code>FixedUpdate</code>? (<code>Update</code>)</li>
<li>Nên áp dụng lực (<code>AddForce</code>) ở <code>Update</code> hay <code>FixedUpdate</code>? (<code>FixedUpdate</code>)</li>
<li>Thông số nào trên Rigidbody giúp xe dừng nhanh hơn khi thả ga? (<code>Drag</code>)</li>
<li>Thông số nào trong script chúng ta viết giúp xe rẽ mạnh hơn/nhạy hơn? (<code>turnStrength</code>)</li>
</ol>
</li>
<li><strong>Quan sát:</strong> Khả năng điều khiển xe của HS, khả năng giải thích các điều chỉnh thông số của họ, câu trả lời cho các câu hỏi.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng lập trình điều khiển cơ bản, hiểu biết về Input và các thông số vật lý liên quan, và kỹ năng tinh chỉnh “game feel”.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV khen ngợi nỗ lực của HS trong việc làm cho chiếc xe chuyển động theo ý muốn.</li>
<li>Nhấn mạnh rằng việc điều khiển nhân vật/xe là một trong những phần cốt lõi và thú vị nhất của làm game.</li>
<li>Giới thiệu buổi học tiếp theo: “Chúng ta đã có xe chạy được. Buổi sau, chúng ta sẽ tìm hiểu về Class và Object trong C# để tổ chức code tốt hơn, chuẩn bị cho việc thêm các tính năng phức tạp hơn như chướng ngại vật có hành vi riêng hay hệ thống điểm.”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.5-giới-thiệu-class-và-object-trong-game-3d">Giáo án Buổi học 2.1.5: Giới thiệu Class và Object trong Game 3D</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành buổi 2.1.4.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS phân biệt và giải thích được khái niệm Class (khuôn mẫu) và Object (thể hiện cụ thể) trong ngữ cảnh lập trình và Unity.</li>
<li>HS xác định được các Component trong Unity là các Object được tạo ra từ các Class tương ứng.</li>
<li>HS định nghĩa được các biến thành viên (fields/attributes) cơ bản trong một class C# để lưu trữ trạng thái của đối tượng (ví dụ: <code>speed</code>, <code>health</code>, <code>obstacleType</code>).</li>
<li>HS bắt đầu cấu trúc lại các script hiện có (ví dụ: <code>KartController</code>) bằng cách xác định rõ các thuộc tính quan trọng của đối tượng mà script đại diện.</li>
<li>HS tạo được một class C# mới đơn giản để đại diện cho một loại đối tượng khác trong game (ví dụ: <code>Obstacle</code>).</li>
<li>HS hiểu được lợi ích ban đầu của việc sử dụng Class để đóng gói dữ liệu liên quan đến một đối tượng.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Adventure từ buổi trước cho mỗi HS.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Tìm hiểu Class và Object trong Unity với C#” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>Bảng trắng hoặc công cụ vẽ sơ đồ để minh họa khái niệm Class/Object.</li>
<li>(Tùy chọn) Các vật thể thực tế để minh họa (ví dụ: khuôn bánh và bánh, bản thiết kế nhà và ngôi nhà).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Tìm hiểu Class và Object trong Unity với C#"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li>
<p><strong>Giới thiệu:</strong> Mục tiêu là giúp bạn hiểu khái niệm nền tảng về Class và Object trong lập trình hướng đối tượng (OOP) và cách nó áp dụng trong Unity để tổ chức code game hiệu quả hơn.</p>
</li>
<li>
<p><strong>Khái niệm Cốt lõi:</strong></p>
<ul>
<li><strong>Class (Lớp):</strong> Giống như một bản thiết kế, một khuôn mẫu, một định nghĩa chung. Nó mô tả các <em>thuộc tính</em> (dữ liệu, biến thành viên, fields) và <em>hành vi</em> (chức năng, phương thức, methods) mà một loại đối tượng sẽ có. Ví dụ: Class <code>Dog</code> định nghĩa rằng tất cả các con chó đều có thuộc tính <code>breed</code> (giống), <code>color</code> (màu lông) và hành vi <code>Bark()</code> (sủa).</li>
<li><strong>Object (Đối tượng):</strong> Là một <em>thể hiện cụ thể</em> được tạo ra từ một Class. Nó có các thuộc tính được định nghĩa trong Class, nhưng với các giá trị cụ thể. Ví dụ: “Milo” là một Object của Class <code>Dog</code>, có <code>breed</code> = “Poodle”, <code>color</code> = “White”. “Buddy” là một Object khác của Class <code>Dog</code>, có <code>breed</code> = “Golden Retriever”, <code>color</code> = “Gold”. Cả Milo và Buddy đều có thể thực hiện hành vi <code>Bark()</code>.</li>
<li><em>Hình ảnh minh họa: Khuôn bánh (Class) và nhiều cái bánh (Objects).</em></li>
</ul>
</li>
<li>
<p><strong>Class và Object trong Unity:</strong></p>
<ul>
<li>Mọi Component bạn thấy trong Inspector (ví dụ: <code>Transform</code>, <code>Rigidbody</code>, <code>BoxCollider</code>, <code>KartController</code> của bạn) thực chất là một <strong>Object</strong> được tạo ra từ một <strong>Class</strong> tương ứng (<code>Transform</code> class, <code>Rigidbody</code> class…).</li>
<li>Khi bạn tạo một C# Script (ví dụ: <code>KartController</code>), bạn đang định nghĩa một <strong>Class</strong> mới.</li>
<li>Khi bạn kéo script đó vào một GameObject trong Hierarchy/Inspector, Unity sẽ tạo ra một <strong>Object</strong> (một thể hiện) của Class đó và gắn nó vào GameObject. Bạn có thể gắn cùng một script (Class) vào nhiều GameObject khác nhau, tạo ra nhiều Object độc lập với các giá trị thuộc tính (biến public) khác nhau.</li>
</ul>
</li>
<li>
<p><strong>Bước 1: Xem lại <code>KartController</code> dưới góc độ Class:</strong></p>
<ul>
<li>Mở script <code>KartController</code> bạn đã viết ở bài trước.</li>
<li>Xác định các biến bạn đã khai báo ở đầu class (ví dụ: <code>forwardSpeed</code>, <code>turnStrength</code>, <code>rb</code>…). Đây chính là các <strong>thuộc tính (fields)</strong> của class <code>KartController</code>, định nghĩa trạng thái và khả năng của chiếc xe.</li>
<li>Các hàm như <code>Start()</code>, <code>Update()</code>, <code>FixedUpdate()</code> định nghĩa <strong>hành vi (methods)</strong> của chiếc xe.</li>
</ul>
</li>
<li>
<p><strong>Bước 2: Định nghĩa Class <code>Obstacle</code> đơn giản:</strong></p>
<ul>
<li>Trong thư mục “Scripts”, tạo một C# Script mới tên là <code>Obstacle</code>.</li>
<li>Mở script <code>Obstacle</code> và viết đoạn code sau:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Obstacle</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token comment">// Thuộc tính (Fields) của một chướng ngại vật</span>
    <span class="token keyword">public</span> <span class="token keyword">string</span> obstacleType <span class="token operator">=</span> <span class="token string">"Static Rock"</span><span class="token punctuation">;</span> <span class="token comment">// Loại chướng ngại vật (ví dụ)</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> damageAmount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// Lượng sát thương gây ra (ví dụ)</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> canBeDestroyed <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>      <span class="token comment">// Có thể bị phá hủy không? (ví dụ)</span>

    <span class="token comment">// Chúng ta sẽ thêm hành vi (Methods) vào class này ở các bài sau</span>
    <span class="token comment">// Ví dụ: ApplyEffect(), TakeDamage()...</span>

    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Có thể thêm code khởi tạo nếu cần</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"An obstacle of type '"</span> <span class="token operator">+</span> obstacleType <span class="token operator">+</span> <span class="token string">"' has been created!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Có thể thêm các hàm sự kiện khác nếu cần (Update, OnCollisionEnter...)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong> Class <code>Obstacle</code> này định nghĩa các thuộc tính cơ bản mà một chướng ngại vật trong game của bạn có thể có. Các biến này là <code>public</code> để bạn có thể dễ dàng thiết lập giá trị cho từng chướng ngại vật cụ thể trong Inspector.</li>
</ul>
</li>
<li>
<p><strong>Bước 3: Tạo các Object Chướng ngại vật:</strong></p>
<ul>
<li>Quay lại Unity Editor.</li>
<li>Tìm lại các GameObject bạn đã tạo làm chướng ngại vật ở bài 2 (ví dụ: các khối Cube). Hoặc tạo một vài Cube mới.</li>
<li>Chọn một Cube chướng ngại vật.</li>
<li><strong>Gắn script <code>Obstacle</code></strong> vào Cube này bằng cách kéo thả hoặc dùng “Add Component”.</li>
<li>Trong Inspector, bạn sẽ thấy component “Obstacle (Script)” xuất hiện cùng các thuộc tính <code>Obstacle Type</code>, <code>Damage Amount</code>, <code>Can Be Destroyed</code> với giá trị mặc định.</li>
<li><strong>Quan trọng:</strong> Hãy thay đổi các giá trị này cho từng Cube chướng ngại vật khác nhau. Ví dụ:
<ul>
<li>Cube 1: <code>Obstacle Type</code> = “Bouncy Wall”, <code>Damage Amount</code> = 0, <code>Can Be Destroyed</code> = false.</li>
<li>Cube 2: <code>Obstacle Type</code> = “Exploding Barrel”, <code>Damage Amount</code> = 5, <code>Can Be Destroyed</code> = true.</li>
</ul>
</li>
<li>Bạn vừa tạo ra các <strong>Objects</strong> khác nhau từ cùng một <strong>Class</strong> <code>Obstacle</code>. Mỗi Object có các giá trị thuộc tính riêng.</li>
</ul>
</li>
<li>
<p><strong>Bước 4: Playtest và Quan sát:</strong></p>
<ul>
<li>Mở cửa sổ Console.</li>
<li>Nhấn Play.</li>
<li>Bạn có thấy các thông điệp “An obstacle of type…” được in ra cho mỗi chướng ngại vật có gắn script <code>Obstacle</code> không?</li>
</ul>
</li>
<li>
<p><strong>Lợi ích ban đầu:</strong></p>
<ul>
<li><strong>Tổ chức:</strong> Gom nhóm các dữ liệu liên quan đến một loại đối tượng vào cùng một nơi (Class).</li>
<li><strong>Tái sử dụng:</strong> Dùng cùng một Class <code>Obstacle</code> để tạo ra nhiều loại chướng ngại vật khác nhau chỉ bằng cách thay đổi giá trị thuộc tính trong Inspector.</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV sử dụng phép ẩn dụ:
<ul>
<li>Giơ ra một cái khuôn bánh (hoặc ảnh) và nhiều cái bánh làm từ khuôn đó. Hỏi: “Cái gì là bản thiết kế chung? Cái gì là sản phẩm cụ thể?” -&gt; Giới thiệu Class (khuôn) và Object (bánh).</li>
<li>Hoặc dùng bản thiết kế nhà (Class) và nhiều ngôi nhà được xây theo bản thiết kế đó (Objects), mỗi nhà có thể có màu sơn, nội thất (giá trị thuộc tính) khác nhau.</li>
</ul>
</li>
<li>Liên hệ với Unity: “Trong Unity, các bạn đã dùng rất nhiều ‘khuôn mẫu’ có sẵn như <code>Rigidbody</code>, <code>Transform</code>. Khi các bạn kéo chúng vào Inspector, các bạn đang tạo ra một ‘sản phẩm cụ thể’ - một component Rigidbody riêng cho đối tượng đó.”</li>
<li>Đặt vấn đề: “Script <code>KartController</code> của chúng ta đang chứa các thông tin về tốc độ, lực rẽ… Đó là các <em>thuộc tính</em> của xe. Nếu chúng ta có nhiều loại xe khác nhau, hoặc nhiều loại chướng ngại vật khác nhau, làm sao để quản lý các thuộc tính và hành vi của chúng một cách gọn gàng?” -&gt; Giới thiệu sự cần thiết của việc tự định nghĩa Class.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giúp HS hình dung khái niệm trừu tượng Class/Object thông qua các ví dụ quen thuộc, kết nối với các component Unity đã biết, nêu bật vấn đề cần giải quyết (tổ chức code).</li>
</ul>
<p><strong>2. Explore (Khám phá - 35 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Tìm hiểu Class và Object trong Unity với C#”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li>Xem lại script <code>KartController</code>, xác định các biến thành viên (fields) là thuộc tính của xe.</li>
<li>Tạo C# Script mới <code>Obstacle</code>.</li>
<li>Viết (hoặc copy/paste) code định nghĩa Class <code>Obstacle</code> với các thuộc tính mẫu (<code>obstacleType</code>, <code>damageAmount</code>…).</li>
<li>Tìm các GameObject chướng ngại vật đã tạo hoặc tạo mới.</li>
<li>Gắn script <code>Obstacle</code> vào các GameObject này.</li>
<li><strong>Thực hành quan trọng:</strong> Thay đổi các giá trị thuộc tính (<code>Obstacle Type</code>, <code>Damage Amount</code>…) trong Inspector cho <em>từng</em> GameObject chướng ngại vật khác nhau, tạo ra các “Object” riêng biệt.</li>
<li>Mở Console và nhấn Play để xem log khởi tạo từ hàm <code>Start()</code> của các script <code>Obstacle</code>.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giải đáp thắc mắc khi HS đọc tài liệu hoặc viết code.</li>
<li>Đảm bảo HS phân biệt được việc <em>định nghĩa Class</em> trong script và việc <em>tạo Object</em> bằng cách gắn script và chỉnh sửa giá trị trong Inspector.</li>
<li>Khuyến khích HS tạo ra sự khác biệt rõ rệt giữa các Object chướng ngại vật qua việc đặt giá trị thuộc tính khác nhau.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành định nghĩa một Class mới, tạo các Object từ Class đó trong Unity, và gán các giá trị thuộc tính khác nhau cho từng Object thông qua Inspector.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV sử dụng bảng trắng hoặc công cụ vẽ sơ đồ để hệ thống hóa lại:
<ul>
<li>Vẽ một hình chữ nhật đại diện cho <strong>Class <code>Obstacle</code></strong>, liệt kê các <strong>thuộc tính</strong> bên trong (<code>obstacleType: string</code>, <code>damageAmount: int</code>, <code>canBeDestroyed: bool</code>).</li>
<li>Vẽ nhiều hình tròn/vuông nhỏ hơn đại diện cho các <strong>Object</strong> chướng ngại vật cụ thể trong Scene (ví dụ: <code>Rock1</code>, <code>Barrel2</code>). Ghi các <strong>giá trị thuộc tính</strong> cụ thể cho từng Object (ví dụ: <code>Rock1: { type: "Static Rock", damage: 1, destroyable: false }</code>, <code>Barrel2: { type: "Exploding Barrel", damage: 5, destroyable: true }</code>).</li>
</ul>
</li>
<li>GV nhấn mạnh lại:
<ul>
<li>Class là định nghĩa chung trong <strong>code (Script)</strong>.</li>
<li>Object là thể hiện cụ thể trong <strong>Scene (GameObject với component script)</strong>, với các giá trị riêng trong <strong>Inspector</strong>.</li>
<li>Lợi ích:
<ul>
<li><strong>Đóng gói (Encapsulation):</strong> Gom dữ liệu liên quan (các thuộc tính của chướng ngại vật) vào một nơi.</li>
<li><strong>Tổ chức:</strong> Code rõ ràng hơn, dễ hiểu hơn khi biết script này đại diện cho loại đối tượng nào.</li>
<li><strong>Tái sử dụng:</strong> Dùng một Class để tạo nhiều Object khác nhau.</li>
</ul>
</li>
<li>Liên hệ <code>KartController</code>: Nó cũng là một Class, và chiếc xe Kart trong Scene là một Object của Class đó. Các biến public <code>forwardSpeed</code>, <code>turnStrength</code> là thuộc tính bạn có thể chỉnh cho Object xe Kart cụ thể đó.</li>
<li>Giới thiệu sơ lược về bước tiếp theo: “Hiện tại Class <code>Obstacle</code> mới chỉ có thuộc tính. Ở bài sau, chúng ta sẽ thêm <em>hành vi</em> (Methods) cho nó, ví dụ như làm cho thùng nổ phát nổ khi va chạm!”</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Củng cố sự khác biệt giữa Class và Object bằng trực quan hóa, giải thích rõ ràng các lợi ích ban đầu của việc sử dụng Class, và liên hệ lại với script <code>KartController</code> đã quen thuộc.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thiết kế Class đơn giản khác):</strong>
<ul>
<li>GV yêu cầu HS suy nghĩ và phác thảo nhanh trên giấy (hoặc thảo luận cặp đôi) về một Class khác có thể cần trong game Karting. Ví dụ:
<ul>
<li>Class <code>PowerUp</code>: Cần những thuộc tính gì? (Loại power-up: tăng tốc, khiên…; Thời gian hiệu lực; Âm thanh khi nhận…).</li>
<li>Class <code>FinishLine</code>: Cần những thuộc tính gì? (Có thể không cần thuộc tính, chỉ cần hành vi kiểm tra xem xe về đích chưa).</li>
<li>Class <code>Checkpoint</code>: Cần những thuộc tính gì? (Số thứ tự checkpoint).</li>
</ul>
</li>
<li>HS chỉ cần liệt kê ra các <strong>thuộc tính</strong> (dữ liệu) mà họ nghĩ Class đó cần có. Không cần viết code hoàn chỉnh.</li>
<li>GV mời một vài HS/cặp đôi chia sẻ ý tưởng thiết kế Class của họ.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS áp dụng tư duy Class/Object vào việc phân tích các yếu tố khác trong game, thực hành xác định các thuộc tính cần thiết cho một loại đối tượng.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh:</strong>
<ol>
<li>Giải thích ngắn gọn sự khác nhau giữa Class và Object? (Class là bản thiết kế/khuôn mẫu, Object là thể hiện cụ thể).</li>
<li>Trong Unity, khi bạn kéo một C# script vào GameObject, bạn đang tạo ra cái gì từ script đó? (Một Object / thể hiện / component).</li>
<li>Trong Class <code>Obstacle</code> chúng ta vừa tạo, <code>obstacleType</code> và <code>damageAmount</code> được gọi là gì? (Thuộc tính / Biến thành viên / Fields).</li>
<li>Lợi ích của việc dùng Class để định nghĩa <code>Obstacle</code> thay vì code trực tiếp vào từng Cube là gì? (Tổ chức code, tái sử dụng, dễ quản lý).</li>
</ol>
</li>
<li><strong>Quan sát:</strong> GV xem qua các GameObject chướng ngại vật của HS, đảm bảo chúng có script <code>Obstacle</code> với các giá trị thuộc tính khác nhau đã được thiết lập trong Inspector. Đánh giá các ý tưởng thiết kế Class trong phần Elaborate.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá mức độ hiểu các khái niệm cốt lõi về Class/Object, khả năng xác định thuộc tính, và nhận biết lợi ích của OOP ở mức cơ bản.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt: Hôm nay chúng ta đã tìm hiểu một khái niệm rất quan trọng trong lập trình là Class và Object, và cách áp dụng nó để định nghĩa các loại đối tượng trong game như Xe và Chướng ngại vật.</li>
<li>Nhấn mạnh rằng việc này giúp tổ chức code tốt hơn.</li>
<li>Giới thiệu buổi học tiếp theo: “Chúng ta sẽ tiếp tục xây dựng trên nền tảng Class/Object này, thêm các hành vi (methods) vào Class để làm cho các đối tượng thực sự tương tác với nhau một cách có ý nghĩa.”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.6-tổ-chức-mã-nguồn-với-class--object-thêm-hành-vi">Giáo án Buổi học 2.1.6: Tổ chức Mã Nguồn với Class &amp; Object (Thêm Hành vi)</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành buổi 2.1.5.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS định nghĩa và viết được các phương thức (methods) đơn giản bên trong một Class C# để đóng gói hành vi của đối tượng.</li>
<li>HS sử dụng được các access modifiers cơ bản (<code>public</code>, <code>private</code>) để kiểm soát truy cập vào các biến thành viên và phương thức.</li>
<li>HS thực hiện được việc gọi phương thức của một object từ một script khác (ví dụ: <code>KartController</code> gọi phương thức của <code>Obstacle</code> khi va chạm).</li>
<li>HS tạo và sử dụng được một Class <code>GameManager</code> đơn giản để quản lý trạng thái chung của game (ví dụ: điểm số).</li>
<li>HS tái cấu trúc (refactor) được code hiện có (ví dụ: xử lý va chạm trong <code>KartController</code>) để sử dụng các phương thức mới tạo, giúp code gọn gàng và dễ hiểu hơn.</li>
<li>HS nhận thức rõ hơn lợi ích của Lập trình Hướng đối tượng (OOP) trong việc tổ chức và quản lý code phức tạp.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Adventure từ buổi trước cho mỗi HS.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Thêm Hành vi (Methods) vào Class và Tương tác giữa các Object” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>Bảng trắng hoặc công cụ vẽ sơ đồ để minh họa luồng gọi phương thức.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Thêm Hành vi (Methods) vào Class và Tương tác giữa các Object"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li>
<p><strong>Giới thiệu:</strong> Ở bài trước, chúng ta đã định nghĩa Class với các <em>thuộc tính</em>. Hôm nay, chúng ta sẽ thêm <em>hành vi</em> (Methods) vào Class để làm cho các Object thực sự hoạt động và tương tác với nhau. Chúng ta cũng sẽ tạo một <code>GameManager</code> để quản lý điểm số.</p>
</li>
<li>
<p><strong>Phương thức (Methods) là gì?</strong></p>
<ul>
<li>Là các khối lệnh (hàm) được định nghĩa bên trong một Class.</li>
<li>Chúng định nghĩa những gì một Object của Class đó <em>có thể làm</em>.</li>
<li>Ví dụ: Class <code>Dog</code> có thể có method <code>Bark()</code>, <code>WagTail()</code>. Class <code>KartController</code> có thể có method <code>Accelerate()</code>, <code>Turn()</code>.</li>
</ul>
</li>
<li>
<p><strong>Bước 1: Thêm Hành vi vào Class <code>Obstacle</code>:</strong></p>
<ul>
<li>Mở script <code>Obstacle</code>.</li>
<li>Thêm một phương thức <code>public</code> đơn giản vào bên trong class:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Obstacle</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token comment">// --- Các thuộc tính từ bài trước ---</span>
    <span class="token keyword">public</span> <span class="token keyword">string</span> obstacleType <span class="token operator">=</span> <span class="token string">"Static Rock"</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> damageAmount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> canBeDestroyed <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"An obstacle of type '"</span> <span class="token operator">+</span> obstacleType <span class="token operator">+</span> <span class="token string">"' has been created!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// --- Hành vi (Method) mới ---</span>
    <span class="token comment">// Phương thức này sẽ được gọi khi có vật gì đó va chạm vào chướng ngại vật</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">HitObstacle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" (type: "</span> <span class="token operator">+</span> obstacleType <span class="token operator">+</span> <span class="token string">") was hit!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Sau này có thể thêm logic phức tạp hơn ở đây</span>
        <span class="token comment">// Ví dụ: Nếu canBeDestroyed == true thì gọi hàm Destroy(gameObject);</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>canBeDestroyed<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" is destroyed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">Destroy</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Phá hủy đối tượng sau 0.1 giây</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong>
<ul>
<li><code>public void HitObstacle()</code>: Định nghĩa một phương thức tên <code>HitObstacle</code>. <code>public</code> nghĩa là các script khác có thể gọi nó. <code>void</code> nghĩa là nó không trả về giá trị nào.</li>
<li>Bên trong phương thức là các lệnh sẽ thực thi khi nó được gọi (in log, kiểm tra <code>canBeDestroyed</code> và tự hủy nếu có thể).</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 2: Gọi Phương thức <code>HitObstacle</code> từ <code>KartController</code>:</strong></p>
<ul>
<li>Mở script <code>KartController</code>.</li>
<li>Tìm hàm <code>OnCollisionEnter()</code> (nếu chưa có thì thêm vào). Hàm này được Unity gọi khi xe va chạm.</li>
<li>Sửa đổi hàm <code>OnCollisionEnter()</code> như sau:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"> <span class="token keyword">void</span> <span class="token function">OnCollisionEnter</span><span class="token punctuation">(</span>Collision collisionInfo<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Kart collided with: "</span> <span class="token operator">+</span> collisionInfo<span class="token punctuation">.</span>gameObject<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Log gốc để biết va chạm</span>

     <span class="token comment">// --- Code mới để tương tác với Obstacle ---</span>
     <span class="token comment">// 1. Kiểm tra xem đối tượng va chạm có component Obstacle không</span>
     Obstacle hitObstacle <span class="token operator">=</span> collisionInfo<span class="token punctuation">.</span>gameObject<span class="token punctuation">.</span><span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>Obstacle<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">// 2. Nếu có (hitObstacle không phải là null)</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>hitObstacle <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token comment">// 3. Gọi phương thức HitObstacle() của đối tượng Obstacle đó</span>
         hitObstacle<span class="token punctuation">.</span><span class="token function">HitObstacle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment">// (Tùy chọn) Có thể lấy thông tin từ obstacle, ví dụ: gây sát thương cho xe</span>
         <span class="token comment">// ApplyDamage(hitObstacle.damageAmount); // Giả sử có hàm ApplyDamage trên Kart</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// --- Hết code mới ---</span>
 <span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong>
<ul>
<li><code>collisionInfo.gameObject.GetComponent&lt;Obstacle&gt;()</code>: Lấy component <code>Obstacle</code> từ đối tượng <em>mà xe vừa va chạm</em>.</li>
<li><code>if (hitObstacle != null)</code>: Kiểm tra xem đối tượng va chạm có phải là một <code>Obstacle</code> không (có script <code>Obstacle</code> không).</li>
<li><code>hitObstacle.HitObstacle();</code>: <strong>Đây là phần quan trọng!</strong> Chúng ta đang gọi phương thức <code>HitObstacle()</code> <em>của chính cái object chướng ngại vật</em> mà xe vừa đâm vào.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 3: Playtest Tương tác:</strong></p>
<ul>
<li>Lưu cả hai script (<code>Obstacle</code> và <code>KartController</code>).</li>
<li>Quay lại Unity Editor. Mở Console.</li>
<li>Đảm bảo bạn có ít nhất một chướng ngại vật được đặt <code>Can Be Destroyed</code> thành <code>true</code> trong Inspector.</li>
<li>Nhấn Play. Lái xe đâm vào các chướng ngại vật.</li>
<li>Quan sát Console: Bạn có thấy log “Kart collided with…” không? Bạn có thấy log “… was hit!” từ script <code>Obstacle</code> không?</li>
<li>Chướng ngại vật nào có <code>Can Be Destroyed = true</code> có bị biến mất sau khi va chạm không?</li>
</ul>
</li>
<li>
<p><strong>Bước 4: Tạo <code>GameManager</code> để quản lý điểm:</strong></p>
<ul>
<li>Tạo một GameObject trống trong Hierarchy: <code>GameObject</code> -&gt; <code>Create Empty</code>. Đặt tên là “GameManager”.</li>
<li>Tạo một C# Script mới tên là <code>GameManager</code>.</li>
<li>Mở script <code>GameManager</code> và viết code sau:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>
<span class="token keyword">using</span> UnityEngine<span class="token punctuation">.</span>UI<span class="token punctuation">;</span> <span class="token comment">// Cần thêm dòng này để sử dụng UI Text</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameManager</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> GameManager instance<span class="token punctuation">;</span> <span class="token comment">// Biến static để dễ dàng truy cập từ script khác (Singleton Pattern đơn giản)</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Điểm số</span>
    <span class="token keyword">public</span> Text scoreText<span class="token punctuation">;</span> <span class="token comment">// Tham chiếu tới đối tượng UI Text để hiển thị điểm</span>

    <span class="token comment">// Awake chạy trước cả Start</span>
    <span class="token keyword">void</span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Thiết lập Singleton Pattern đơn giản</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            <span class="token comment">// DontDestroyOnLoad(gameObject); // Tùy chọn: giữ GameManager tồn tại qua các Scene</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            <span class="token function">Destroy</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Nếu đã có instance khác, hủy cái này đi</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">UpdateScoreUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cập nhật UI lúc bắt đầu</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Phương thức public để các script khác có thể gọi để tăng điểm</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">AddScore</span><span class="token punctuation">(</span><span class="token keyword">int</span> points<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        score <span class="token operator">+</span><span class="token operator">=</span> points<span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Score: "</span> <span class="token operator">+</span> score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Log để kiểm tra</span>
        <span class="token function">UpdateScoreUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cập nhật UI sau khi điểm thay đổi</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Phương thức private để cập nhật UI Text</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">UpdateScoreUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>scoreText <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            scoreText<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Score: "</span> <span class="token operator">+</span> score<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            Debug<span class="token punctuation">.</span><span class="token function">LogWarning</span><span class="token punctuation">(</span><span class="token string">"Score Text UI is not assigned in GameManager!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong>
<ul>
<li><code>public static GameManager instance;</code>: Biến <code>static</code> đặc biệt, chỉ có một bản sao duy nhất cho cả Class. Giúp truy cập <code>GameManager</code> dễ dàng từ bất kỳ đâu bằng <code>GameManager.instance</code>. (Đây là Singleton Pattern đơn giản).</li>
<li><code>Awake()</code>: Dùng để thiết lập <code>instance</code>.</li>
<li><code>public Text scoreText;</code>: Biến để kéo thả đối tượng UI Text vào trong Inspector.</li>
<li><code>AddScore(int points)</code>: Phương thức <code>public</code> để tăng điểm.</li>
<li><code>UpdateScoreUI()</code>: Phương thức <code>private</code> chỉ dùng nội bộ để cập nhật Text.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 5: Thiết lập UI và Gọi <code>AddScore</code>:</strong></p>
<ul>
<li>Trong Unity, tạo một UI Text: <code>GameObject</code> -&gt; <code>UI</code> -&gt; <code>Text</code> (Nếu dùng TextMeshPro thì chọn TextMeshPro).</li>
<li>Chọn GameObject “GameManager” trong Hierarchy.</li>
<li>Trong Inspector, tìm biến <code>Score Text</code> của component “GameManager (Script)”. Kéo thả đối tượng UI Text bạn vừa tạo vào ô này.</li>
<li>Mở lại script <code>Obstacle</code>. Sửa đổi phương thức <code>HitObstacle</code> để gọi <code>AddScore</code>:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">HitObstacle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" (type: "</span> <span class="token operator">+</span> obstacleType <span class="token operator">+</span> <span class="token string">") was hit!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">// --- Code mới để cộng điểm ---</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>GameManager<span class="token punctuation">.</span>instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// Luôn kiểm tra instance tồn tại trước khi gọi</span>
     <span class="token punctuation">{</span>
         <span class="token comment">// Giả sử phá hủy chướng ngại vật sẽ được điểm</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>canBeDestroyed<span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
              GameManager<span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">AddScore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Gọi hàm AddScore của GameManager, cộng 5 điểm</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// Hoặc có thể cộng điểm dựa trên damageAmount, v.v...</span>
         <span class="token comment">// GameManager.instance.AddScore(damageAmount);</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// --- Hết code mới ---</span>

     <span class="token keyword">if</span> <span class="token punctuation">(</span>canBeDestroyed<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" is destroyed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">Destroy</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre>
</li>
<li>
<p><strong>Bước 6: Playtest Hệ thống điểm:</strong></p>
<ul>
<li>Lưu các script. Quay lại Unity.</li>
<li>Nhấn Play.</li>
<li>Lái xe đâm vào chướng ngại vật có <code>Can Be Destroyed = true</code>.</li>
<li>Quan sát UI Text trên màn hình. Điểm số có tăng lên không? Quan sát Console xem log điểm.</li>
</ul>
</li>
<li>
<p><strong>Access Modifiers (<code>public</code> vs <code>private</code>):</strong></p>
<ul>
<li><code>public</code>: Có thể truy cập (gọi hàm, đọc/ghi biến) từ bất kỳ script nào khác. Hiển thị trong Inspector. Dùng cho những gì cần tương tác từ bên ngoài hoặc chỉnh sửa trong Editor.</li>
<li><code>private</code> (Mặc định nếu không ghi gì): Chỉ có thể truy cập từ bên trong chính Class đó. Không hiển thị trong Inspector. Dùng để ẩn giấu chi tiết cài đặt bên trong, bảo vệ dữ liệu.</li>
<li>Ví dụ: <code>GameManager.AddScore</code> là <code>public</code> để <code>Obstacle</code> gọi được. <code>GameManager.UpdateScoreUI</code> là <code>private</code> vì chỉ <code>GameManager</code> cần dùng nó.</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV đặt câu hỏi: “Ở bài trước, các chướng ngại vật (<code>Obstacle</code>) của chúng ta chỉ có dữ liệu (loại, sát thương…). Làm sao để chúng thực sự <em>làm</em> gì đó khi bị xe đâm vào? Ví dụ: tự biến mất, hoặc cộng điểm cho người chơi?”</li>
<li>GV liên hệ: “Giống như Class <code>Dog</code> không chỉ có thuộc tính màu lông, giống loài, mà còn có <em>hành động</em> như sủa, vẫy đuôi. Class trong lập trình cũng vậy, chúng cần có các <em>phương thức</em> (methods) để thực hiện hành động.”</li>
<li>Giới thiệu mục tiêu: “Hôm nay, chúng ta sẽ thêm ‘hành động’ cho Class <code>Obstacle</code>, làm cho chúng phản ứng khi va chạm. Chúng ta cũng sẽ tạo một ‘nhà quản lý’ (<code>GameManager</code>) để theo dõi điểm số của người chơi.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Nêu bật sự cần thiết của việc thêm hành vi (methods) vào Class, giới thiệu khái niệm tương tác giữa các object và quản lý trạng thái game.</li>
</ul>
<p><strong>2. Explore (Khám phá - 40 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Thêm Hành vi (Methods) vào Class và Tương tác giữa các Object”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li>Thêm phương thức <code>HitObstacle()</code> vào Class <code>Obstacle</code>.</li>
<li>Sửa đổi <code>OnCollisionEnter()</code> trong <code>KartController</code> để lấy component <code>Obstacle</code> và gọi phương thức <code>HitObstacle()</code> của nó.</li>
<li>Playtest để kiểm tra log va chạm và hành vi <code>Destroy</code> của <code>Obstacle</code>.</li>
<li>Tạo GameObject và script <code>GameManager</code>. Viết code quản lý điểm và Singleton pattern.</li>
<li>Tạo UI Text và kết nối nó với <code>GameManager</code> trong Inspector.</li>
<li>Sửa đổi <code>Obstacle.HitObstacle()</code> để gọi <code>GameManager.instance.AddScore()</code>.</li>
<li>Playtest hệ thống điểm.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp sửa lỗi cú pháp, lỗi logic khi gọi phương thức hoặc truy cập <code>instance</code>.</li>
<li>Giải thích lại các bước nếu HS gặp khó khăn (đặc biệt là phần Singleton và kết nối UI).</li>
<li>Đảm bảo HS hiểu được luồng tương tác: Va chạm -&gt; <code>OnCollisionEnter</code> (Kart) -&gt; <code>GetComponent&lt;Obstacle&gt;</code> -&gt; Gọi <code>HitObstacle</code> (Obstacle) -&gt; Gọi <code>AddScore</code> (GameManager) -&gt; Cập nhật UI.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành viết phương thức, thực hiện gọi phương thức giữa các object khác nhau, tạo và sử dụng Singleton GameManager cơ bản, kết nối logic game với UI.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập trung giải thích các khái niệm và kỹ thuật mới:
<ul>
<li><strong>Phương thức (Methods):</strong> Mục đích (đóng gói hành vi), cách khai báo (<code>public/private returnType MethodName(parameters)</code>). Sự khác biệt giữa định nghĩa phương thức và gọi phương thức.</li>
<li><strong>Tương tác Object:</strong> Luồng gọi <code>GetComponent&lt;T&gt;()</code> để lấy tham chiếu tới object khác và sau đó dùng dấu chấm (<code>.</code>) để truy cập thuộc tính public hoặc gọi phương thức public của object đó (<code>hitObstacle.HitObstacle()</code>). Vẽ sơ đồ luồng tương tác lên bảng.</li>
<li><strong>Access Modifiers (<code>public</code> vs <code>private</code>):</strong> Tại sao <code>HitObstacle</code> và <code>AddScore</code> là <code>public</code>? Tại sao <code>UpdateScoreUI</code> nên là <code>private</code>? Lợi ích của việc che giấu thông tin (information hiding).</li>
<li><strong><code>static</code> và Singleton Pattern (cơ bản):</strong> Mục đích của <code>static GameManager instance</code> (chỉ có một, truy cập dễ dàng). Giải thích nhanh mô hình <code>Awake()</code> để đảm bảo chỉ có một <code>GameManager</code>. Nhấn mạnh đây là một pattern phổ biến để quản lý các hệ thống toàn cục.</li>
<li><strong>Tái cấu trúc (Refactoring):</strong> So sánh cách xử lý va chạm trước đây (có thể chỉ log trong <code>KartController</code>) với bây giờ (gọi phương thức của <code>Obstacle</code>). Mã nguồn trở nên gọn hơn trong <code>KartController</code> và logic xử lý của chướng ngại vật được đặt đúng chỗ (trong Class <code>Obstacle</code>). Nhấn mạnh lợi ích về tính tổ chức và bảo trì.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giải thích sâu về phương thức, cách thức tương tác giữa các object, ý nghĩa của <code>public/private</code>, giới thiệu Singleton pattern và lợi ích của việc tái cấu trúc code theo hướng đối tượng.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Brainstorming &amp; Design):</strong>
<ul>
<li>GV chia HS thành các nhóm nhỏ.</li>
<li>Yêu cầu mỗi nhóm thảo luận và thiết kế (trên giấy) các phương thức cần thiết cho một trong các Class đã phác thảo ở bài trước (hoặc Class mới):
<ul>
<li>Class <code>PowerUp</code>: Cần phương thức gì? (<code>ApplyPowerUp(KartController kart)</code>, <code>StartTimer()</code>, <code>RemoveEffect()</code>).</li>
<li>Class <code>FinishLine</code>: Cần phương thức gì? (<code>RecordFinishTime(KartController kart)</code>, <code>ShowResults()</code>).</li>
<li>Class <code>KartController</code>: Có thể thêm phương thức gì? (<code>TakeDamage(int amount)</code>, <code>Boost(float duration)</code>, <code>ResetPosition()</code>).</li>
</ul>
</li>
<li>Nhóm chỉ cần liệt kê tên phương thức, kiểu trả về (nếu có), và các tham số đầu vào (nếu cần), cùng mô tả ngắn gọn chức năng. Không cần viết code chi tiết.</li>
<li>GV đi quanh các nhóm, gợi ý và giải đáp thắc mắc.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS tư duy về hành vi của các đối tượng khác nhau trong game, thực hành thiết kế phương thức (xác định input, output, chức năng) như một bước chuẩn bị trước khi code.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Chia sẻ Thiết kế:</strong> Mời đại diện 1-2 nhóm trình bày nhanh thiết kế phương thức của họ cho một Class. Các nhóm khác lắng nghe và có thể góp ý.</li>
<li><strong>Câu hỏi nhanh:</strong>
<ol>
<li>Từ khóa nào dùng để định nghĩa một hành động (hàm) bên trong Class? (Không có từ khóa cụ thể, nhưng đó là phương thức/method).</li>
<li>Làm thế nào để script A gọi được một phương thức <code>public</code> của script B trên một GameObject khác? (Lấy component B từ GameObject đó, rồi dùng dấu <code>.</code> để gọi phương thức).</li>
<li>Từ khóa <code>public</code> và <code>private</code> dùng để làm gì? (Kiểm soát truy cập).</li>
<li>Tại sao việc đặt logic xử lý va chạm của chướng ngại vật vào phương thức <code>HitObstacle</code> của Class <code>Obstacle</code> lại tốt hơn là viết hết trong <code>KartController</code>? (Tổ chức tốt hơn, dễ bảo trì, logic đúng chỗ).</li>
<li>Mục đích chính của Singleton <code>GameManager</code> là gì? (Quản lý trạng thái chung, dễ truy cập từ mọi nơi).</li>
</ol>
</li>
<li><strong>Quan sát:</strong> Chất lượng thiết kế phương thức của các nhóm, khả năng giải thích luồng tương tác, câu trả lời cho các câu hỏi.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng thiết kế phương thức, hiểu biết về tương tác object, access modifiers, Singleton cơ bản và lợi ích của việc tổ chức code OOP.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tổng kết: Chúng ta đã tiến một bước lớn trong việc sử dụng OOP bằng cách thêm hành vi (methods) vào Class và làm cho các object tương tác với nhau. Chúng ta cũng đã tạo ra <code>GameManager</code> để quản lý điểm số.</li>
<li>Nhấn mạnh lợi ích của việc tổ chức code rõ ràng, logic đặt đúng chỗ.</li>
<li>Giới thiệu buổi học tiếp theo: “Game của chúng ta đã có tương tác vật lý, điều khiển, và một chút logic. Buổi sau, chúng ta sẽ làm cho nó sinh động hơn nữa bằng cách thêm Animation cho xe đua!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.7-bổ-sung-animation-3d-cơ-bản">Giáo án Buổi học 2.1.7: Bổ sung Animation 3D cơ bản</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành buổi 2.1.6.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS xác định và sử dụng được các cửa sổ Animation và Animator trong Unity Editor.</li>
<li>HS tạo được một Animator Controller asset và gắn nó vào GameObject (xe đua).</li>
<li>HS hiểu và tạo được các States (trạng thái animation) trong Animator Controller, liên kết chúng với các Animation Clips có sẵn (ví dụ: idle, driving).</li>
<li>HS tạo và sử dụng được các Parameters (ví dụ: kiểu Bool, Float) trong Animator Controller để điều khiển việc chuyển đổi giữa các States.</li>
<li>HS thiết lập được các Transitions (chuyển đổi) giữa các States dựa trên điều kiện của Parameters.</li>
<li>HS viết được code C# đơn giản trong <code>KartController</code> để cập nhật giá trị của Animator Parameters dựa trên trạng thái hiện tại của xe (ví dụ: đang chạy hay đứng yên).</li>
<li>HS quan sát được sự thay đổi animation của xe trong game dựa trên hành động của người chơi.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Adventure từ buổi trước cho mỗi HS. <em>(Quan trọng: Đảm bảo project Karting Microgame gốc hoặc project HS đang làm có chứa model xe đua đã được thiết lập sẵn với các animation clips cơ bản như idle, drive, turn… Nếu không, cần chuẩn bị sẵn một model đơn giản có animation clips hoặc hướng dẫn HS import từ Asset Store).</em></li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Giới thiệu Hệ thống Animation trong Unity (Animator Controller)” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Giới thiệu Hệ thống Animation trong Unity (Animator Controller)"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Mục tiêu là giúp bạn làm cho chiếc xe đua trở nên sống động hơn bằng cách sử dụng hệ thống Animator của Unity để chuyển đổi giữa các hoạt ảnh (animation) khác nhau như đứng yên, lái xe, rẽ…</li>
<li><strong>Các Thành phần Chính:</strong>
<ul>
<li><strong>Animation Clips:</strong> Các file chứa dữ liệu hoạt ảnh (ví dụ: <code>Kart_Idle.anim</code>, <code>Kart_Drive.anim</code>). Thường được tạo bởi họa sĩ 3D hoặc tạo trực tiếp trong Unity. Chúng ta sẽ sử dụng clip có sẵn trong project.</li>
<li><strong>Animator Component:</strong> Component gắn vào GameObject (xe Kart) để liên kết GameObject đó với một Animator Controller.</li>
<li><strong>Animator Controller:</strong> Asset chứa “sơ đồ logic” điều khiển việc chuyển đổi giữa các Animation Clips. Đây là nơi chúng ta sẽ làm việc chính.</li>
<li><strong>Cửa sổ Animator:</strong> Nơi để xem và chỉnh sửa Animator Controller (sơ đồ logic).</li>
<li><strong>Cửa sổ Animation:</strong> Nơi để xem trước hoặc tạo/chỉnh sửa Animation Clips (chúng ta ít dùng ở bài này).</li>
</ul>
</li>
<li><strong>Bước 1: Kiểm tra Animator Component và Animation Clips:</strong>
<ul>
<li>Chọn GameObject xe Kart trong Hierarchy.</li>
<li>Trong Inspector, kiểm tra xem đã có component <code>Animator</code> chưa. Nếu chưa, nhấn “Add Component” và thêm <code>Animator</code>.</li>
<li>Trong cửa sổ Project, tìm thư mục chứa Animation Clips của xe Kart (thường nằm trong thư mục Models hoặc Animations). Xác định các clip quan trọng như Idle (đứng yên), Drive (lái tới), TurnLeft, TurnRight…</li>
<li><em>Hình ảnh minh họa Animator component và vị trí các animation clips.</em></li>
</ul>
</li>
<li><strong>Bước 2: Tạo Animator Controller:</strong>
<ul>
<li>Trong cửa sổ Project (ví dụ: trong thư mục “Animations” hoặc “Controllers”), nhấp chuột phải -&gt; <code>Create</code> -&gt; <code>Animator Controller</code>.</li>
<li>Đặt tên cho asset này là “KartAnimatorController”.</li>
<li><em>Hình ảnh minh họa tạo Animator Controller asset.</em></li>
</ul>
</li>
<li><strong>Bước 3: Gắn Animator Controller vào Xe:</strong>
<ul>
<li>Chọn GameObject xe Kart.</li>
<li>Trong Inspector, tìm component <code>Animator</code>. Kéo thả asset “KartAnimatorController” từ cửa sổ Project vào ô “Controller” của component <code>Animator</code>.</li>
<li><em>Hình ảnh minh họa gắn controller vào component.</em></li>
</ul>
</li>
<li><strong>Bước 4: Mở Cửa sổ Animator và Làm quen:</strong>
<ul>
<li>Nhấp đúp vào asset “KartAnimatorController” trong cửa sổ Project (hoặc chọn xe Kart rồi vào <code>Window</code> -&gt; <code>Animation</code> -&gt; <code>Animator</code>).</li>
<li>Bạn sẽ thấy một giao diện dạng sơ đồ với các nút đặc biệt như <code>Entry</code>, <code>Exit</code>, <code>Any State</code>. Đây là nơi chúng ta sẽ xây dựng logic animation.</li>
<li><em>Hình ảnh minh họa cửa sổ Animator ban đầu.</em></li>
</ul>
</li>
<li><strong>Bước 5: Tạo State cho Animation “Idle”:</strong>
<ul>
<li>Trong cửa sổ Project, tìm Animation Clip “Idle” của xe Kart (ví dụ: <code>Kart_Idle</code>).</li>
<li>Kéo thả Animation Clip này từ Project vào vùng trống trong cửa sổ Animator.</li>
<li>Một nút màu cam mới sẽ xuất hiện, đại diện cho trạng thái “Idle”. Màu cam nghĩa là đây là trạng thái mặc định (Default State) - animation sẽ bắt đầu từ đây.</li>
<li><em>Hình ảnh minh họa kéo thả clip Idle.</em></li>
</ul>
</li>
<li><strong>Bước 6: Tạo State cho Animation “Drive”:</strong>
<ul>
<li>Tương tự, kéo thả Animation Clip “Drive” (ví dụ: <code>Kart_Drive</code>) vào cửa sổ Animator. Một nút màu xám mới sẽ xuất hiện.</li>
</ul>
</li>
<li><strong>Bước 7: Tạo Parameter để điều khiển:</strong>
<ul>
<li>Trong cửa sổ Animator, tìm tab “Parameters” (thường ở góc trên bên trái).</li>
<li>Nhấn vào dấu “+” và chọn kiểu Parameter. Chúng ta cần biết xe đang chạy hay đứng yên, nên dùng kiểu <code>Bool</code> (true/false).</li>
<li>Đặt tên cho Parameter là <code>IsDriving</code>. Bỏ dấu tick ở ô checkbox bên cạnh (giá trị mặc định là <code>false</code> - đứng yên).</li>
<li><em>Hình ảnh minh họa tạo Parameter Bool.</em></li>
</ul>
</li>
<li><strong>Bước 8: Tạo Transition (Chuyển đổi) từ Idle sang Drive:</strong>
<ul>
<li>Trong sơ đồ Animator, nhấp chuột phải vào nút state “Idle” -&gt; chọn <code>Make Transition</code>.</li>
<li>Một mũi tên sẽ xuất hiện, kéo đầu mũi tên và nhấp vào nút state “Drive”.</li>
<li>Nhấp vào mũi tên Transition vừa tạo (nó sẽ sáng lên).</li>
<li>Trong Inspector, tìm mục “Conditions”. Nhấn dấu “+” để thêm điều kiện.</li>
<li>Chọn Parameter <code>IsDriving</code> từ danh sách thả xuống. Đảm bảo điều kiện là <code>true</code>.</li>
<li><strong>Quan trọng:</strong> Bỏ dấu tick ở ô “Has Exit Time”. Điều này có nghĩa là transition sẽ xảy ra ngay khi điều kiện <code>IsDriving</code> là <code>true</code>, không cần đợi animation “Idle” chạy xong.</li>
<li><em>Hình ảnh minh họa tạo transition và cài đặt conditions.</em></li>
</ul>
</li>
<li><strong>Bước 9: Tạo Transition từ Drive về Idle:</strong>
<ul>
<li>Tương tự, nhấp chuột phải vào state “Drive” -&gt; <code>Make Transition</code> -&gt; nhấp vào state “Idle”.</li>
<li>Chọn mũi tên transition mới này.</li>
<li>Trong Inspector, mục “Conditions”, thêm điều kiện: Parameter <code>IsDriving</code>, điều kiện là <code>false</code>.</li>
<li>Bỏ dấu tick ở ô “Has Exit Time”.</li>
</ul>
</li>
<li><strong>Bước 10: Viết Code Cập nhật Parameter:</strong>
<ul>
<li>Mở script <code>KartController</code>.</li>
<li>Thêm một biến private để giữ tham chiếu tới Animator:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">private</span> Animator animator<span class="token punctuation">;</span> <span class="token comment">// Tham chiếu tới Animator component</span>
</code></pre>
<ul>
<li>Trong hàm <code>Start()</code>, lấy tham chiếu tới Animator:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    rb <span class="token operator">=</span> <span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>Rigidbody<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    animator <span class="token operator">=</span> <span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>Animator<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Lấy Animator component</span>

    rb<span class="token punctuation">.</span>drag <span class="token operator">=</span> dragOnGround<span class="token punctuation">;</span>
    rb<span class="token punctuation">.</span>angularDrag <span class="token operator">=</span> angularDragOnGround<span class="token punctuation">;</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"KartController script started!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Kiểm tra xem có lấy được Animator không</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>animator <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">LogError</span><span class="token punctuation">(</span><span class="token string">"Animator component not found on the Kart!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>Trong hàm <code>Update()</code> (hoặc <code>FixedUpdate()</code> cũng được, tùy logic), thêm code để cập nhật Parameter <code>IsDriving</code>:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    horizontalInput <span class="token operator">=</span> Input<span class="token punctuation">.</span><span class="token function">GetAxis</span><span class="token punctuation">(</span><span class="token string">"Horizontal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    verticalInput <span class="token operator">=</span> Input<span class="token punctuation">.</span><span class="token function">GetAxis</span><span class="token punctuation">(</span><span class="token string">"Vertical"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// --- Code mới cập nhật Animator ---</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>animator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Nếu có input dọc (tiến/lùi) hoặc xe đang di chuyển với tốc độ đáng kể</span>
        <span class="token comment">// (rb.velocity.sqrMagnitude &gt; 0.1f là một cách kiểm tra tốc độ đơn giản)</span>
        <span class="token comment">// thì đặt IsDriving thành true, ngược lại là false.</span>
        <span class="token keyword">bool</span> currentlyDriving <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Abs</span><span class="token punctuation">(</span>verticalInput<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0.01f</span> <span class="token operator">||</span> rb<span class="token punctuation">.</span>velocity<span class="token punctuation">.</span>sqrMagnitude <span class="token operator">&gt;</span> <span class="token number">0.1f</span><span class="token punctuation">;</span>
        animator<span class="token punctuation">.</span><span class="token function">SetBool</span><span class="token punctuation">(</span><span class="token string">"IsDriving"</span><span class="token punctuation">,</span> currentlyDriving<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// --- Hết code mới ---</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong>
<ul>
<li><code>GetComponent&lt;Animator&gt;()</code>: Lấy component Animator.</li>
<li><code>animator.SetBool("IsDriving", currentlyDriving)</code>: Đặt giá trị cho Parameter <code>IsDriving</code> trong Animator Controller. Tên “IsDriving” phải <em>chính xác</em> như bạn đã đặt trong tab Parameters. <code>currentlyDriving</code> là biến bool tính toán dựa trên input hoặc tốc độ hiện tại.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Bước 11: Playtest Animation:</strong>
<ul>
<li>Lưu script. Quay lại Unity.</li>
<li>Nhấn Play.</li>
<li>Quan sát xe Kart: Khi đứng yên, nó có chạy animation “Idle” không?</li>
<li>Nhấn nút tiến/lùi: Xe có chuyển sang animation “Drive” không?</li>
<li>Thả nút: Xe có quay lại animation “Idle” không?</li>
<li>(Tùy chọn) Mở cửa sổ Animator khi game đang chạy. Bạn sẽ thấy state nào đang active (sáng lên) và các transition diễn ra.</li>
</ul>
</li>
<li><strong>Troubleshooting:</strong>
<ul>
<li>Animation không chạy: Đảm bảo đã gắn Animator Controller vào component Animator. Đảm bảo tên Parameter trong code (<code>SetBool("IsDriving"...)</code>) <em>khớp chính xác</em> với tên Parameter trong tab Parameters của cửa sổ Animator. Kiểm tra Console xem có lỗi không.</li>
<li>Transition không xảy ra: Kiểm tra lại điều kiện (Conditions) trên mũi tên transition. Đảm bảo đã bỏ tick “Has Exit Time” nếu muốn chuyển tức thì.</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chiếu lại cảnh xe đua trong game (đã có điều khiển) và hỏi: “Chiếc xe của chúng ta chạy được rồi, nhưng trông nó vẫn hơi ‘cứng’, phải không? Bánh xe không lăn, không có cảm giác rung lắc khi chạy…”</li>
<li>GV cho xem một ví dụ (video/GIF) về một chiếc xe trong game khác có animation mượt mà (bánh xe quay, có thể có cả hiệu ứng nghiêng khi rẽ…).</li>
<li>GV dẫn dắt: “Để làm cho đối tượng sống động và biểu cảm hơn, chúng ta cần đến Animation! Hôm nay, chúng ta sẽ học cách ra lệnh cho xe chuyển đổi giữa các hoạt ảnh khác nhau, ví dụ như từ trạng thái đứng yên sang trạng thái lái xe.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Nêu bật hạn chế về mặt hình ảnh của đối tượng hiện tại, tạo nhu cầu về animation, giới thiệu mục tiêu làm cho xe “sống động” hơn.</li>
</ul>
<p><strong>2. Explore (Khám phá - 40 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Giới thiệu Hệ thống Animation trong Unity (Animator Controller)”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li>Kiểm tra Animator component và tìm Animation Clips có sẵn.</li>
<li>Tạo Animator Controller asset.</li>
<li>Gắn Controller vào xe.</li>
<li>Mở cửa sổ Animator.</li>
<li>Kéo thả các clip Idle, Drive vào Animator để tạo States.</li>
<li>Tạo Parameter <code>IsDriving</code> kiểu Bool.</li>
<li>Tạo Transitions giữa Idle và Drive với điều kiện dựa trên <code>IsDriving</code>. Bỏ tick “Has Exit Time”.</li>
<li>Thêm code vào <code>KartController</code> để lấy Animator và gọi <code>animator.SetBool("IsDriving", ...)</code> trong <code>Update</code>.</li>
<li>Playtest để xem xe chuyển đổi giữa animation Idle và Drive khi nhấn/thả nút tiến/lùi.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp HS tìm đúng Animation Clips và cửa sổ Animator.</li>
<li>Hướng dẫn cách tạo State, Parameter, Transition nếu HS gặp khó khăn.</li>
<li>Kiểm tra lỗi cú pháp trong code C#.</li>
<li><em>Quan trọng:</em> Đảm bảo HS nhập <em>chính xác</em> tên Parameter (<code>IsDriving</code>) trong cả Animator và Code.</li>
<li>Khuyến khích HS mở cửa sổ Animator khi game đang chạy để quan sát trực quan luồng hoạt động.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành các bước cơ bản để thiết lập Animator Controller, tạo States, Parameters, Transitions và kết nối chúng với logic game thông qua script C#.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV sử dụng cửa sổ Animator trên máy chiếu để hệ thống hóa lại các khái niệm:
<ul>
<li><strong>Animator Controller:</strong> Sơ đồ logic, “bộ não” điều khiển animation.</li>
<li><strong>States:</strong> Mỗi nút đại diện cho một trạng thái hoạt ảnh cụ thể (Idle, Drive, Jump…). Một State được liên kết với một Animation Clip.</li>
<li><strong>Animation Clips:</strong> Dữ liệu hoạt ảnh thực tế.</li>
<li><strong>Parameters:</strong> Các biến (Bool, Int, Float, Trigger) dùng làm “công tắc” hoặc “thông số” để điều khiển việc chuyển đổi giữa các States. Chúng được thay đổi từ code C#.</li>
<li><strong>Transitions:</strong> Các mũi tên nối giữa các States, quy định việc chuyển đổi có thể xảy ra.</li>
<li><strong>Conditions:</strong> Điều kiện gắn trên Transitions, dựa trên giá trị của Parameters. Transition chỉ xảy ra khi tất cả Conditions được thỏa mãn.</li>
<li><strong>Has Exit Time:</strong> Ý nghĩa của việc tick/bỏ tick. Tick: Phải đợi animation hiện tại chạy hết một phần hoặc toàn bộ mới chuyển. Bỏ tick: Chuyển ngay lập tức khi điều kiện đúng (thường dùng cho các hành động tức thời như nhảy, tấn công, hoặc chuyển trạng thái lái xe).</li>
<li><strong>Code C#:</strong> Cách lấy component <code>Animator</code> (<code>GetComponent&lt;Animator&gt;()</code>) và cách thay đổi giá trị Parameter (<code>animator.SetBool()</code>, <code>animator.SetFloat()</code>, <code>animator.SetInteger()</code>, <code>animator.SetTrigger()</code>). Nhấn mạnh sự cần thiết phải khớp tên Parameter chính xác.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giải thích rõ ràng vai trò và mối liên hệ giữa các thành phần cốt lõi của hệ thống Animator, cách chúng phối hợp với nhau và với code C# để tạo ra hoạt ảnh động.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thêm Animation Rẽ trái/phải):</strong>
<ul>
<li>GV thử thách HS (hướng dẫn nhanh nếu cần):
<ul>
<li>Tìm Animation Clips cho việc Rẽ Trái (<code>TurnLeft</code>) và Rẽ Phải (<code>TurnRight</code>) trong Project.</li>
<li>Tạo thêm 2 States mới trong Animator Controller cho <code>TurnLeft</code> và <code>TurnRight</code>.</li>
<li>Tạo một Parameter mới kiểu <code>Float</code> tên là <code>TurnDirection</code> (giá trị từ -1 đến 1).</li>
<li>Tạo Transitions từ State “Drive” sang “TurnLeft” (điều kiện: <code>IsDriving</code> = true, <code>TurnDirection</code> &lt; -0.1) và sang “TurnRight” (điều kiện: <code>IsDriving</code> = true, <code>TurnDirection</code> &gt; 0.1).</li>
<li>Tạo Transitions từ “TurnLeft”/“TurnRight” quay về “Drive” (điều kiện: <code>IsDriving</code> = true, <code>TurnDirection</code> trong khoảng -0.1 đến 0.1).</li>
<li>Trong script <code>KartController</code> (hàm <code>Update</code>), thêm dòng: <code>animator.SetFloat("TurnDirection", horizontalInput);</code></li>
</ul>
</li>
<li>HS thử tự làm hoặc làm theo hướng dẫn của GV. Playtest để xem xe có animation rẽ khi nhấn nút trái/phải không. <em>Lưu ý: Việc này có thể phức tạp hơn, GV cân nhắc mức độ của lớp.</em></li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Áp dụng kiến thức vừa học để xử lý một tình huống phức tạp hơn (thêm state và parameter mới), sử dụng Parameter kiểu Float, củng cố kỹ năng thiết lập Animator Controller.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Demo nhanh:</strong> Mời 1-2 HS đã làm được (hoặc thử làm) phần animation rẽ lái chia sẻ nhanh kết quả.</li>
<li><strong>Câu hỏi nhanh:</strong>
<ol>
<li>Asset nào chứa sơ đồ logic điều khiển animation? (Animator Controller)</li>
<li>Các nút trong Animator Controller đại diện cho cái gì? (States / Trạng thái animation)</li>
<li>Thành phần nào dùng để làm điều kiện chuyển đổi giữa các States? (Parameters)</li>
<li>Các mũi tên nối giữa các States gọi là gì? (Transitions)</li>
<li>Lệnh C# nào dùng để đặt giá trị cho Parameter kiểu Bool trong Animator? (<code>animator.SetBool("TênParameter", giá_trị_bool)</code>)</li>
</ol>
</li>
<li><strong>Quan sát:</strong> Khả năng HS hoàn thành các bước Explore, mức độ thành công khi thử phần Elaborate, câu trả lời cho các câu hỏi.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá mức độ nắm vững các thuật ngữ và thành phần chính của Animator Controller, khả năng thiết lập transition cơ bản và kết nối với code.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV khen ngợi HS đã làm cho chiếc xe trở nên “có hồn” hơn.</li>
<li>Nhấn mạnh Animator Controller là một công cụ mạnh mẽ để quản lý các trạng thái phức tạp của nhân vật/đối tượng.</li>
<li>Giới thiệu buổi học tiếp theo: “Animation của chúng ta hiện tại chuyển đổi khá đột ngột giữa lái thẳng và rẽ. Buổi sau, chúng ta sẽ học cách dùng Blend Tree để trộn các animation này lại mượt mà hơn, tạo cảm giác rẽ tự nhiên hơn.”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.8-tinh-chỉnh-hành-vi-và-chuyển-động-với-blend-tree">Giáo án Buổi học 2.1.8: Tinh chỉnh hành vi và chuyển động với Blend Tree</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành buổi 2.1.7 và có các animation clips cơ bản (Idle, Drive, TurnLeft, TurnRight).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS giải thích được lý do cần sử dụng Blend Tree (trộn mượt mà nhiều animation dựa trên giá trị liên tục).</li>
<li>HS tạo và cấu hình được một State mới trong Animator Controller sử dụng Blend Tree (loại 1D).</li>
<li>HS thêm được nhiều Animation Clips vào một Blend Tree (ví dụ: TurnLeft, Drive, TurnRight).</li>
<li>HS chọn và sử dụng được một Parameter kiểu Float để điều khiển sự pha trộn (blend) trong Blend Tree.</li>
<li>HS thiết lập được các ngưỡng (Thresholds) cho từng Animation Clip trong Blend Tree.</li>
<li>HS điều chỉnh được code C# (<code>KartController</code>) để cung cấp giá trị chính xác và liên tục cho Parameter điều khiển Blend Tree.</li>
<li>HS quan sát và đánh giá được sự cải thiện về độ mượt của animation (đặc biệt là khi rẽ) so với việc sử dụng các State và Transition riêng biệt.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Adventure với Animator Controller đã thiết lập cơ bản (Idle, Drive states) và các animation clips (Idle, Drive, TurnLeft, TurnRight) cho xe Kart.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Sử dụng Blend Tree để Trộn Animation Mượt Mà” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Sử dụng Blend Tree để Trộn Animation Mượt Mà"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Ở bài trước, chúng ta đã dùng các State riêng biệt cho Idle, Drive, TurnLeft, TurnRight. Tuy nhiên, việc chuyển đổi giữa Drive và Turn có thể hơi đột ngột. Blend Tree là một công cụ mạnh mẽ trong Animator Controller giúp chúng ta <em>trộn</em> nhiều animation lại với nhau một cách mượt mà dựa trên một hoặc hai thông số (Parameters). Hôm nay chúng ta sẽ dùng Blend Tree 1D để trộn animation rẽ trái, lái thẳng và rẽ phải.</li>
<li><strong>Vấn đề với State riêng biệt:</strong> Khi chuyển từ Drive sang TurnLeft, animation thay đổi tức thì, không có sự chuyển tiếp tự nhiên thể hiện việc <em>bắt đầu</em> rẽ hoặc rẽ <em>nhẹ</em>.</li>
<li><strong>Giải pháp Blend Tree:</strong> Blend Tree cho phép bạn định nghĩa một “dải” giá trị (ví dụ: từ -1 cho rẽ trái hết cỡ, 0 cho lái thẳng, 1 cho rẽ phải hết cỡ). Dựa vào giá trị hiện tại của một Parameter (ví dụ: <code>TurnDirection</code>), Blend Tree sẽ tự động pha trộn các animation tương ứng (TurnLeft, Drive, TurnRight) để tạo ra hoạt ảnh phù hợp.</li>
<li><strong>Bước 1: Chuẩn bị Animator Controller:</strong>
<ul>
<li>Mở cửa sổ Animator (<code>Window</code> -&gt; <code>Animation</code> -&gt; <code>Animator</code> hoặc nhấp đúp vào “KartAnimatorController”).</li>
<li><em>Xóa các State <code>TurnLeft</code>, <code>TurnRight</code> và các Transition liên quan đến chúng mà bạn đã tạo ở bài trước (nếu có).</em> Chúng ta sẽ thay thế chúng bằng Blend Tree. Giữ lại State <code>Idle</code> và <code>Drive</code>.</li>
<li>Đảm bảo bạn vẫn còn Parameter <code>IsDriving</code> (Bool) và <code>TurnDirection</code> (Float). Nếu chưa có <code>TurnDirection</code>, hãy tạo nó (kiểu Float, giá trị mặc định 0).</li>
</ul>
</li>
<li><strong>Bước 2: Tạo State Blend Tree mới:</strong>
<ul>
<li>Trong cửa sổ Animator, nhấp chuột phải vào vùng trống -&gt; <code>Create State</code> -&gt; <code>New Blend Tree</code>.</li>
<li>Một nút State mới màu xanh lá cây sẽ xuất hiện. Đặt tên cho State này là “DriveBlendTree” (nhấp vào tên để sửa).</li>
<li><em>Hình ảnh minh họa tạo Blend Tree State.</em></li>
</ul>
</li>
<li><strong>Bước 3: Thiết lập Transition vào Blend Tree:</strong>
<ul>
<li>Tạo Transition từ State <code>Idle</code> đến State <code>DriveBlendTree</code>.</li>
<li>Chọn mũi tên Transition này. Trong Inspector, đặt Conditions: <code>IsDriving</code> = <code>true</code>. Bỏ tick “Has Exit Time”.</li>
</ul>
</li>
<li><strong>Bước 4: Thiết lập Transition ra khỏi Blend Tree:</strong>
<ul>
<li>Tạo Transition từ State <code>DriveBlendTree</code> về State <code>Idle</code>.</li>
<li>Chọn mũi tên Transition này. Trong Inspector, đặt Conditions: <code>IsDriving</code> = <code>false</code>. Bỏ tick “Has Exit Time”.</li>
</ul>
</li>
<li><strong>Bước 5: Cấu hình Blend Tree:</strong>
<ul>
<li><strong>Nhấp đúp</strong> vào State <code>DriveBlendTree</code> trong cửa sổ Animator để “đi vào bên trong” nó.</li>
<li>Bạn sẽ thấy một node “Blend Tree” duy nhất. Chọn node này.</li>
<li>Trong Inspector:
<ul>
<li>Mục “Blend Type”: Đảm bảo đang chọn là <code>1D</code>.</li>
<li>Mục “Parameter”: Chọn Parameter kiểu Float bạn đã tạo để điều khiển việc rẽ, ví dụ: <code>TurnDirection</code>.</li>
<li><em>Hình ảnh minh họa Inspector của Blend Tree node.</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>Bước 6: Thêm Animation Clips vào Blend Tree:</strong>
<ul>
<li>Trong Inspector của Blend Tree node, tìm mục “Motion”. Nhấn vào dấu “+” -&gt; <code>Add Motion Field</code>. Làm thao tác này 3 lần để có 3 ô trống.</li>
<li><strong>Ô thứ nhất:</strong> Kéo thả Animation Clip <code>TurnLeft</code> (hoạt ảnh rẽ trái) vào ô “Motion”. Đặt giá trị <code>Threshold</code> (Ngưỡng) là <code>-1</code>.</li>
<li><strong>Ô thứ hai:</strong> Kéo thả Animation Clip <code>Drive</code> (hoạt ảnh lái thẳng) vào ô “Motion”. Đặt giá trị <code>Threshold</code> là <code>0</code>.</li>
<li><strong>Ô thứ ba:</strong> Kéo thả Animation Clip <code>TurnRight</code> (hoạt ảnh rẽ phải) vào ô “Motion”. Đặt giá trị <code>Threshold</code> là <code>1</code>.</li>
<li><strong>Quan trọng:</strong> Đảm bảo thứ tự các Motion Field và giá trị Threshold tương ứng: Rẽ trái (-1), Thẳng (0), Rẽ phải (1).</li>
<li><em>Hình ảnh minh họa thêm Motion và đặt Threshold.</em></li>
</ul>
</li>
<li><strong>Bước 7: Xem trước Blend Tree:</strong>
<ul>
<li>Trong Inspector của Blend Tree node, bạn sẽ thấy một thanh trượt nhỏ bên dưới biểu đồ “Blend Tree”. Kéo thanh trượt này qua lại giữa -1 và 1. Quan sát hình ảnh preview nhân vật/xe ở góc dưới Inspector thay đổi hoạt ảnh một cách mượt mà khi bạn kéo. Đây chính là sự pha trộn!</li>
<li><em>Hình ảnh minh họa thanh trượt preview.</em></li>
</ul>
</li>
<li><strong>Bước 8: Kiểm tra lại Code C#:</strong>
<ul>
<li>Mở script <code>KartController</code>.</li>
<li>Đảm bảo trong hàm <code>Update()</code> (hoặc nơi bạn xử lý input), bạn có dòng code để cập nhật giá trị Parameter <code>TurnDirection</code> dựa trên <code>horizontalInput</code>:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token comment">// Đảm bảo dòng này tồn tại và dùng đúng tên Parameter</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>animator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ... code cập nhật IsDriving ...</span>

    <span class="token comment">// Cập nhật TurnDirection dựa trên input ngang (-1 đến 1)</span>
    animator<span class="token punctuation">.</span><span class="token function">SetFloat</span><span class="token punctuation">(</span><span class="token string">"TurnDirection"</span><span class="token punctuation">,</span> horizontalInput<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><strong>Bước 9: Playtest và So sánh:</strong>
<ul>
<li>Lưu script và quay lại Unity.</li>
<li>Nhấn Play.</li>
<li>Lái xe và đặc biệt chú ý khi bạn rẽ trái/phải từ từ hoặc rẽ gấp.</li>
<li>So sánh với cách animation hoạt động trước khi dùng Blend Tree (nếu bạn còn nhớ). Animation rẽ bây giờ có mượt hơn không? Có sự chuyển tiếp tự nhiên hơn giữa lái thẳng và rẽ không?</li>
<li>Mở cửa sổ Animator khi game đang chạy và nhấp đúp vào State <code>DriveBlendTree</code> để xem thanh trượt bên trong tự động di chuyển theo input của bạn.</li>
</ul>
</li>
<li><strong>Troubleshooting:</strong>
<ul>
<li>Animation không blend/chỉ chạy một clip: Kiểm tra lại Parameter đã chọn cho Blend Tree trong Inspector. Kiểm tra lại code <code>SetFloat("TurnDirection", ...)</code> xem có chạy và dùng đúng tên Parameter không. Đảm bảo giá trị <code>horizontalInput</code> đang thay đổi từ -1 đến 1.</li>
<li>Blend không đúng (ví dụ: rẽ trái lại chạy anim rẽ phải): Kiểm tra lại thứ tự các Motion Field và giá trị Threshold (-1, 0, 1) trong Blend Tree Inspector.</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chiếu lại cảnh xe đua đã có animation cơ bản từ bài trước. Tập trung vào khoảnh khắc xe bắt đầu rẽ hoặc ngừng rẽ. Hỏi: “Các bạn có thấy animation chuyển đổi giữa lái thẳng và rẽ hơi bị ‘giật’ không? Nó giống như bật công tắc vậy.”</li>
<li>GV giải thích: “Trong thực tế, khi bạn lái xe, bạn rẽ lái từ từ, chiếc xe cũng nghiêng dần đi. Làm sao để mô phỏng sự chuyển tiếp mượt mà đó trong game?”</li>
<li>Giới thiệu Blend Tree: “Unity cung cấp một công cụ gọi là Blend Tree, cho phép chúng ta không chỉ chuyển đổi giữa các animation, mà còn <em>pha trộn</em> chúng lại với nhau một cách mượt mà dựa trên một giá trị nào đó, ví dụ như góc lái của bạn!”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giúp HS nhận ra hạn chế của phương pháp animation trước, tạo nhu cầu về sự mượt mà, giới thiệu Blend Tree như một giải pháp.</li>
</ul>
<p><strong>2. Explore (Khám phá - 40 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Sử dụng Blend Tree để Trộn Animation Mượt Mà”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li>Xóa các state/transition rẽ cũ (nếu có).</li>
<li>Tạo State Blend Tree mới (“DriveBlendTree”).</li>
<li>Thiết lập transitions vào/ra Blend Tree dựa trên <code>IsDriving</code>.</li>
<li>Đi vào cấu hình Blend Tree: chọn Parameter <code>TurnDirection</code>.</li>
<li>Thêm 3 Motion Fields: TurnLeft (-1), Drive (0), TurnRight (1).</li>
<li>Sử dụng thanh trượt preview trong Inspector để xem trước sự pha trộn.</li>
<li>Kiểm tra lại code C# đảm bảo <code>animator.SetFloat("TurnDirection", horizontalInput)</code> được gọi.</li>
<li>Playtest kỹ lưỡng, tập trung vào cảm nhận độ mượt khi rẽ lái ở các mức độ khác nhau.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Hướng dẫn HS cách xóa State/Transition cũ và tạo Blend Tree State.</li>
<li>Giúp HS cấu hình đúng Parameter và thêm Motion Fields với Threshold chính xác.</li>
<li>Giải đáp thắc mắc về cách Blend Tree hoạt động khi HS xem preview.</li>
<li>Đảm bảo code C# đang cập nhật đúng Parameter cho Blend Tree.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành các bước tạo và cấu hình Blend Tree 1D, thêm animation clips và thresholds, kết nối Blend Tree với Parameter được điều khiển bởi code, và trải nghiệm kết quả trực quan.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV sử dụng cửa sổ Animator và Inspector của Blend Tree trên máy chiếu để giải thích lại:
<ul>
<li><strong>Blend Tree là gì?</strong> Nó không phải là một animation clip mới, mà là một “bộ trộn” các clip có sẵn. Nó vẫn là một State trong Animator Controller.</li>
<li><strong>Tại sao gọi là “Blend”?</strong> Vì nó pha trộn (blend) tỷ lệ của các animation clips dựa trên giá trị của Parameter. Ví dụ: Nếu <code>TurnDirection</code> = -0.5, nó có thể chạy 50% animation <code>TurnLeft</code> và 50% animation <code>Drive</code>. Nếu <code>TurnDirection</code> = 0, nó chạy 100% <code>Drive</code>.</li>
<li><strong>Blend Type 1D:</strong> Ý nghĩa là sự pha trộn chỉ dựa trên <em>một</em> Parameter (một chiều).</li>
<li><strong>Parameter (Float):</strong> Tại sao dùng Float? Vì góc lái/hướng rẽ là một giá trị liên tục, không phải chỉ là bật/tắt (Bool).</li>
<li><strong>Motion Fields:</strong> Nơi chứa các animation clips sẽ được trộn.</li>
<li><strong>Thresholds (Ngưỡng):</strong> Xác định giá trị Parameter mà tại đó animation clip tương ứng sẽ đạt 100% trọng số (ảnh hưởng). Blend Tree sẽ nội suy (interpolate) giữa các ngưỡng này. (-1 ứng với TurnLeft, 0 ứng với Drive, 1 ứng với TurnRight).</li>
<li>So sánh với cách làm cũ: Blend Tree giúp giảm số lượng State và Transition cần quản lý, đồng thời tạo ra chuyển động mượt mà hơn nhiều cho các hành động có tính liên tục như di chuyển, rẽ lái.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giải thích cặn kẽ nguyên lý hoạt động của Blend Tree 1D, ý nghĩa của Thresholds và Parameter Float, lợi ích so với việc dùng nhiều State riêng biệt cho các biến thể của cùng một hành động.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Giới thiệu và Thảo luận Blend Tree 2D):</strong>
<ul>
<li>GV giới thiệu khái niệm Blend Tree 2D: “Nếu Blend Tree 1D trộn animation dựa trên 1 thông số (ví dụ: hướng rẽ), thì Blend Tree 2D có thể trộn dựa trên <em>hai</em> thông số cùng lúc!”</li>
<li>Ví dụ: Trộn animation di chuyển dựa trên cả <code>SpeedX</code> (tốc độ ngang - đi ngang/lùi ngang) và <code>SpeedY</code> (tốc độ dọc - tiến/lùi). Blend Tree 2D sẽ có dạng lưới thay vì đường thẳng.</li>
<li>GV có thể demo nhanh (không yêu cầu HS làm theo) cách tạo Blend Tree 2D và thêm các animation di chuyển 8 hướng (tiến, lùi, trái, phải, và các đường chéo) vào lưới, sử dụng 2 Parameters (ví dụ: <code>InputX</code>, <code>InputY</code>).</li>
<li>Thảo luận: “Trong game Karting, ngoài hướng rẽ (<code>TurnDirection</code>), còn thông số nào khác có thể dùng để blend animation không?” (Gợi ý: Tốc độ hiện tại của xe - <code>Speed</code>. Có thể blend giữa Idle, Drive chậm, Drive nhanh…).</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Mở rộng hiểu biết của HS sang Blend Tree 2D, gợi ý các ứng dụng phức tạp hơn của Blend Tree, khuyến khích tư duy về cách kết hợp nhiều yếu tố để điều khiển animation.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>So sánh Trước/Sau:</strong> Yêu cầu HS chia sẻ cảm nhận về độ mượt của animation rẽ lái <em>sau khi</em> dùng Blend Tree so với trước đó (nếu họ còn nhớ hoặc so với state Idle/Drive).</li>
<li><strong>Câu hỏi nhanh:</strong>
<ol>
<li>Công cụ nào dùng để trộn mượt mà nhiều animation dựa trên Parameter? (Blend Tree)</li>
<li>Blend Tree 1D trộn animation dựa trên mấy Parameter? (Một)</li>
<li>Giá trị nào xác định điểm mà một animation clip đạt 100% trọng số trong Blend Tree? (Threshold)</li>
<li>Kiểu dữ liệu Parameter nào thường dùng cho Blend Tree 1D điều khiển hướng rẽ (-1 đến 1)? (Float)</li>
<li>Lợi ích chính của việc dùng Blend Tree cho animation rẽ lái là gì? (Mượt mà hơn, tự nhiên hơn, giảm số State/Transition).</li>
</ol>
</li>
<li><strong>Quan sát:</strong> Mức độ thành công khi cấu hình Blend Tree, sự tham gia thảo luận, câu trả lời cho câu hỏi.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng áp dụng Blend Tree 1D, hiểu biết về các thành phần cấu hình và lợi ích của nó.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV chúc mừng HS đã làm chủ được Blend Tree để tạo animation mượt mà hơn đáng kể.</li>
<li>Nhấn mạnh rằng Blend Tree là một kỹ thuật rất phổ biến và quan trọng trong animation nhân vật và đối tượng 3D.</li>
<li>Giới thiệu buổi học tiếp theo: “Chúng ta đã đi qua các khái niệm cốt lõi về vật lý, scripting, và animation cơ bản. Buổi tiếp theo sẽ là cơ hội để các bạn ôn tập lại kiến thức, giải đáp thắc mắc và chuẩn bị cho việc hoàn thiện dự án Karting Adventure của mình.”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.9-ôn-tập-kiểm-tra-và-rà-soát-dự-án">Giáo án Buổi học 2.1.9: Ôn tập, Kiểm tra và Rà soát Dự án</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành các buổi học trước trong học phần 2.1.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS hệ thống hóa và củng cố lại các kiến thức, kỹ năng cốt lõi đã học trong học phần: Vật lý 3D (Rigidbody, Collider), Scripting C# (MonoBehaviour, Start, Update, FixedUpdate, GetComponent, AddForce, AddTorque, Input, OnCollisionEnter), Class &amp; Object (Fields, Methods, public/private, tương tác object, GameManager), Animation (Animator Controller, States, Parameters, Transitions, Blend Tree).</li>
<li>HS tự đánh giá được mức độ hiểu biết của bản thân thông qua bài kiểm tra lý thuyết ngắn.</li>
<li>HS xác định được những khó khăn, vướng mắc còn tồn tại trong kiến thức hoặc trong quá trình thực hiện dự án “Karting Adventure”.</li>
<li>HS nhận được phản hồi và giải đáp thắc mắc từ GV và các bạn học.</li>
<li>HS có kế hoạch sơ bộ cho các bước tiếp theo để hoàn thiện dự án của mình.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Adventure của HS.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Bài kiểm tra lý thuyết ngắn (Quiz):</strong> Khoảng 10-15 câu hỏi trắc nghiệm và/hoặc điền khuyết bao quát các chủ đề chính đã học. (Ví dụ câu hỏi bên dưới).</li>
<li>Bảng trắng hoặc công cụ ghi chú chung để tổng hợp thắc mắc và kế hoạch.</li>
<li>Phiếu phản hồi nhỏ hoặc công cụ trực tuyến để HS ghi lại khó khăn/câu hỏi ẩn danh (tùy chọn).</li>
</ul>
<p><strong>Ví dụ Câu hỏi Quiz:</strong></p>
<ol>
<li>Component nào chịu trách nhiệm cho việc đối tượng 3D tuân theo định luật vật lý (trọng lực, lực tác động)?<br>
a) Collider b) Mesh Renderer c) Rigidbody d) Transform</li>
<li>Để phát hiện va chạm giữa hai đối tượng, cả hai cần có component … và ít nhất một trong hai cần có component …<br>
(Điền vào chỗ trống: Collider, Rigidbody)</li>
<li>Hàm nào của MonoBehaviour được gọi đều đặn theo chu kỳ vật lý và là nơi tốt nhất để xử lý <code>AddForce</code>?<br>
a) Start() b) Update() c) OnCollisionEnter() d) FixedUpdate()</li>
<li>Lệnh nào dùng để lấy tham chiếu tới một component khác (ví dụ: Animator) trên cùng GameObject từ trong script?<br>
a) FindObjectOfType() b) GetComponent() c) AddComponent() d) GetReference()</li>
<li>Để đọc giá trị input từ trục “Horizontal” (trả về giá trị float từ -1 đến 1), bạn dùng lệnh: …<br>
(Điền vào chỗ trống: <code>Input.GetAxis("Horizontal")</code>)</li>
<li>Trong lập trình hướng đối tượng, … là bản thiết kế/khuôn mẫu, còn … là thể hiện cụ thể được tạo ra từ bản thiết kế đó.<br>
(Điền vào chỗ trống: Class, Object)</li>
<li>Từ khóa nào dùng để khai báo một biến hoặc phương thức có thể được truy cập từ các script khác?<br>
a) private b) static c) void d) public</li>
<li>Mục đích chính của Singleton Pattern (ví dụ: <code>GameManager.instance</code>) là gì?<br>
a) Tăng tốc độ game b) Tạo nhiều bản sao của đối tượng c) Đảm bảo chỉ có một thể hiện duy nhất và dễ truy cập d) Tự động hủy đối tượng</li>
<li>Trong Animator Controller, thành phần nào dùng để làm điều kiện chuyển đổi giữa các State?<br>
a) Transitions b) Layers c) Parameters d) Animation Clips</li>
<li>Công cụ nào trong Animator giúp trộn mượt mà nhiều animation (như rẽ trái, thẳng, rẽ phải) dựa trên một Parameter (ví dụ: kiểu Float)?<br>
a) State Machine b) Sub-State Machine c) Blend Tree d) Animation Layer</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chiếu một slide tổng hợp nhanh các chủ đề chính đã học trong 8 buổi vừa qua (có thể kèm hình ảnh minh họa: Rigidbody, Script C#, Class Diagram đơn giản, Animator…).</li>
<li>GV đặt câu hỏi gợi mở: “Chúng ta đã cùng nhau xây dựng khá nhiều thứ cho game đua xe của mình, từ làm xe chạy, va chạm, thêm animation… Các bạn còn nhớ hết các bước và khái niệm không?”</li>
<li>GV chia sẻ: “Việc ôn tập và kiểm tra lại kiến thức là rất quan trọng để đảm bảo chúng ta nắm vững nền tảng trước khi đi tiếp hoặc hoàn thiện sản phẩm. Hôm nay sẽ là cơ hội để các bạn hệ thống lại, đặt câu hỏi và xem dự án của mình đang ở đâu.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo tâm thế ôn tập, nhắc lại phạm vi kiến thức đã học, nhấn mạnh tầm quan trọng của việc củng cố và rà soát.</li>
</ul>
<p><strong>2. Explore (Khám phá - 30 phút)</strong></p>
<ul>
<li><strong>Hoạt động 1: Kiểm tra Lý thuyết (15 phút)</strong>
<ul>
<li>GV phát bài kiểm tra lý thuyết ngắn (Quiz) cho HS.</li>
<li>HS tự làm bài trong khoảng thời gian quy định. <em>Mục đích chính không phải là chấm điểm khắt khe mà là để HS tự đánh giá mức độ hiểu bài.</em></li>
</ul>
</li>
<li><strong>Hoạt động 2: Rà soát Dự án Cá nhân (15 phút)</strong>
<ul>
<li>Sau khi làm quiz, HS mở lại dự án “Karting Adventure” của mình trên máy tính.</li>
<li>GV yêu cầu HS tự rà soát lại dự án dựa trên các câu hỏi định hướng:
<ul>
<li>Xe của bạn đã điều khiển được chưa? Cảm giác lái đã ổn chưa?</li>
<li>Hệ thống vật lý (va chạm với địa hình, chướng ngại vật) hoạt động đúng như mong đợi chưa?</li>
<li>Bạn đã áp dụng Class/Object để tổ chức code chưa (ví dụ: có Class <code>Obstacle</code>, <code>GameManager</code> không)?</li>
<li>Animation của xe đã hoạt động chưa? Có mượt mà không (đã dùng Blend Tree chưa)?</li>
<li>Có tính năng nào bạn muốn thêm/sửa nhưng chưa biết cách làm không?</li>
<li>Có lỗi nào (bug) bạn gặp phải mà chưa sửa được không?</li>
</ul>
</li>
<li>HS tự ghi chú lại những điểm đã làm được, những điểm còn vướng mắc hoặc lỗi trong dự án của mình. Có thể dùng giấy bút hoặc file note.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS tự đánh giá kiến thức qua quiz, đồng thời tự kiểm tra lại tiến độ và các vấn đề thực tế trong dự án đang làm.</li>
</ul>
<p><strong>3. Explain (Giải thích - 30 phút)</strong></p>
<ul>
<li><strong>Hoạt động 1: Chữa bài Quiz và Giải đáp (15 phút)</strong>
<ul>
<li>GV chữa bài quiz cùng cả lớp. Đọc từng câu hỏi, nêu đáp án đúng và giải thích ngắn gọn tại sao đáp án đó đúng, nhắc lại các khái niệm liên quan.</li>
<li>Trong quá trình chữa bài, khuyến khích HS đặt câu hỏi nếu có phần nào chưa hiểu rõ về khái niệm trong quiz.</li>
</ul>
</li>
<li><strong>Hoạt động 2: Tổng hợp Thắc mắc và Khó khăn từ Dự án (15 phút)</strong>
<ul>
<li>GV mời HS chia sẻ những khó khăn, vướng mắc hoặc lỗi mà họ đã ghi chú lại trong quá trình rà soát dự án (Explore - Hoạt động 2).</li>
<li>GV ghi lại các vấn đề chung lên bảng trắng hoặc công cụ ghi chú. Các vấn đề có thể bao gồm:
<ul>
<li>Kỹ thuật: “Làm sao để xe nhảy?”, “Code lấy điểm từ GameManager bị lỗi”, “Blend Tree không mượt như ý”…</li>
<li>Khái niệm: “Vẫn chưa hiểu rõ về static”, “Khi nào nên dùng Update, khi nào dùng FixedUpdate?”…</li>
<li>Lỗi cụ thể: “Xe bị kẹt ở địa hình”, “Animation không chạy đúng tên Parameter”…</li>
</ul>
</li>
<li>GV và cả lớp cùng nhau thảo luận, đưa ra gợi ý giải pháp hoặc giải thích lại các khái niệm liên quan đến các vấn đề được nêu ra. GV đóng vai trò điều phối và cung cấp kiến thức chuyên môn. <em>Ưu tiên giải quyết các vấn đề chung, các vấn đề cá biệt có thể hỗ trợ riêng sau.</em></li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Củng cố kiến thức qua việc chữa bài quiz, tạo không gian an toàn để HS nêu vấn đề, giải đáp các thắc mắc chung và củng cố hiểu biết về các khái niệm/kỹ thuật.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 20 phút)</strong></p>
<ul>
<li><strong>Hoạt động: Lập Kế hoạch Hoàn thiện Dự án (Cá nhân &amp; Chia sẻ)</strong>
<ul>
<li>Dựa trên việc rà soát dự án và các giải đáp vừa nhận được, GV yêu cầu HS dành 10 phút để tự lập một kế hoạch ngắn gọn (2-3 gạch đầu dòng) về những việc cần làm tiếp theo để hoàn thiện hoặc cải thiện dự án “Karting Adventure” của mình trong các buổi tới. Ví dụ:
<ul>
<li>“Sửa lỗi xe bị kẹt ở dốc A.”</li>
<li>“Tinh chỉnh lại thông số Drag/Angular Drag để xe bớt trượt.”</li>
<li>“Thêm âm thanh khi va chạm.”</li>
<li>“Tìm hiểu cách làm menu đơn giản.”</li>
</ul>
</li>
<li>Sau 10 phút, GV mời một vài HS chia sẻ kế hoạch của mình. Việc này giúp các bạn khác có thêm ý tưởng và cũng để GV nắm được định hướng của HS.</li>
<li>GV có thể góp ý nhanh về tính khả thi hoặc gợi ý thêm tài nguyên/hướng dẫn cho các kế hoạch đó.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giúp HS chuyển từ việc xác định vấn đề sang việc lên kế hoạch hành động cụ thể, định hướng cho các buổi học cuối cùng của học phần.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Tự đánh giá và Phản hồi:</strong> GV yêu cầu HS tự đánh giá lại mức độ tự tin của mình với các chủ đề chính đã học (ví dụ: thang điểm 1-5 cho Vật lý, Scripting, Class, Animation). Có thể dùng phiếu nhỏ hoặc công cụ online.</li>
<li><strong>Câu hỏi cuối buổi:</strong> “Sau buổi hôm nay, bạn cảm thấy rõ ràng hơn về vấn đề nào nhất trong dự án của mình?” hoặc “Bước tiếp theo quan trọng nhất bạn sẽ làm cho dự án là gì?”</li>
<li><strong>Quan sát:</strong> Mức độ tham gia thảo luận, chất lượng câu hỏi và các vấn đề được nêu ra, tính cụ thể của kế hoạch hoàn thiện dự án. Kết quả quiz (tham khảo).</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá tổng quan mức độ nắm bắt kiến thức của cả lớp, khả năng xác định vấn đề và lập kế hoạch của HS. Thu thập phản hồi để điều chỉnh nội dung các buổi cuối nếu cần.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tổng kết lại các kiến thức trọng tâm đã ôn tập.</li>
<li>Khẳng định rằng việc gặp khó khăn và lỗi là bình thường trong quá trình làm game. Quan trọng là xác định được vấn đề và tìm cách giải quyết.</li>
<li>Động viên HS tiếp tục thực hiện kế hoạch hoàn thiện dự án của mình.</li>
<li>Giới thiệu các buổi học tiếp theo sẽ tập trung vào việc hỗ trợ HS hoàn thiện dự án, tối ưu hóa và chuẩn bị cho buổi tổng kết.</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.10-case-study---tối-ưu-hóa-và-hoàn-thiện-game">Giáo án Buổi học 2.1.10: Case Study - Tối ưu hóa và Hoàn thiện Game</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành buổi 2.1.9 và đang trong quá trình hoàn thiện dự án.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS thực hành quy trình Playtesting tập trung để tìm kiếm và ghi nhận lỗi (bugs) hoặc các điểm chưa hợp lý trong gameplay.</li>
<li>HS làm quen và sử dụng được cửa sổ Profiler ở mức cơ bản để xác định các khu vực có thể gây ảnh hưởng đến hiệu suất (CPU Usage).</li>
<li>HS áp dụng được một số kỹ thuật tối ưu hóa đơn giản (ví dụ: kiểm tra <code>GetComponent</code> trong <code>Update</code>, sử dụng <code>CompareTag</code>).</li>
<li>HS thêm được các hiệu ứng âm thanh cơ bản (Sound Effects - SFX) vào game sử dụng <code>AudioSource</code> và <code>AudioClip</code>.</li>
<li>HS cải thiện được giao diện người dùng (UI) cơ bản đã có hoặc thêm các yếu tố UI mới (ví dụ: nút bấm đơn giản, thông báo).</li>
<li>HS thực hành kỹ năng sửa lỗi (Debugging) dựa trên các vấn đề đã xác định trong dự án của mình.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Adventure của HS (đang trong giai đoạn hoàn thiện).</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Tối ưu hóa cơ bản, Thêm Âm thanh và Hoàn thiện UI” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>Một số file âm thanh (Audio Clips - .wav, .mp3, .ogg) cơ bản phù hợp với game đua xe (tiếng động cơ, va chạm, ăn vật phẩm…) để HS sử dụng. Có thể chuẩn bị sẵn trong một thư mục dùng chung hoặc hướng dẫn HS tìm trên các trang tài nguyên miễn phí.</li>
<li>(Tùy chọn) Bảng hoặc công cụ theo dõi lỗi (Bug Tracking) đơn giản để HS ghi lại lỗi tìm được.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Tối ưu hóa cơ bản, Thêm Âm thanh và Hoàn thiện UI"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Game của bạn đã có các chức năng chính. Bây giờ là lúc “đánh bóng” sản phẩm: tìm và sửa lỗi, làm cho game chạy mượt hơn, thêm âm thanh cho sinh động và cải thiện giao diện người dùng.</li>
<li><strong>Phần 1: Playtesting và Tìm lỗi:</strong>
<ul>
<li><strong>Mục đích:</strong> Chơi game một cách có chủ đích để tìm ra lỗi hoặc những điểm chưa hợp lý.</li>
<li><strong>Cách thực hiện:</strong>
<ul>
<li>Chơi nhiều lần, thử các tình huống khác nhau (lái nhanh, chậm, đâm vào mọi thứ, đi lùi…).</li>
<li>Cố gắng “phá game”: Làm những điều bất thường xem có gây lỗi không.</li>
<li>Nhờ bạn bè chơi thử và quan sát họ.</li>
<li><strong>Ghi lại lỗi:</strong> Mô tả rõ ràng lỗi là gì, xảy ra khi nào, các bước để tái hiện lỗi. (Ví dụ: “Lỗi: Xe bị kẹt khi lùi vào góc tường gần vạch xuất phát. Bước tái hiện: 1. Lùi xe. 2. Rẽ bánh sau vào góc tường. 3. Xe không di chuyển được nữa.”)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Phần 2: Tối ưu hóa cơ bản với Profiler:</strong>
<ul>
<li><strong>Profiler là gì?</strong> Công cụ của Unity giúp phân tích hiệu suất game (CPU, GPU, Bộ nhớ…).</li>
<li><strong>Mở Profiler:</strong> <code>Window</code> -&gt; <code>Analysis</code> -&gt; <code>Profiler</code>.</li>
<li><strong>Sử dụng cơ bản:</strong>
<ul>
<li>Nhấn nút “Record” trong cửa sổ Profiler.</li>
<li>Nhấn Play trong Unity Editor. Chơi game một lúc.</li>
<li>Nhấn Stop trong Editor, sau đó dừng Record trong Profiler.</li>
<li>Quan sát biểu đồ “CPU Usage”. Tìm những “gai” (spikes) cao bất thường, hoặc những mục chiếm nhiều thời gian xử lý nhất trong bảng phân cấp bên dưới.</li>
<li><em>Hình ảnh minh họa cửa sổ Profiler và mục CPU Usage.</em></li>
</ul>
</li>
<li><strong>Kỹ thuật tối ưu đơn giản:</strong>
<ul>
<li><strong>Tránh <code>GetComponent</code> trong <code>Update</code>/<code>FixedUpdate</code>:</strong> Lệnh này tốn hiệu năng. Thay vào đó, hãy gọi <code>GetComponent</code> một lần trong <code>Start()</code> và lưu kết quả vào một biến private để dùng lại. (Chúng ta đã làm điều này với Rigidbody, Animator).</li>
<li><strong>Sử dụng <code>CompareTag</code> thay vì so sánh chuỗi <code>tag</code>:</strong> Khi kiểm tra va chạm, thay vì viết <code>if (collisionInfo.gameObject.tag == "Player")</code>, hãy dùng <code>if (collisionInfo.gameObject.CompareTag("Player"))</code>. <code>CompareTag</code> hiệu quả hơn. (Bạn cần đặt Tag cho GameObject trước trong Inspector).</li>
<li><strong>(Nâng cao) Collision Layer Matrix:</strong> <code>Edit</code> -&gt; <code>Project Settings</code> -&gt; <code>Physics</code> (hoặc <code>Physics 2D</code>). Bảng này cho phép bạn bỏ chọn tương tác giữa các Layer không cần thiết (ví dụ: UI không cần va chạm với Xe), giúp giảm tính toán vật lý.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Phần 3: Thêm Hiệu ứng Âm thanh (SFX):</strong>
<ul>
<li><strong>Chuẩn bị:</strong> Import các file âm thanh (Audio Clips) vào thư mục Assets (ví dụ: thư mục “Audio/SFX”).</li>
<li><strong>AudioSource Component:</strong> Đây là component phát âm thanh trong không gian 3D.
<ul>
<li>Chọn GameObject bạn muốn phát ra âm thanh (ví dụ: xe Kart để phát tiếng động cơ, chướng ngại vật để phát tiếng va chạm).</li>
<li>Thêm component <code>AudioSource</code> vào GameObject đó.</li>
</ul>
</li>
<li><strong>AudioClip:</strong> Là file âm thanh bạn đã import.</li>
<li><strong>Cách phát âm thanh:</strong>
<ul>
<li><strong>Phát lặp lại (tiếng động cơ):</strong>
<ul>
<li>Trong Inspector của AudioSource trên xe Kart, kéo thả AudioClip tiếng động cơ vào ô <code>AudioClip</code>.</li>
<li>Tick vào ô <code>Loop</code>.</li>
<li>Tick vào ô <code>Play On Awake</code> (nếu muốn tiếng động cơ bắt đầu ngay khi game chạy).</li>
<li>Điều chỉnh <code>Volume</code> (âm lượng), <code>Pitch</code> (cao độ - có thể thay đổi theo tốc độ xe bằng code).</li>
</ul>
</li>
<li><strong>Phát một lần khi có sự kiện (va chạm, ăn vật phẩm):</strong>
<ul>
<li>Trong script xử lý sự kiện (ví dụ: <code>OnCollisionEnter</code> trong <code>KartController</code> hoặc <code>HitObstacle</code> trong <code>Obstacle</code>):
<ol>
<li>Thêm biến <code>public AudioClip collisionSound;</code> ở đầu script.</li>
<li>Trong Inspector của GameObject chứa script đó, kéo thả AudioClip tiếng va chạm vào ô <code>Collision Sound</code>.</li>
<li>Thêm biến <code>private AudioSource audioSource;</code> và lấy tham chiếu trong <code>Start()</code>: <code>audioSource = GetComponent&lt;AudioSource&gt;();</code> (Đảm bảo GameObject đó <em>cũng</em> có component AudioSource).</li>
<li>Trong hàm xử lý sự kiện (ví dụ: <code>OnCollisionEnter</code>), gọi lệnh: <code>if (audioSource != null &amp;&amp; collisionSound != null) audioSource.PlayOneShot(collisionSound);</code></li>
</ol>
<ul>
<li><code>PlayOneShot()</code>: Phát một AudioClip một lần, không làm dừng âm thanh đang phát (như tiếng động cơ).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><em>Hình ảnh minh họa AudioSource component và code PlayOneShot.</em></li>
</ul>
</li>
<li><strong>Phần 4: Hoàn thiện Giao diện Người dùng (UI):</strong>
<ul>
<li><strong>Cải thiện UI có sẵn:</strong>
<ul>
<li>Điều chỉnh vị trí, kích thước, màu sắc, font chữ của Text hiển thị điểm/thời gian cho dễ nhìn.</li>
<li>Sử dụng Anchors và Pivots trong Rect Transform để UI co dãn tốt trên các màn hình khác nhau.</li>
</ul>
</li>
<li><strong>Thêm UI mới:</strong>
<ul>
<li><strong>Nút bấm (Button):</strong> <code>GameObject</code> -&gt; <code>UI</code> -&gt; <code>Button</code>.
<ul>
<li>Chỉnh sửa Text trên nút.</li>
<li>Trong Inspector của Button, tìm mục <code>On Click ()</code>. Nhấn dấu “+”.</li>
<li>Kéo GameObject chứa script có hàm bạn muốn gọi vào ô “None (Object)”.</li>
<li>Chọn hàm <code>public</code> từ danh sách thả xuống (ví dụ: gọi hàm <code>RestartGame()</code> trong <code>GameManager</code>).</li>
</ul>
</li>
<li><strong>Hình ảnh (Image):</strong> <code>GameObject</code> -&gt; <code>UI</code> -&gt; <code>Image</code>. Dùng để hiển thị logo, biểu tượng… Kéo Sprite vào ô <code>Source Image</code>.</li>
</ul>
</li>
<li><em>Hình ảnh minh họa cách thêm sự kiện OnClick cho Button.</em></li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV bắt đầu bằng việc chơi thử một phiên bản game “Karting Adventure” (có thể là của GV hoặc một HS) và cố tình tạo ra lỗi hoặc chỉ ra những điểm chưa mượt mà: “Ồ, xe bị kẹt ở đây!”, “Sao điểm số lại nhảy lung tung thế này?”, “Giá mà có tiếng động khi va chạm thì hay hơn nhỉ?”.</li>
<li>GV đặt câu hỏi: “Game của chúng ta đã chạy được, nhưng làm sao để nó trở nên <em>chuyên nghiệp</em> hơn, ít lỗi hơn, chạy mượt hơn và có hồn hơn?”</li>
<li>Giới thiệu mục tiêu: “Hôm nay, chúng ta sẽ đóng vai trò như những người kiểm thử (Tester) và kỹ sư tối ưu hóa. Chúng ta sẽ săn lùng lỗi, tìm cách làm game chạy nhanh hơn, thêm ‘gia vị’ âm thanh và làm đẹp giao diện.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo nhận thức về tầm quan trọng của việc sửa lỗi, tối ưu hóa và hoàn thiện chi tiết (“đánh bóng” game), tạo hứng thú cho các hoạt động thực hành.</li>
</ul>
<p><strong>2. Explore (Khám phá - 50 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thực hành theo Module):</strong> Buổi này chủ yếu là thực hành dựa trên tài liệu và hỗ trợ của GV. Chia thời gian cho các phần:
<ul>
<li><strong>Module 1: Playtesting &amp; Bug Hunting (10 phút):</strong>
<ul>
<li>HS tập trung chơi game của mình, cố gắng tìm lỗi và ghi chú lại theo hướng dẫn trong tài liệu.</li>
</ul>
</li>
<li><strong>Module 2: Profiler Cơ bản (10 phút):</strong>
<ul>
<li>HS mở Profiler, Record và chơi game một đoạn ngắn. Quan sát biểu đồ CPU Usage, thử xác định xem có điểm nào bất thường không (không cần đi sâu vào phân tích chi tiết).</li>
</ul>
</li>
<li><strong>Module 3: Thêm Âm thanh (15 phút):</strong>
<ul>
<li>HS import Audio Clips (GV cung cấp hoặc tự tìm).</li>
<li>Thêm AudioSource vào xe/chướng ngại vật.</li>
<li>Thiết lập âm thanh lặp lại (động cơ) hoặc thêm code <code>PlayOneShot</code> cho âm thanh sự kiện (va chạm). Playtest để nghe thử.</li>
</ul>
</li>
<li><strong>Module 4: Hoàn thiện UI (15 phút):</strong>
<ul>
<li>HS chỉnh sửa UI Text điểm số hiện có cho đẹp hơn.</li>
<li>(Tùy chọn nâng cao) Thử thêm một Button đơn giản (ví dụ: nút “Quit” gọi <code>Application.Quit()</code> hoặc nút “Restart” gọi hàm tải lại Scene).</li>
</ul>
</li>
<li><strong>Trong suốt quá trình:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn</strong> tương ứng với từng module.</li>
<li>GV di chuyển liên tục, hỗ trợ HS gặp khó khăn với Profiler, code âm thanh, thiết lập UI, hoặc sửa lỗi HS tìm được.</li>
<li>Khuyến khích HS áp dụng các kỹ thuật tối ưu đơn giản (kiểm tra <code>GetComponent</code> trong <code>Update</code>, dùng <code>CompareTag</code>) nếu phù hợp với lỗi hoặc mã nguồn của họ.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp các kỹ năng playtesting, sử dụng Profiler cơ bản, thêm âm thanh, cải thiện UI và áp dụng kiến thức để sửa lỗi/tối ưu hóa dự án của chính mình.</li>
</ul>
<p><strong>3. Explain (Giải thích - 20 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thảo luận và Chia sẻ Kinh nghiệm):</strong>
<ul>
<li>GV tập hợp lớp lại. Thay vì giảng lý thuyết mới, GV tập trung vào việc thảo luận kinh nghiệm thực hành của HS:
<ul>
<li><strong>Bug Sharing:</strong> “Có bạn nào tìm được lỗi nào thú vị hoặc khó sửa không? Bạn đã sửa nó như thế nào?” -&gt; GV và lớp cùng phân tích nguyên nhân và cách sửa một vài lỗi điển hình.</li>
<li><strong>Profiler Insights:</strong> “Có ai thấy điểm nào bất thường trong Profiler không? Mặc dù chúng ta chưa phân tích sâu, nhưng việc quan sát này giúp chúng ta ý thức hơn về hiệu suất.” -&gt; GV nhắc lại nhanh các mẹo tối ưu đơn giản.</li>
<li><strong>Audio Challenges:</strong> “Việc thêm âm thanh có khó khăn gì không? Các bạn đã dùng <code>PlayOneShot</code> ở đâu?” -&gt; Chia sẻ cách dùng <code>PlayOneShot</code> hiệu quả.</li>
<li><strong>UI Tips:</strong> “Có ai gặp khó khăn khi căn chỉnh UI không?” -&gt; GV có thể demo nhanh lại cách dùng Anchors. Cách kết nối Button với hàm trong script.</li>
</ul>
</li>
<li>GV nhấn mạnh lại quy trình làm việc: <strong>Test -&gt; Tìm lỗi/Điểm yếu -&gt; Sửa/Cải thiện -&gt; Test lại.</strong></li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo diễn đàn để HS chia sẻ kinh nghiệm, học hỏi từ lỗi và cách giải quyết của nhau, củng cố lại các kỹ thuật đã thực hành và quy trình làm việc hiệu quả.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Làm việc theo Cặp - Peer Debugging/Feedback):</strong>
<ul>
<li>GV ghép cặp HS.</li>
<li>Trong 10 phút, HS đổi máy cho nhau, chơi thử game của bạn và đưa ra phản hồi ngắn gọn:
<ul>
<li>Tìm thêm lỗi (nếu có).</li>
<li>Góp ý về cảm giác lái, độ khó, âm thanh, UI.</li>
<li>Chỉ ra điểm họ thích nhất.</li>
</ul>
</li>
<li>Việc này giúp HS có cái nhìn khách quan về sản phẩm của mình và thực hành kỹ năng đưa/nhận phản hồi.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS nhận được phản hồi từ người khác, có thêm góc nhìn để cải thiện game, thực hành kỹ năng giao tiếp và đánh giá sản phẩm.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Tổng kết cá nhân:</strong> Yêu cầu HS ghi lại nhanh 1-2 điều quan trọng nhất họ đã làm được hoặc sửa được cho dự án trong buổi học hôm nay.</li>
<li><strong>Chia sẻ nhanh:</strong> Mời vài HS chia sẻ một lỗi họ đã sửa thành công hoặc một cải tiến (âm thanh/UI) họ thấy hài lòng.</li>
<li><strong>Câu hỏi kiểm tra nhanh:</strong>
<ol>
<li>Công cụ nào giúp phân tích hiệu suất CPU/GPU của game? (Profiler)</li>
<li>Lệnh nào dùng để phát một âm thanh ngắn một lần mà không dừng âm thanh khác? (<code>PlayOneShot</code>)</li>
<li>Tại sao nên tránh gọi <code>GetComponent</code> liên tục trong <code>Update</code>? (Tốn hiệu năng)</li>
<li>Mục <code>On Click ()</code> trong Inspector của Button dùng để làm gì? (Gán hàm sẽ được gọi khi nhấn nút).</li>
</ol>
</li>
<li><strong>Quan sát:</strong> Mức độ tham gia của HS trong các hoạt động thực hành, khả năng xác định và sửa lỗi (qua chia sẻ), mức độ hoàn thiện của dự án so với buổi trước.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng áp dụng các kỹ thuật tối ưu, thêm âm thanh/UI và sửa lỗi vào dự án thực tế. Kiểm tra lại kiến thức về các công cụ và lệnh liên quan.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV khen ngợi sự nỗ lực của HS trong việc “đánh bóng” game.</li>
<li>Nhấn mạnh rằng quá trình sửa lỗi và tối ưu là một phần không thể thiếu và liên tục trong phát triển game chuyên nghiệp.</li>
<li>Giới thiệu buổi học tiếp theo: “Chúng ta đã gần hoàn thành! Buổi tới sẽ là cơ hội cuối cùng để các bạn hoàn thiện các chi tiết, chuẩn bị ‘đóng gói’ sản phẩm và sẵn sàng cho buổi tổng kết dự án.”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.11-case-study---hoàn-thiện-game-và-chuẩn-bị-trình-bày">Giáo án Buổi học 2.1.11: Case Study - Hoàn thiện Game và Chuẩn bị Trình bày</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đang ở giai đoạn cuối hoàn thiện dự án Karting Adventure.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS rà soát và hoàn thiện các chi tiết nhỏ còn lại trong game (ví dụ: tinh chỉnh giá trị, sửa lỗi vặt, kiểm tra luồng chơi).</li>
<li>HS thực hiện các bước cơ bản để Build dự án thành một ứng dụng chạy được (ví dụ: bản build cho Windows/Mac hoặc WebGL).</li>
<li>HS chuẩn bị được nội dung và cấu trúc cho bài trình bày dự án cuối khóa.</li>
<li>HS thực hành (tùy chọn) việc trình bày thử trong nhóm nhỏ hoặc trước lớp.</li>
<li>HS thể hiện sự sẵn sàng và tự tin để giới thiệu sản phẩm game của mình.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án Karting Adventure của HS (gần hoàn thiện).</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Hoàn thiện Game và Hướng dẫn Build &amp; Chuẩn bị Trình bày” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Mẫu slide trình bày đơn giản hoặc dàn ý gợi ý cho HS.</li>
<li>(Tùy chọn) Thiết bị ngoại vi nếu cần Build cho nền tảng cụ thể (ví dụ: thiết bị Android/iOS nếu muốn build mobile).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Hoàn thiện Game và Hướng dẫn Build &amp; Chuẩn bị Trình bày"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Chúc mừng bạn đã gần hoàn thành dự án Karting Adventure! Buổi học này tập trung vào việc kiểm tra lại mọi thứ lần cuối, “đóng gói” game thành sản phẩm chạy được và chuẩn bị để giới thiệu thành quả của bạn.</li>
<li><strong>Phần 1: Rà soát và Hoàn thiện Lần cuối (Checklist):</strong>
<ul>
<li><strong>Luồng chơi (Gameplay Loop):</strong> Chơi game từ đầu đến cuối (nếu có nhiều màn hoặc mục tiêu). Có điểm bắt đầu, kết thúc rõ ràng không? Có bị kẹt ở đâu không?</li>
<li><strong>Điều khiển &amp; Cảm giác lái:</strong> Đã thực sự ưng ý chưa? Có cần tinh chỉnh lại tốc độ, lực rẽ, drag lần cuối không?</li>
<li><strong>Vật lý &amp; Va chạm:</strong> Các va chạm có hợp lý không? Có lỗi vật lý lạ (xe bay, kẹt…) không?</li>
<li><strong>Tính năng chính:</strong> Các tính năng bạn đã thêm (điểm số, chướng ngại vật, power-up…) hoạt động đúng không?</li>
<li><strong>Animation:</strong> Các hoạt ảnh có mượt mà và khớp với hành động không?</li>
<li><strong>Âm thanh (SFX/Music):</strong> Âm thanh có phát đúng lúc? Âm lượng có phù hợp không? (Có thể thêm nhạc nền nếu muốn).</li>
<li><strong>Giao diện người dùng (UI):</strong> Thông tin hiển thị có chính xác, dễ nhìn không? Các nút bấm hoạt động đúng không?</li>
<li><strong>Lỗi vặt:</strong> Kiểm tra lại danh sách lỗi bạn đã ghi nhận, đảm bảo đã sửa hết các lỗi quan trọng.</li>
<li><strong>Dọn dẹp Project (Tùy chọn):</strong> Xóa các asset, script không dùng đến trong cửa sổ Project để giữ dự án gọn gàng.</li>
</ul>
</li>
<li><strong>Phần 2: Build Game:</strong>
<ul>
<li><strong>Build là gì?</strong> Là quá trình đóng gói dự án Unity thành một ứng dụng độc lập mà người khác có thể chạy mà không cần cài Unity Editor.</li>
<li><strong>Mở Build Settings:</strong> <code>File</code> -&gt; <code>Build Settings...</code>.</li>
<li><strong>Chọn Platform (Nền tảng):</strong>
<ul>
<li>Phổ biến nhất: <code>PC, Mac &amp; Linux Standalone</code>. Chọn Target Platform là <code>Windows</code> hoặc <code>macOS</code> tùy hệ điều hành bạn muốn build cho.</li>
<li>Nếu muốn chạy trên web: Chọn <code>WebGL</code>. (Quá trình build WebGL có thể lâu hơn và yêu cầu một số thiết lập server đơn giản để chạy).</li>
<li>Nhấn nút “Switch Platform” nếu nền tảng bạn chọn chưa phải là nền tảng active (có logo Unity bên cạnh). Quá trình này có thể mất ít phút.</li>
</ul>
</li>
<li><strong>Thêm Scene vào Build:</strong> Đảm bảo Scene chính của game (ví dụ: <code>Karting</code>, <code>Main</code>) đã được kéo thả vào ô “Scenes In Build”. Scene ở vị trí 0 sẽ là scene được load đầu tiên. Nếu có Menu Scene, hãy đặt nó ở vị trí 0.</li>
<li><strong>Nhấn nút “Build”:</strong> Unity sẽ hỏi bạn chọn một thư mục để lưu bản build. <strong>Hãy tạo một thư mục mới riêng</strong> (ví dụ: tên là “Build_Windows”) và chọn thư mục đó. <em>Đừng chọn trực tiếp thư mục Assets hoặc thư mục gốc của Project.</em></li>
<li><strong>Chờ đợi:</strong> Quá trình build có thể mất từ vài phút đến lâu hơn tùy độ phức tạp của dự án và tốc độ máy.</li>
<li><strong>Chạy thử bản Build:</strong> Sau khi build xong, mở thư mục bạn đã chọn, tìm file thực thi (.exe cho Windows, .app cho Mac) và chạy thử để đảm bảo game hoạt động đúng như trong Editor. Đối với WebGL, bạn cần chạy thông qua một server local đơn giản hoặc upload lên host.</li>
<li><em>Hình ảnh minh họa cửa sổ Build Settings, chọn Platform, thêm Scene, nhấn Build.</em></li>
</ul>
</li>
<li><strong>Phần 3: Chuẩn bị Trình bày Dự án:</strong>
<ul>
<li><strong>Mục đích:</strong> Giới thiệu sản phẩm game của bạn, chia sẻ quá trình thực hiện và những gì bạn học được.</li>
<li><strong>Nội dung chính cần có:</strong>
<ul>
<li><strong>Giới thiệu:</strong> Tên game, thể loại, giới thiệu ngắn về game của bạn (nó có gì đặc biệt?).</li>
<li><strong>Demo Gameplay:</strong> Chơi trực tiếp một đoạn game (khoảng 1-2 phút) để thể hiện các tính năng chính và cảm giác chơi. <em>Đây là phần quan trọng nhất!</em></li>
<li><strong>Tính năng nổi bật:</strong> Chỉ ra 1-2 tính năng hoặc khía cạnh kỹ thuật mà bạn tâm đắc nhất hoặc đã dành nhiều công sức để làm (ví dụ: hệ thống vật lý xe, AI đơn giản, hiệu ứng đặc biệt, Blend Tree mượt mà…). Có thể giải thích ngắn gọn cách bạn thực hiện (nếu có thời gian).</li>
<li><strong>Quá trình phát triển:</strong> Chia sẻ ngắn gọn về những khó khăn bạn đã gặp phải và cách bạn vượt qua.</li>
<li><strong>Bài học kinh nghiệm:</strong> Bạn học được điều gì quan trọng nhất qua dự án này?</li>
<li><strong>(Tùy chọn) Hướng phát triển tương lai:</strong> Nếu có thêm thời gian, bạn muốn thêm gì vào game này?</li>
</ul>
</li>
<li><strong>Hình thức:</strong> Có thể dùng slide đơn giản để hỗ trợ (vài slide với tiêu đề, hình ảnh/video ngắn gọn), nhưng tập trung chính vào việc demo game trực tiếp và nói.</li>
<li><strong>Thời lượng:</strong> Chuẩn bị cho khoảng thời gian trình bày được GV thông báo (thường là 5-10 phút mỗi HS/nhóm).</li>
<li><strong>Luyện tập:</strong> Hãy tập nói và demo trước để đảm bảo đúng thời gian và trình bày trôi chảy.</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chiếu hình ảnh logo Unity hoặc một màn hình “Build Successful”. Hỏi: “Sau bao nỗ lực, làm sao để chúng ta có thể chia sẻ game của mình cho bạn bè cùng chơi mà không cần họ phải cài Unity?”</li>
<li>GV tạo không khí hào hứng: “Hôm nay là buổi chúng ta ‘đóng gói’ thành quả của mình! Chúng ta sẽ kiểm tra lại mọi thứ lần cuối, biến dự án Unity thành một game thực thụ có thể chạy độc lập, và chuẩn bị để ‘khoe’ sản phẩm tâm huyết của mình với mọi người!”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo tâm thế hoàn thiện, giới thiệu khái niệm Build và chuẩn bị cho việc trình bày sản phẩm cuối cùng.</li>
</ul>
<p><strong>2. Explore (Khám phá - 45 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thực hành Hoàn thiện và Build):</strong>
<ul>
<li><strong>Module 1: Final Polish (20 phút):</strong>
<ul>
<li>GV yêu cầu HS sử dụng Checklist trong <strong>Tài liệu đọc/hướng dẫn (Phần 1)</strong> để tự rà soát lại dự án lần cuối.</li>
<li>HS tập trung vào việc tinh chỉnh các giá trị nhỏ, sửa các lỗi vặt còn sót lại, kiểm tra luồng chơi tổng thể.</li>
<li>GV đi quanh lớp, hỗ trợ cá nhân giải quyết các vấn đề cuối cùng.</li>
</ul>
</li>
<li><strong>Module 2: Build Game (25 phút):</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn (Phần 2)</strong> về cách Build game.</li>
<li>GV demo nhanh các bước chính trên máy chiếu: Mở Build Settings, chọn Platform (ví dụ: PC Standalone), thêm Scene, nhấn Build và chọn thư mục lưu.</li>
<li>HS thực hiện Build dự án của mình theo hướng dẫn. <em>Lưu ý HS chọn đúng Platform và tạo thư mục lưu riêng.</em></li>
<li>Trong lúc chờ build, HS có thể bắt đầu xem Phần 3 của tài liệu (Chuẩn bị trình bày).</li>
<li>Sau khi build xong, HS chạy thử bản build để kiểm tra.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giải đáp thắc mắc về Checklist hoàn thiện.</li>
<li>Hỗ trợ các vấn đề phát sinh trong quá trình Build (lỗi build, chọn sai platform, quên thêm scene…).</li>
<li>Giúp HS chạy thử và kiểm tra bản build.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành rà soát và hoàn thiện chi tiết cuối cùng, thực hiện thành công việc Build dự án thành ứng dụng chạy được.</li>
</ul>
<p><strong>3. Explain (Giải thích - 20 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Hướng dẫn Chuẩn bị Trình bày):</strong>
<ul>
<li>GV tập hợp lớp lại. Chúc mừng HS đã có bản build đầu tiên!</li>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn (Phần 3)</strong> về cách chuẩn bị bài trình bày.</li>
<li>GV nhấn mạnh các thành phần quan trọng cần có trong bài trình bày (Giới thiệu, Demo, Tính năng nổi bật, Khó khăn/Giải pháp, Bài học).</li>
<li>GV đưa ra các lời khuyên:
<ul>
<li><strong>Tập trung vào Demo:</strong> Phần chơi thử trực tiếp là hấp dẫn nhất.</li>
<li><strong>Nói về Quá trình:</strong> Chia sẻ khó khăn và cách vượt qua thể hiện sự nỗ lực và học hỏi.</li>
<li><strong>Ngắn gọn, súc tích:</strong> Tuân thủ thời gian cho phép.</li>
<li><strong>Chuẩn bị kỹ thuật:</strong> Đảm bảo bản build chạy tốt, chuẩn bị sẵn file trình chiếu (nếu có).</li>
<li><strong>Luyện tập:</strong> Tập nói trước giúp tự tin và trôi chảy hơn.</li>
</ul>
</li>
<li>GV có thể chiếu một dàn ý mẫu hoặc slide mẫu đơn giản.</li>
<li>Trả lời các câu hỏi của HS về việc chuẩn bị trình bày.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Cung cấp cấu trúc và hướng dẫn rõ ràng để HS chuẩn bị hiệu quả cho bài trình bày cuối khóa, giảm bớt sự bỡ ngỡ hoặc lo lắng.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Lập Dàn ý và Chuẩn bị Demo):</strong>
<ul>
<li>HS dành thời gian này để bắt đầu chuẩn bị cho bài trình bày của mình:
<ul>
<li>Gạch đầu dòng các ý chính sẽ nói theo cấu trúc được gợi ý.</li>
<li>Suy nghĩ xem sẽ demo đoạn nào trong game để thể hiện rõ nhất các tính năng đã làm.</li>
<li>Chuẩn bị sẵn bản build để demo.</li>
<li>(Tùy chọn) Tạo nhanh vài slide đơn giản nếu muốn.</li>
</ul>
</li>
<li>GV đi quanh lớp, xem qua dàn ý của HS, góp ý và trả lời các câu hỏi cụ thể về nội dung trình bày.</li>
<li>(Tùy chọn nếu có thời gian) Cho HS bắt cặp và trình bày thử nhanh (1-2 phút) phần demo cho bạn nghe và nhận xét.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS bắt tay vào việc chuẩn bị cụ thể cho bài trình bày, xác định nội dung demo và cấu trúc bài nói.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Check sự sẵn sàng:</strong> GV hỏi nhanh cả lớp: “Ai đã build được game thành công?”, “Ai đã có dàn ý cơ bản cho bài trình bày?”</li>
<li><strong>Nhắc nhở:</strong> GV nhắc lại thời gian, địa điểm và yêu cầu cụ thể cho buổi trình bày tổng kết dự án. Khuyến khích HS hoàn thiện việc chuẩn bị ở nhà nếu cần.</li>
<li><strong>Động viên:</strong> GV bày tỏ sự mong đợi được xem các sản phẩm game hoàn chỉnh và nghe chia sẻ của HS trong buổi tổng kết.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Kiểm tra mức độ sẵn sàng về kỹ thuật (có bản build) và nội dung (có dàn ý) cho buổi trình bày. Tạo sự tự tin và động viên HS.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV chúc mừng HS đã hoàn thành các bước cuối cùng để hoàn thiện game và chuẩn bị cho buổi trình bày.</li>
<li>Nhấn mạnh đây là cơ hội để tự hào về sản phẩm mình đã tạo ra và chia sẻ hành trình học hỏi.</li>
<li>Hẹn gặp lại trong buổi Tổng kết Dự án.</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-2.1.12-tổng-kết-dự-án-và-trình-bày">Giáo án Buổi học 2.1.12: Tổng Kết Dự Án và Trình Bày</h3>
<p><strong>Học phần:</strong> 2.1 - Tương tác vật lý 3D<br>
<strong>Dự án:</strong> Karting Adventure<br>
<strong>Thời lượng:</strong> 100 phút (Có thể cần linh hoạt tùy số lượng học sinh)<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã có kiến thức cơ bản về lập trình C#, đã hoàn thành dự án Karting Adventure và chuẩn bị bài trình bày.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS trình bày được sản phẩm game “Karting Adventure” của mình một cách rõ ràng và tự tin trước lớp và giáo viên.</li>
<li>HS demo được các tính năng chính và gameplay của sản phẩm.</li>
<li>HS chia sẻ được về quá trình phát triển, những thách thức đã gặp và cách giải quyết, cũng như những bài học kinh nghiệm rút ra.</li>
<li>HS thực hành kỹ năng lắng nghe, đưa ra và tiếp nhận phản hồi mang tính xây dựng từ bạn bè và giáo viên.</li>
<li>HS tổng kết và nhìn nhận lại được những kiến thức, kỹ năng đã học được trong suốt học phần.</li>
<li>Tạo không khí tổng kết tích cực, ghi nhận nỗ lực và thành quả của tất cả học sinh.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity (dự phòng) và có các bản build game của HS (hoặc HS tự chuẩn bị trên máy của mình).</li>
<li>Máy chiếu và máy tính cho GV (để HS kết nối trình bày nếu cần).</li>
<li>Thiết bị kết nối máy tính HS lên máy chiếu (HDMI, cáp chuyển đổi…).</li>
<li>Thứ tự trình bày của HS (chuẩn bị trước).</li>
<li>Đồng hồ bấm giờ để kiểm soát thời gian trình bày của mỗi HS.</li>
<li>Phiếu nhận xét/góp ý đơn giản (tùy chọn, để GV và HS khác ghi chú).</li>
<li>(Tùy chọn) Phần thưởng nhỏ hoặc giấy chứng nhận hoàn thành học phần để tạo động lực.</li>
</ul>
<p><strong>Tiến trình bài học (Cấu trúc đặc thù cho buổi Tổng kết)</strong></p>
<p><strong>1. Khởi động và Thiết lập không khí (5 - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chào mừng HS đến buổi tổng kết học phần.</li>
<li>Tạo không khí thoải mái, tích cực: Chúc mừng tất cả HS đã hoàn thành một chặng đường học tập và phát triển dự án đầy thử thách. Nhấn mạnh đây là cơ hội để chia sẻ thành quả và học hỏi lẫn nhau.</li>
<li>Phổ biến lại quy trình buổi học: Thứ tự trình bày, thời gian dự kiến cho mỗi bạn (ví dụ: 5-7 phút trình bày + 2-3 phút Q&amp;A/Góp ý), cách thức đặt câu hỏi và đưa phản hồi (lịch sự, xây dựng).</li>
<li>Kiểm tra nhanh công tác chuẩn bị kỹ thuật (máy chiếu, kết nối…).</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo tâm thế sẵn sàng, giảm căng thẳng, thống nhất quy trình làm việc cho buổi tổng kết.</li>
</ul>
<p><strong>2. Trình bày Dự án của Học sinh (70 - 80 phút, tùy số lượng HS)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV mời lần lượt từng HS (hoặc nhóm) lên trình bày theo thứ tự đã chuẩn bị.</li>
<li><strong>Trong phần trình bày của mỗi HS (Theo cấu trúc đã chuẩn bị ở buổi 11):</strong>
<ul>
<li><strong>Giới thiệu:</strong> Tên game, giới thiệu ngắn.</li>
<li><strong>Demo Gameplay:</strong> HS mở bản build game và chơi thử trực tiếp, thể hiện các tính năng chính (điều khiển xe, tương tác vật lý, va chạm, animation, điểm số, âm thanh, UI…). <em>GV và các bạn khác tập trung quan sát.</em></li>
<li><strong>Chia sẻ:</strong> HS nói ngắn gọn về tính năng tâm đắc, khó khăn gặp phải và cách giải quyết, bài học kinh nghiệm.</li>
</ul>
</li>
<li><strong>Sau phần trình bày của mỗi HS:</strong>
<ul>
<li><strong>Q&amp;A và Phản hồi (2-3 phút):</strong>
<ul>
<li>GV đặt 1-2 câu hỏi gợi mở hoặc nhận xét mang tính xây dựng (Ví dụ: “Thầy/Cô thấy phần xử lý va chạm của em khá tốt, em đã làm thế nào?”, “Ý tưởng thêm power-up rất hay, em có gặp khó khăn gì khi code không?”, “Phần UI có thể cân nhắc làm cho font chữ to hơn một chút.”).</li>
<li>Mời các HS khác đặt câu hỏi hoặc đưa ra nhận xét ngắn gọn, tích cực (Ví dụ: “Mình thích hiệu ứng âm thanh lúc va chạm của bạn”, “Làm sao bạn làm được hiệu ứng drift đó?”).</li>
<li>GV điều phối để đảm bảo câu hỏi/nhận xét tập trung, lịch sự và đúng thời gian.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Kiểm soát thời gian:</strong> GV sử dụng đồng hồ bấm giờ và nhắc nhở nhẹ nhàng nếu HS trình bày quá dài.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành kỹ năng trình bày sản phẩm kỹ thuật, demo gameplay, chia sẻ kinh nghiệm; HS khác thực hành kỹ năng lắng nghe, phân tích và đưa phản hồi.</li>
</ul>
<p><strong>3. Tổng kết và Phản hồi chung (10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>Sau khi tất cả HS đã trình bày, GV đưa ra nhận xét và phản hồi chung cho cả lớp:
<ul>
<li>Khen ngợi sự nỗ lực, sáng tạo và tiến bộ của HS trong suốt học phần.</li>
<li>Nhấn mạnh những điểm chung tích cực đã thấy qua các bài trình bày (ví dụ: nhiều bạn đã xử lý tốt vật lý xe, áp dụng được Blend Tree, có ý tưởng sáng tạo…).</li>
<li>Nhắc lại các kiến thức và kỹ năng cốt lõi mà học phần đã cung cấp (liên hệ lại với mục tiêu ban đầu và có thể cả UCA objectives nếu phù hợp).</li>
<li>Chia sẻ cảm nghĩ cá nhân của GV về quá trình đồng hành cùng lớp.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Ghi nhận thành quả chung của cả lớp, củng cố lại giá trị học tập của học phần, tạo cảm giác hoàn thành và tự hào.</li>
</ul>
<p><strong>4. Nhìn về Tương lai và Kết thúc (5 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV khuyến khích HS tiếp tục phát triển dự án của mình nếu có hứng thú, hoặc áp dụng các kỹ năng đã học vào các dự án game khác trong tương lai.</li>
<li>Giới thiệu sơ lược về các học phần tiếp theo hoặc các hướng phát triển nâng cao trong Unity (ví dụ: AI cho đối thủ, lập trình mạng, VR/AR…).</li>
<li>Gửi lời cảm ơn đến tất cả HS đã tham gia tích cực.</li>
<li>(Tùy chọn) Trao phần thưởng nhỏ hoặc giấy chứng nhận hoàn thành học phần.</li>
<li>Kết thúc buổi học và học phần.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích học tập liên tục, mở ra định hướng phát triển tương lai, kết thúc học phần một cách ý nghĩa và tích cực.</li>
</ul>
<hr>
<p><strong>Lưu ý cho Giáo viên:</strong></p>
<ul>
<li><strong>Linh hoạt về thời gian:</strong> Thời gian trình bày có thể cần điều chỉnh tùy thuộc vào số lượng HS và chất lượng bài trình bày. Hãy chuẩn bị phương án dự phòng nếu thời gian thiếu hoặc thừa.</li>
<li><strong>Tập trung vào quá trình:</strong> Đánh giá không chỉ dựa trên sản phẩm cuối cùng mà còn dựa trên sự tiến bộ, nỗ lực giải quyết vấn đề và những gì HS học được qua quá trình làm dự án.</li>
<li><strong>Khuyến khích và xây dựng:</strong> Duy trì không khí tích cực, tập trung vào điểm mạnh và những gì HS đã làm được. Phản hồi cần mang tính xây dựng, giúp HS học hỏi thêm.</li>
<li><strong>Ghi chú:</strong> GV nên ghi chú lại những điểm nổi bật hoặc cần cải thiện của từng HS trong quá trình trình bày để có phản hồi cá nhân hóa hơn (nếu cần).</li>
<li><strong>Kỹ thuật:</strong> Đảm bảo mọi thứ về mặt kỹ thuật (máy chiếu, kết nối, bản build…) hoạt động trơn tru để không làm gián đoạn buổi tổng kết.</li>
</ul>

    </div>
  </div>
</body>

</html>
