<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unity - HP4 Chi tiết hóa</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <a href="dashboard.html" style="display:inline-block; margin:10px; font-size:16px; text-decoration:none; background:#eee; padding:5px 10px; border-radius:4px;">⬅ Quay lại Dashboard</a>

  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#giáo-án-chi-tiết-công-nghệ-game-với-unity---hp4">Giáo án chi tiết Công nghệ Game với Unity - HP4</a>
<ul>
<li><a href="#tóm-tắt-học-phần-1.4-quản-lý-tài-nguyên--lập-trình-gameplay-với-hàmphương-thức-c">Tóm tắt học phần 1.4: Quản lý Tài nguyên & Lập trình Gameplay với Hàm/Phương thức C#</a></li>
<li><a href="#mô-tả-dự-án-mẫu-và-cách-triển-khai">Mô tả dự án mẫu và cách triển khai</a>
<ul>
<li><a href="#concept--gameplay">1. Concept & Gameplay:</a></li>
<li><a href="#tài-nguyên-cần-thiết-minh-họa-việc-quản-lý-tài-nguyên">2. Tài nguyên Cần thiết (Minh họa việc Quản lý Tài nguyên):</a></li>
<li><a href="#cấu-trúc-scene--ui">3. Cấu trúc Scene & UI:</a></li>
<li><a href="#cấu-trúc-script-c--ứng-dụng-hàmphương-thức-trọng-tâm-học-phần">4. Cấu trúc Script C# & Ứng dụng Hàm/Phương thức (Trọng tâm Học phần):</a></li>
<li><a href="#trọng-tâm-liên-kết-với-học-phần">5. Trọng tâm Liên kết với Học phần:</a></li>
</ul>
</li>
<li><a href="#giáo-án-chi-tiết">Giáo án chi tiết</a>
<ul>
<li><a href="#giáo-án-buổi-học-1.4.1-giới-thiệu-học-phần-ý-tưởng-game--cấu-trúc-dự-án">Giáo án Buổi học 1.4.1: Giới thiệu Học phần, Ý tưởng Game & Cấu trúc Dự án</a></li>
<li><a href="#giáo-án-buổi-học-1.4.2-quản-lý-âm-thanh-cơ-bản">Giáo án Buổi học 1.4.2: Quản lý Âm thanh Cơ bản</a></li>
<li><a href="#giáo-án-buổi-học-1.4.3-quản-lý-packages-và-assets">Giáo án Buổi học 1.4.3: Quản lý Packages và Assets</a></li>
<li><a href="#giáo-án-buổi-học-1.4.4-chuẩn-bị-tài-nguyên-hình-ảnh--thiết-kế-ui-cơ-bản">Giáo án Buổi học 1.4.4: Chuẩn bị Tài nguyên Hình ảnh & Thiết kế UI Cơ bản</a></li>
<li><a href="#giáo-án-buổi-học-1.4.5-giới-thiệu-hàm-và-phương-thức-c-1">Giáo án Buổi học 1.4.5: Giới thiệu Hàm và Phương thức C# (1)</a></li>
<li><a href="#giáo-án-buổi-học-1.4.6-ứng-dụng-hàm-và-phương-thức-c-2---tham-số-và-giá-trị-trả-về">Giáo án Buổi học 1.4.6: Ứng dụng Hàm và Phương thức C# (2) - Tham số và Giá trị trả về</a></li>
<li><a href="#giáo-án-buổi-học-1.4.7-project---phát-triển-cấp-độ-và-thách-thức-xây-dựng-logic-game-cơ-bản">Giáo án Buổi học 1.4.7: Project - Phát triển Cấp độ và Thách Thức (Xây dựng Logic Game Cơ bản)</a></li>
<li><a href="#giáo-án-buổi-học-1.4.8-project---tối-ưu-hóa-và-kiểm-tra-game">Giáo án Buổi học 1.4.8: Project - Tối Ưu Hóa và Kiểm Tra Game</a></li>
<li><a href="#giáo-án-buổi-học-1.4.9-kiểm-tra-lý-thuyết-tổng-kết-học-phần-1.4">Giáo án Buổi học 1.4.9: Kiểm tra Lý thuyết Tổng kết Học phần 1.4</a></li>
<li><a href="#giáo-án-buổi-học-1.4.10-project---tạo-ra-các-phần-thưởng-ngẫu-nhiên-thêm-yếu-tố-ngẫu-nhiên">Giáo án Buổi học 1.4.10: Project - Tạo ra các Phần thưởng Ngẫu nhiên (Thêm Yếu tố Ngẫu nhiên)</a></li>
<li><a href="#giáo-án-buổi-học-1.4.11-project---thêm-chức-năng-và-hoàn-thiện-game">Giáo án Buổi học 1.4.11: Project - Thêm Chức năng và Hoàn Thiện Game</a></li>
<li><a href="#giáo-án-buổi-học-1.4.12-tổng-kết-dự-án-và-showcase">Giáo án Buổi học 1.4.12: Tổng kết Dự án và Showcase</a></li>
</ul>
</li>
<li><a href="#phụ-lục">Phụ lục</a>
<ul>
<li><a href="#hướng-dẫn-cài-đặt-công-cụ-lập-trình-c-với-unity--visual-studio-code">Hướng dẫn Cài đặt Công cụ Lập trình C# với Unity & Visual Studio Code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="giáo-án-chi-tiết-công-nghệ-game-với-unity---hp4">Giáo án chi tiết Công nghệ Game với Unity - HP4</h1>
<p>Link: <a href="https://docs.google.com/spreadsheets/d/1Tan-N8aVrvQ1H1-Ict9beZoIJ2aVUW4b/edit?gid=1043273961#gid=1043273961&amp;range=B43">Unity HP4 / HK1.4</a></p>
<p><strong>Học phần 1.4: Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#</strong></p>
<p><strong>Đối tượng:</strong> Học sinh 15+ đã biết C# cơ bản.<br>
<strong>Thời lượng:</strong> 100 phút/buổi (Tổng cộng 12 buổi = 1200 phút)<br>
<strong>Mục tiêu chung:</strong> Xây dựng “Puzzle Quest” - Một trò chơi giải đố 2D, người chơi giải các câu đố logic hoặc hình ảnh để qua màn. Trọng tâm là sử dụng hàm và phương thức C# để quản lý trạng thái game, logic câu đố và tương tác người chơi.</p>
<h2 id="tóm-tắt-học-phần-1.4-quản-lý-tài-nguyên--lập-trình-gameplay-với-hàmphương-thức-c">Tóm tắt học phần 1.4: Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#</h2>
<p><strong>Buổi 1.4.1: Giới thiệu Học phần, Ý tưởng Game &amp; Cấu trúc Dự án</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Giới thiệu mục tiêu học phần 4: Quản lý tài nguyên và ứng dụng hàm/phương thức C#.</li>
<li>Phác thảo ý tưởng và cấu trúc cơ bản cho game “Puzzle Quest”.</li>
<li>Thiết lập project Unity ban đầu cho “Puzzle Quest”.</li>
<li>Ôn lại giao diện Unity Editor cơ bản.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu mục tiêu học phần 4, nhấn mạnh việc chuyển đổi sang ngôn ngữ lập trình C# và vai trò của hàm/phương thức trong việc tổ chức mã nguồn hiệu quả.</li>
<li>Thảo luận và phác thảo ý tưởng cho game “Puzzle Quest”: xác định loại câu đố phù hợp (tìm cặp, giải mã, sắp xếp,…), cơ chế gameplay chính, và luồng chơi cơ bản (từ menu chính đến màn chơi và kết thúc).</li>
<li>Hướng dẫn tạo một project Unity mới với template 2D thông qua Unity Hub.</li>
<li>Thiết lập cấu trúc thư mục chuẩn và có tổ chức trong cửa sổ Project (ví dụ: tạo các thư mục <code>_Scenes</code>, <code>_Scripts</code>, <code>_Sprites</code>, <code>_Audio</code>, <code>_Prefabs</code>) để quản lý tài nguyên dự án hiệu quả.</li>
<li>Tạo và lưu các Scene ban đầu cần thiết cho game (ví dụ: <code>MenuScene</code> cho màn hình chính, <code>GameplayScene</code> cho màn chơi).</li>
<li>Ôn tập lại chức năng và cách điều hướng qua các cửa sổ giao diện chính của Unity Editor (Scene, Game, Hierarchy, Inspector, Project, Console) trong ngữ cảnh phát triển game 2D.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Project Unity 2D được tạo với cấu trúc thư mục cơ bản.</li>
<li>Hai scene ban đầu (Menu, Gameplay) được tạo và lưu.</li>
<li>Tài liệu/ghi chú về ý tưởng gameplay và luồng chơi của “Puzzle Quest”.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Trình bày được mục tiêu chính của học phần.</li>
<li>Mô tả được ý tưởng cơ bản và luồng chơi của game “Puzzle Quest”.</li>
<li>Tạo mới một project Unity 2D và tổ chức thư mục cơ bản.</li>
<li>Nhận biết và nêu chức năng các cửa sổ chính trong Unity Editor.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 1.11, 1.15, 2.5, 2.6, 2.8, 2.10, 2.11, 2.12, 4.4.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.2: Quản lý Âm thanh Cơ bản</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Học cách thêm và quản lý âm nhạc nền (BGM).</li>
<li>Học cách thêm và kích hoạt hiệu ứng âm thanh (SFX).</li>
<li>Tìm hiểu về component <code>AudioSource</code> và <code>AudioListener</code>.</li>
<li>Nhập khẩu và cấu hình các file âm thanh trong Unity.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu các thành phần cốt lõi cho hệ thống âm thanh trong Unity: <code>AudioListener</code> (thường tự động gắn với Main Camera, đóng vai trò “tai nghe” trong scene) và <code>AudioSource</code> (component được gắn vào GameObject để chứa và phát các AudioClip).</li>
<li>Giải thích các thuộc tính quan trọng và thường dùng của component <code>AudioSource</code>:
<ul>
<li><code>AudioClip</code>: Nơi gán file âm thanh muốn phát.</li>
<li><code>Play On Awake</code>: Tự động phát khi GameObject được kích hoạt.</li>
<li><code>Loop</code>: Lặp lại âm thanh sau khi phát xong.</li>
<li><code>Volume</code>: Điều chỉnh âm lượng.</li>
<li><code>Pitch</code>: Điều chỉnh cao độ (tốc độ phát).</li>
</ul>
</li>
<li>Thảo luận về các định dạng file âm thanh phổ biến (WAV, MP3, Ogg Vorbis) và xem xét các tùy chọn Import Settings cho audio trong Unity để tối ưu hóa (ví dụ: Compression Format, Load Type).</li>
<li>Hướng dẫn cách tìm kiếm nguồn tài nguyên âm thanh miễn phí (nêu rõ tầm quan trọng của việc kiểm tra giấy phép sử dụng) và nhập khẩu (import) các file âm thanh (nhạc nền - BGM, hiệu ứng - SFX) vào thư mục <code>_Audio</code> của dự án.</li>
<li>Thực hành thêm nhạc nền (BGM) vào game: Tạo một GameObject quản lý âm thanh (ví dụ: “AudioManager”), gắn component <code>AudioSource</code>, gán file BGM vào <code>AudioClip</code>, và thiết lập <code>Play On Awake</code>, <code>Loop</code> để nhạc nền tự động phát và lặp lại.</li>
<li>Thực hành thêm hiệu ứng âm thanh (SFX): Gắn một <code>AudioSource</code> khác (hoặc sử dụng cùng <code>AudioSource</code> nhưng không loop/play on awake), và tạo một script C# đơn giản để kích hoạt việc phát SFX thông qua các phương thức như <code>AudioSource.Play()</code> hoặc <code>AudioSource.PlayOneShot(clip)</code>.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Project có nhạc nền tự động phát khi bắt đầu.</li>
<li>Ít nhất một hiệu ứng âm thanh có thể được kích hoạt thông qua một hành động đơn giản (như nhấn phím).</li>
<li>Các file âm thanh được nhập và tổ chức trong project.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Giải thích vai trò của <code>AudioListener</code> và <code>AudioSource</code>.</li>
<li>Nhập khẩu và cấu hình cơ bản cho file âm thanh.</li>
<li>Thêm nhạc nền lặp lại vào game.</li>
<li>Kích hoạt hiệu ứng âm thanh bằng một đoạn script C# đơn giản.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 2.1.a, 3.1.a, 16.1, 16.2, 16.3, 16.4, 16.5, 16.7, 16.8, 11.7 (implicit).</li>
</ul>
<hr>
<p><strong>Buổi 1.4.3: Quản lý Packages và Assets</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Hiểu và sử dụng Unity Package Manager để thêm/quản lý các gói chức năng.</li>
<li>Tìm hiểu cách sử dụng Unity Asset Store để tìm và nhập tài nguyên.</li>
<li>Thực hành tổ chức assets hiệu quả trong project.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu và hướng dẫn sử dụng cửa sổ Unity Package Manager (<code>Window &gt; Package Manager</code>), công cụ chính để quản lý các gói tính năng mở rộng và tài nguyên được tích hợp hoặc mua từ Unity.</li>
<li>Giải thích các nguồn package khác nhau trong Package Manager: <code>In Project</code> (các package đang có trong dự án), <code>Unity Registry</code> (các package chính thức từ Unity), <code>My Assets</code> (các package đã mua/lấy từ Asset Store).</li>
<li>Thực hành tìm kiếm, xem thông tin chi tiết (dependencies, version) và cài đặt các package từ Unity Registry (ví dụ: các package cần thiết cho 2D như <code>2D Sprite</code>, hoặc <code>TextMeshPro</code> để hiển thị text nâng cao).</li>
<li>Giới thiệu và hướng dẫn cách truy cập, tìm kiếm tài nguyên trên Unity Asset Store (<code>Window &gt; Asset Store</code> hoặc qua trình duyệt web).</li>
<li>Thực hành tìm kiếm, xem thông tin chi tiết, “lấy” (add to my assets - đối với cả asset miễn phí) và sau đó nhập (download và import) các asset pack miễn phí phù hợp từ Asset Store vào dự án thông qua Package Manager (<code>My Assets</code>).</li>
<li>Thảo luận và thực hành các phương pháp tốt nhất (best practices) để tổ chức lại cấu trúc thư mục và quản lý assets trong cửa sổ Project một cách khoa học, đặc biệt là sau khi nhập các gói tài nguyên lớn từ bên ngoài.</li>
<li>Giới thiệu sơ lược về khái niệm Prefabs như một công cụ mạnh mẽ để tạo các “bản thiết kế” GameObject, cho phép đóng gói các component và thuộc tính, dễ dàng tái sử dụng và quản lý hàng loạt đối tượng trong game.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Ít nhất một package từ Unity Registry được xem xét hoặc cài đặt.</li>
<li>Một asset pack miễn phí từ Asset Store được nhập vào project.</li>
<li>Thư mục Project được tổ chức lại gọn gàng sau khi nhập assets.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Sử dụng Package Manager để xem và cài đặt các package cơ bản.</li>
<li>Tìm kiếm, lấy và nhập assets từ Unity Asset Store.</li>
<li>Sắp xếp, tổ chức các thư mục và assets trong cửa sổ Project một cách hợp lý.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 1.20, 2.1.a, 4.4, 4.5, 4.6, 2.5, 2.12, 3.1, 3.9.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.4: Chuẩn bị Tài nguyên Hình ảnh &amp; Thiết kế Màn hình Cơ bản</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Tìm hiểu cách chọn và chuẩn bị tài nguyên hình ảnh (sprites, textures).</li>
<li>Sử dụng Sprite Editor để cắt sprite sheet.</li>
<li>Bắt đầu thiết kế các màn hình UI cơ bản (Menu, Gameplay) bằng các tài nguyên đã nhập.</li>
<li>Giới thiệu các nguồn tài nguyên game miễn phí/trả phí.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Thảo luận về các loại tài nguyên hình ảnh thường gặp trong phát triển game 2D: Sprites (hình ảnh riêng lẻ hoặc trong sprite sheet), Textures (ảnh dùng làm bề mặt, nền), UI elements (icon, nút bấm, khung,…).</li>
<li>Giới thiệu các nguồn tài nguyên hình ảnh uy tín (ví dụ: <a href="http://Kenney.nl">Kenney.nl</a>, OpenGameArt, <a href="http://Itch.io">Itch.io</a>, Unity Asset Store) và nhấn mạnh tầm quan trọng của việc đọc và tuân thủ giấy phép sử dụng (License) của tài nguyên.</li>
<li>Hướng dẫn cách cấu hình các tùy chọn Import Settings quan trọng cho hình ảnh trong Unity, đặc biệt khi dùng làm Sprites (Texture Type: Sprite (2D and UI), Sprite Mode: Single/Multiple, Pixels Per Unit, Filter Mode, Compression).</li>
<li>Giới thiệu và thực hành sử dụng công cụ Sprite Editor (<code>Window &gt; 2D &gt; Sprite Editor</code>) để xem chi tiết và cắt (slice) các sprite riêng lẻ ra từ một sprite sheet (ảnh lớn chứa nhiều hình nhỏ), sử dụng các chế độ cắt tự động (Automatic) hoặc theo lưới (Grid by Cell Size).</li>
<li>Giới thiệu hệ thống UI (User Interface) của Unity:
<ul>
<li><code>Canvas</code>: Đối tượng gốc chứa tất cả các yếu tố UI.</li>
<li><code>Rect Transform</code>: Component đặc biệt để định vị và co giãn các yếu tố UI.</li>
<li><code>Anchors</code> và <code>Pivots</code>: Các khái niệm quan trọng để thiết kế UI thích ứng với các kích thước màn hình khác nhau.</li>
</ul>
</li>
<li>Hướng dẫn tạo và cấu hình các thành phần UI cơ bản thường dùng: <code>Image</code> (hiển thị sprite/texture), <code>Text</code> (hiển thị văn bản - hoặc <code>TextMeshPro</code> nếu đã cài), <code>Button</code> (cho phép tương tác click).</li>
<li>Thực hành xây dựng bố cục giao diện người dùng (UI layout) đơn giản cho các màn hình chính của game (ví dụ: Menu, Gameplay) bằng cách kết hợp các thành phần UI và sử dụng các sprites đã chuẩn bị/nhập khẩu.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Các sprite cần thiết cho game được nhập và cấu hình (cắt từ sheet nếu cần).</li>
<li>Giao diện người dùng (UI) cơ bản cho màn hình Menu và Gameplay được dựng lên bằng các thành phần UI và sprites.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Nhập và cấu hình các loại tài nguyên hình ảnh (sprite, texture).</li>
<li>Sử dụng Sprite Editor để cắt sprite sheet thành các sprite riêng lẻ.</li>
<li>Sử dụng Canvas và các thành phần UI cơ bản (Image, Text, Button) để tạo giao diện người dùng đơn giản.</li>
<li>Tìm kiếm tài nguyên từ các nguồn bên ngoài.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 2.1.a.1, 5.1, 5.2, 5.8, 5.9, 5.13, 18.1, 18.2, 18.5, 18.7, 18.8, 18.10, 3.12.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.5: Giới thiệu Hàm và Phương thức C# (1)</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Giới thiệu chính thức ngôn ngữ C#: Cú pháp cơ bản, biến, kiểu dữ liệu (int, float, bool, string, Vector2), toán tử, cấu trúc điều khiển (<code>if</code>/<code>else</code>).</li>
<li>Giới thiệu khái niệm Hàm (Function) / Phương thức (Method) trong C#: Tại sao cần dùng? (Tổ chức code, tái sử dụng, dễ đọc/bảo trì).</li>
<li>Viết và gọi hàm <code>void</code> đơn giản không có tham số.</li>
<li>Tạo và gắn C# script vào GameObject.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu ngôn ngữ lập trình C# là ngôn ngữ chính được sử dụng để viết logic game trong Unity.</li>
<li>Hướng dẫn cách tạo một file script C# mới trong cửa sổ Project và gắn (attach) script đó như một component vào một GameObject trong Scene.</li>
<li>Giải thích cấu trúc cơ bản và các thành phần thường thấy của một script C# kế thừa từ lớp <code>MonoBehaviour</code> của Unity:
<ul>
<li><code>using UnityEngine;</code>: Khai báo sử dụng thư viện cốt lõi của Unity.</li>
<li><code>public class TenScript : MonoBehaviour</code>: Khai báo lớp (class) của script, kế thừa từ <code>MonoBehaviour</code>.</li>
<li>Các hàm sự kiện (event functions) đặc biệt được Unity tự động gọi: <code>Start()</code> (chạy một lần khi script được kích hoạt) và <code>Update()</code> (chạy mỗi khung hình).</li>
</ul>
</li>
<li>Giới thiệu các khái niệm lập trình C# nền tảng:
<ul>
<li><strong>Biến (Variables):</strong> Cách khai báo biến để lưu trữ dữ liệu, sử dụng các access modifiers (<code>public</code> - hiển thị trong Inspector, <code>private</code> - chỉ dùng nội bộ).</li>
<li><strong>Kiểu dữ liệu (Data Types):</strong> Các kiểu dữ liệu cơ bản (<code>int</code> - số nguyên, <code>float</code> - số thực, <code>bool</code> - đúng/sai, <code>string</code> - chuỗi ký tự) và các kiểu dữ liệu phổ biến của Unity (<code>Vector2</code>/<code>Vector3</code> - vị trí/hướng, <code>GameObject</code>, <code>Transform</code>,…).</li>
<li><strong>Toán tử (Operators):</strong> Các phép toán số học (+, -, *, /), so sánh (==, !=, &lt;, &gt;), logic (&amp;&amp; - VÀ, || - HOẶC, ! - PHỦ ĐỊNH).</li>
<li><strong>Cấu trúc điều khiển (Control Flow):</strong> Câu lệnh <code>if</code>/<code>else if</code>/<code>else</code> để thực thi code dựa trên điều kiện.</li>
<li><strong>Debugging cơ bản:</strong> Sử dụng hàm <code>Debug.Log("Thông điệp");</code> để in thông tin, giá trị biến ra cửa sổ Console của Unity nhằm kiểm tra và gỡ lỗi.</li>
</ul>
</li>
<li>Giới thiệu khái niệm Hàm (Function) / Phương thức (Method) trong lập trình:
<ul>
<li>Định nghĩa: Một khối mã được đặt tên, thực hiện một nhiệm vụ cụ thể.</li>
<li>Lợi ích: Giúp chia nhỏ chương trình thành các phần dễ quản lý, tăng khả năng tái sử dụng code (nguyên tắc DRY - Don’t Repeat Yourself), làm cho code dễ đọc và bảo trì hơn.</li>
</ul>
</li>
<li>Hướng dẫn cú pháp khai báo và định nghĩa một hàm đơn giản không trả về giá trị (<code>void</code>) và không nhận tham số: <code>void TenHamCuaToi() { // Mã lệnh thực thi ở đây }</code>.</li>
<li>Thực hành viết một hàm <code>void</code> tùy chỉnh đầu tiên và cách gọi (invoke/call) hàm đó từ bên trong hàm <code>Start()</code> hoặc <code>Update()</code>.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Một script C# được tạo và gắn vào GameObject.</li>
<li>Script chứa ít nhất một hàm <code>void</code> tùy chỉnh được định nghĩa và gọi từ hàm <code>Start()</code>.</li>
<li>Học sinh chạy game và thấy output từ <code>Debug.Log()</code> trong Console.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Tạo, gắn và mở một script C#.</li>
<li>Giải thích cấu trúc cơ bản của script MonoBehaviour.</li>
<li>Khai báo biến với các kiểu dữ liệu cơ bản.</li>
<li>Sử dụng <code>if/else</code> và <code>Debug.Log()</code>.</li>
<li>Giải thích khái niệm và lợi ích của hàm/phương thức.</li>
<li>Định nghĩa và gọi một hàm <code>void</code> đơn giản không tham số.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 11.2, 11.3, 11.4, 11.6, 11.7, 11.9, 13.2.1, 13.3.a.1, 15.8.1.a.1, 15.8.1.a.2, 15.9.1.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.6: Ứng dụng Hàm và Phương thức C# (2)</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Viết và sử dụng hàm có tham số (parameters).</li>
<li>Viết và sử dụng hàm có giá trị trả về (return types khác <code>void</code>).</li>
<li>Áp dụng hàm để bắt đầu xây dựng logic cơ bản cho “Puzzle Quest”.</li>
<li>Hiểu về phạm vi biến (scope).</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giải thích khái niệm <strong>tham số (parameters)</strong> trong định nghĩa hàm: là các biến đại diện cho dữ liệu đầu vào mà hàm cần để thực hiện nhiệm vụ. Giúp hàm trở nên linh hoạt và tái sử dụng tốt hơn.</li>
<li>Hướng dẫn cú pháp khai báo hàm có tham số: <code>void TenHam(kieuDuLieu1 tenThamSo1, kieuDuLieu2 tenThamSo2) { ... }</code>.</li>
<li>Thực hành viết các hàm nhận tham số với các kiểu dữ liệu khác nhau (ví dụ: <code>void AddScore(int pointsToAdd)</code>, <code>void MovePlayer(Vector2 direction)</code>).</li>
<li>Giải thích cách truyền <strong>đối số (arguments)</strong> - là các giá trị cụ thể - vào hàm khi gọi nó: <code>AddScore(10);</code>, <code>MovePlayer(new Vector2(1, 0));</code>.</li>
<li>Giải thích khái niệm <strong>giá trị trả về (return value)</strong>: là kết quả mà hàm tính toán hoặc xử lý xong và “gửi lại” cho nơi đã gọi nó. Cần thiết khi muốn lấy kết quả từ một hàm để sử dụng tiếp.</li>
<li>Hướng dẫn cú pháp khai báo hàm có giá trị trả về: <code>kieuDuLieuTraVe TenHam(thamSo...) { ... return giaTriTraVe; }</code>. Từ khóa <code>return</code> dùng để chỉ định giá trị trả về và kết thúc hàm.</li>
<li>Thực hành viết các hàm trả về các kiểu dữ liệu khác nhau (ví dụ: <code>int GetCurrentScore() { return score; }</code>, <code>bool IsPlayerAlive() { return health &gt; 0; }</code>).</li>
<li>Hướng dẫn cách gọi hàm có giá trị trả về và lưu kết quả vào một biến: <code>int currentScore = GetCurrentScore();</code>, <code>if (IsPlayerAlive()) { ... }</code>.</li>
<li>Giới thiệu khái niệm <strong>phạm vi biến (variable scope)</strong>:
<ul>
<li><strong>Biến cục bộ (Local variables):</strong> Được khai báo bên trong một hàm, chỉ tồn tại và có thể truy cập được từ bên trong hàm đó.</li>
<li><strong>Biến thành viên (Member/Instance variables):</strong> Được khai báo bên ngoài các hàm nhưng bên trong lớp, tồn tại suốt vòng đời của đối tượng (instance) chứa script đó, có thể truy cập từ bất kỳ hàm nào trong lớp.</li>
</ul>
</li>
<li>Bắt đầu vận dụng kiến thức về hàm (có tham số, có trả về) để phác thảo và viết khung sườn (skeleton) cho các hàm logic chính của game “Puzzle Quest” (ví dụ: <code>void SetupPuzzle(int levelNumber)</code>, <code>bool CheckWinCondition()</code>).</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Script C# chứa các hàm có tham số và hàm có giá trị trả về.</li>
<li>Các hàm này được gọi và kết quả/hoạt động của chúng được kiểm tra (qua <code>Debug.Log</code> hoặc thay đổi trạng thái game).</li>
<li>Khung sườn các hàm chính cho logic game “Puzzle Quest”.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Định nghĩa và gọi hàm có tham số.</li>
<li>Định nghĩa và gọi hàm có giá trị trả về, sử dụng kết quả trả về.</li>
<li>Phân biệt được biến cục bộ và biến thành viên (instance variable).</li>
<li>Áp dụng kiến thức về hàm để bắt đầu cấu trúc logic game.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> (Tiếp tục) 13.2.1, 13.3.a.1, 11.4, 11.6. <em>Mới:</em> 13.4.1.a.1, 13.4.1.a.2.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.7: Project - Phát triển Cấp độ và Thách Thức</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Sử dụng các hàm đã học để xây dựng logic cốt lõi của một màn chơi trong “Puzzle Quest”.</li>
<li>Tạo ra các đối tượng game (mảnh ghép, ô chữ,…) bằng code hoặc Prefab.</li>
<li>Xử lý tương tác cơ bản của người chơi (ví dụ: click chuột vào đối tượng).</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Phân tích chi tiết và xác định các bước logic, các trạng thái cần quản lý để triển khai một màn chơi hoàn chỉnh của game “Puzzle Quest” dựa trên ý tưởng đã thống nhất.</li>
<li>Áp dụng kiến thức về hàm và phương thức C# để xây dựng các chức năng gameplay cốt lõi, chia nhỏ logic thành các hàm có nhiệm vụ rõ ràng:
<ul>
<li>Triển khai hàm <code>SetupLevel()</code>: Sử dụng vòng lặp, tạo các đối tượng câu đố (ví dụ: các mảnh ghép) bằng cách <code>Instantiate</code> từ Prefab đã chuẩn bị hoặc tạo GameObject hoàn toàn bằng code. Gán dữ liệu cần thiết (hình ảnh, giá trị, vị trí) cho các đối tượng này.</li>
<li>Triển khai hàm <code>HandleObjectClick(GameObject clickedObject)</code>: Hàm này sẽ được gọi khi người chơi tương tác (ví dụ: click) vào một đối tượng câu đố. Bên trong hàm sẽ xử lý logic tương ứng (ví dụ: lật mảnh ghép, chọn đối tượng).</li>
<li>Triển khai hàm <code>CheckMatch()</code> (hoặc tên tương tự): Logic để kiểm tra xem các lựa chọn/hành động của người chơi có khớp với điều kiện giải đố hay không (ví dụ: kiểm tra hai mảnh ghép vừa lật có giống nhau).</li>
<li>Triển khai hàm <code>CheckWinCondition()</code>: Logic để kiểm tra xem người chơi đã hoàn thành màn chơi hay chưa (ví dụ: tất cả các cặp đã được tìm thấy).</li>
</ul>
</li>
<li>Tìm hiểu cách phát hiện và xử lý input từ người chơi:
<ul>
<li>Sử dụng lớp <code>Input</code> của Unity trong hàm <code>Update()</code> để kiểm tra các sự kiện như nhấn chuột (<code>Input.GetMouseButtonDown(0)</code>).</li>
<li>Sử dụng <code>Physics.Raycast</code> (cho 3D) hoặc <code>Physics2D.Raycast</code> (cho 2D) để xác định đối tượng mà người chơi đã click vào.</li>
<li>Hoặc sử dụng hệ thống sự kiện (Event System) của Unity UI nếu các đối tượng tương tác là các thành phần UI (ví dụ: Button).</li>
</ul>
</li>
<li>Thực hành kỹ năng gỡ lỗi (debugging) chủ động: Sử dụng <code>Debug.Log()</code> để in ra giá trị các biến quan trọng, theo dõi luồng thực thi của chương trình, xác định và sửa các lỗi logic trong quá trình phát triển.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Một màn chơi cơ bản của “Puzzle Quest” có thể chơi được, với logic giải đố chính được triển khai bằng các hàm C#.</li>
<li>Người chơi có thể tương tác với các đối tượng trên màn hình.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Áp dụng hàm C# để triển khai logic gameplay cốt lõi.</li>
<li>Tạo đối tượng game trong Scene bằng code (<code>Instantiate</code>).</li>
<li>Xử lý sự kiện click chuột cơ bản lên đối tượng game.</li>
<li>Sử dụng <code>Debug.Log</code> để gỡ lỗi logic game.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> <em>Kết hợp:</em> (Lập trình) 11.x, 13.x, 15.x; (GameObject) 3.x; (Tương tác/Physics) 12.x; Cụ thể: 3.8, 3.10, 13.2.1, 13.3.a.1, 11.6, 12.2.1.a (nếu dùng Raycast).</li>
</ul>
<hr>
<p><strong>Buổi 1.4.8: Project - Tối Ưu Hóa và Kiểm Tra Game</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Tìm hiểu các khái niệm cơ bản về tối ưu hóa hiệu suất liên quan đến code C#.</li>
<li>Sử dụng các kỹ thuật debug nâng cao hơn (ngoài <code>Debug.Log</code>).</li>
<li>Thực hiện kiểm thử (playtesting) để tìm lỗi và cải thiện trải nghiệm người chơi.</li>
<li>Refactor (tái cấu trúc) code sử dụng hàm để cải thiện tính rõ ràng và hiệu quả.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu các khái niệm cơ bản và các vấn đề thường gặp liên quan đến tối ưu hóa hiệu suất (performance optimization) trong Unity và C#:
<ul>
<li>Tác động tiêu cực của việc thực thi quá nhiều logic phức tạp trong hàm <code>Update()</code> (chạy mỗi khung hình).</li>
<li>Vấn đề <strong>Garbage Collection (GC)</strong>: Việc tạo và hủy (destroy) đối tượng liên tục trong game có thể dẫn đến hiện tượng “giật lag” do bộ nhớ cần được dọn dẹp.</li>
<li>Kỹ thuật <strong>Caching Components</strong>: Lưu trữ tham chiếu đến các component cần dùng thường xuyên (ví dụ: <code>Transform</code>, <code>Rigidbody</code>) vào biến thành viên trong hàm <code>Start()</code> hoặc <code>Awake()</code> thay vì gọi <code>GetComponent&lt;T&gt;()</code> nhiều lần trong <code>Update()</code>.</li>
<li>Giới thiệu ý tưởng về <strong>Object Pooling</strong>: Tái sử dụng các đối tượng đã tạo thay vì hủy đi và tạo mới liên tục (hữu ích cho đạn, hiệu ứng,…).</li>
</ul>
</li>
<li>Giới thiệu các công cụ và kỹ thuật debugging nâng cao hơn <code>Debug.Log()</code>:
<ul>
<li><strong>Unity Profiler</strong> (<code>Window &gt; Analysis &gt; Profiler</code>): Công cụ mạnh mẽ để phân tích hiệu năng của game theo thời gian thực, xem chi tiết mức sử dụng CPU, bộ nhớ (Memory), Rendering, Physics,… Giúp xác định các “điểm nóng” gây chậm game.</li>
<li><strong>Điểm dừng (Breakpoints)</strong>: Tính năng của các trình soạn thảo code (IDE) như Visual Studio/VS Code, cho phép tạm dừng thực thi chương trình tại một dòng code cụ thể để kiểm tra giá trị của các biến và theo dõi luồng thực thi từng bước.</li>
</ul>
</li>
<li>Tổ chức hoạt động <strong>kiểm thử game (playtesting)</strong>: Học sinh chơi thử game của nhau, tập trung vào việc tìm lỗi (bugs), các điểm chưa hợp lý trong gameplay, và đưa ra phản hồi mang tính xây dựng cho bạn bè.</li>
<li>Giới thiệu khái niệm <strong>tái cấu trúc code (Refactoring)</strong>: Là quá trình cải thiện cấu trúc của mã nguồn hiện có mà không làm thay đổi hành vi bên ngoài của nó. Mục đích là làm cho code dễ đọc, dễ hiểu, dễ bảo trì và có thể hiệu quả hơn.</li>
<li>Thực hành các kỹ thuật refactoring đơn giản: Tìm các đoạn code bị lặp lại và tách chúng ra thành hàm riêng; chia nhỏ các hàm quá dài và phức tạp thành các hàm nhỏ hơn với mục đích rõ ràng; đặt lại tên biến, tên hàm sao cho dễ hiểu và thể hiện đúng ý nghĩa.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Code được xem xét và cải thiện về mặt cấu trúc và hiệu năng cơ bản.</li>
<li>Học sinh làm quen với Profiler và Breakpoints.</li>
<li>Danh sách lỗi và đề xuất cải thiện từ buổi playtesting.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Nhận biết một số vấn đề hiệu năng cơ bản trong code C#.</li>
<li>Sử dụng Profiler để xem thông tin hiệu năng cơ bản.</li>
<li>Sử dụng Breakpoints để debug code.</li>
<li>Thực hiện playtesting và đưa ra phản hồi.</li>
<li>Áp dụng kỹ thuật refactoring đơn giản để cải thiện code.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> 11.4, 12.2.1, 13.4.1.b.1.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.9: Kiểm tra Lý thuyết</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Đánh giá kiến thức tổng hợp về các khái niệm Unity và C# đã học trong học phần.</li>
<li>Tập trung vào quản lý tài nguyên (âm thanh, assets, packages) và hàm/phương thức C#.</li>
<li>Cung cấp cơ hội để học sinh đặt câu hỏi và làm rõ các vấn đề chưa hiểu.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Hệ thống hóa và ôn tập các kiến thức, kỹ năng trọng tâm đã được học trong suốt Học phần 4, bao gồm:
<ul>
<li><strong>Quản lý Tài nguyên:</strong> Vai trò và cách sử dụng <code>AudioSource</code>, <code>AudioListener</code>; Mục đích và thao tác với <code>Package Manager</code>; Cách tìm và nhập tài nguyên từ <code>Asset Store</code>; Cấu hình import settings cho audio, sprite; Sử dụng <code>Sprite Editor</code>.</li>
<li><strong>Lập trình C#:</strong> Cú pháp cơ bản (biến, kiểu dữ liệu, <code>if/else</code>, toán tử); Cấu trúc script <code>MonoBehaviour</code> (<code>Start</code>, <code>Update</code>); Cách sử dụng <code>Debug.Log()</code>.</li>
<li><strong>Hàm và Phương thức:</strong> Khái niệm, lợi ích; Cú pháp khai báo và gọi hàm <code>void</code>, hàm có tham số, hàm có giá trị trả về; Khái niệm phạm vi biến (local vs member).</li>
</ul>
</li>
<li>Thực hiện một bài kiểm tra lý thuyết (dạng trắc nghiệm, điền khuyết, trả lời ngắn) được thiết kế để đánh giá mức độ nắm vững các khái niệm và kỹ năng đã ôn tập.</li>
<li>Chữa bài kiểm tra, giải thích chi tiết các đáp án đúng, làm rõ những lỗi sai phổ biến.</li>
<li>Dành thời gian đáng kể để giải đáp mọi câu hỏi, thắc mắc còn tồn đọng của học sinh liên quan đến bất kỳ nội dung nào đã học trong học phần.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Bài kiểm tra lý thuyết đã hoàn thành của học sinh.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Thể hiện được mức độ hiểu biết về các khái niệm và kỹ thuật đã học qua bài kiểm tra.</li>
<li>Xác định được những phần kiến thức cần củng cố thêm.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> <em>Tổng hợp nhiều mục tiêu</em>, ví dụ: 2.1.a, 3.1.a, 1.20, 2.1.a.1, 11.2, 11.3, 11.7, 11.9, 13.3.a.1, 15.8.1.a.1, 15.9.1, etc.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.10: Project - Tạo ra các Phần thưởng Ngẫu nhiên</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Học cách sử dụng lớp <code>Random</code> trong C# (hoặc <code>UnityEngine.Random</code>) để tạo sự ngẫu nhiên.</li>
<li>Áp dụng tính ngẫu nhiên để tạo yếu tố bất ngờ trong game (ví dụ: phần thưởng, vị trí đối tượng).</li>
<li>Tích hợp logic ngẫu nhiên vào các hàm hiện có.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Giới thiệu cách tạo ra các giá trị ngẫu nhiên trong lập trình C# với Unity, sử dụng lớp tĩnh <code>UnityEngine.Random</code>.</li>
<li>Hướng dẫn sử dụng các phương thức (methods) phổ biến của lớp <code>Random</code>:
<ul>
<li><code>Random.Range(minInclusive, maxExclusive)</code>: Sinh số nguyên ngẫu nhiên trong khoảng từ <code>minInclusive</code> đến <code>maxExclusive - 1</code>.</li>
<li><code>Random.Range(minInclusive, maxInclusive)</code>: Sinh số thực (float) ngẫu nhiên trong khoảng từ <code>minInclusive</code> đến <code>maxInclusive</code>.</li>
<li><code>Random.value</code>: Sinh số thực ngẫu nhiên trong khoảng từ 0.0 đến 1.0 (bao gồm cả 0.0 và 1.0).</li>
</ul>
</li>
<li>Thực hành viết các đoạn code ví dụ đơn giản để sinh ra các loại giá trị ngẫu nhiên khác nhau và hiển thị chúng bằng <code>Debug.Log()</code>.</li>
<li>Tổ chức thảo luận (brainstorm) về các cách có thể áp dụng yếu tố ngẫu nhiên (randomness) vào game “Puzzle Quest” để làm tăng tính thử thách, sự bất ngờ và khả năng chơi lại (replayability). Ví dụ:
<ul>
<li>Xáo trộn vị trí ban đầu của các mảnh ghép/đối tượng câu đố.</li>
<li>Phần thưởng ngẫu nhiên (điểm số, vật phẩm cosmetic) khi hoàn thành màn chơi.</li>
<li>Xuất hiện các thử thách phụ hoặc chướng ngại vật ngẫu nhiên.</li>
<li>Tạo ra các màn chơi có cấu trúc hoặc mục tiêu ngẫu nhiên.</li>
</ul>
</li>
<li>Thực hành lựa chọn và triển khai một hoặc hai ý tưởng về cơ chế ngẫu nhiên vào trong các hàm C# của dự án game. Ví dụ: sửa đổi hàm <code>SetupLevel()</code> để sử dụng <code>Random.Range()</code> sắp xếp vị trí, hoặc viết hàm <code>AwardRandomBonus()</code> sử dụng <code>Random.value</code> để quyết định phần thưởng.</li>
<li>Kiểm tra kỹ lưỡng bằng cách chơi thử nhiều lần để đảm bảo rằng các yếu tố ngẫu nhiên hoạt động đúng như thiết kế và mang lại hiệu quả mong muốn.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Game “Puzzle Quest” có ít nhất một yếu tố gameplay được điều khiển bởi sự ngẫu nhiên.</li>
<li>Các hàm C# sử dụng <code>UnityEngine.Random</code> để tạo ra kết quả ngẫu nhiên.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Sử dụng các hàm của <code>UnityEngine.Random</code> để sinh số nguyên và số thực ngẫu nhiên.</li>
<li>Thiết kế và triển khai một cơ chế ngẫu nhiên đơn giản trong game.</li>
<li>Tích hợp logic ngẫu nhiên vào cấu trúc hàm hiện có.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> (Lập trình) 11.6, 13.2.1, 13.3.a.1.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.11: Project - Thêm Chức năng và Hoàn Thiện Game</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Hoàn thiện luồng chơi chính của game (từ Menu đến Gameplay và quay lại).</li>
<li>Thêm các chức năng phụ trợ (ví dụ: hệ thống điểm số, chuyển màn, màn hình thắng/thua).</li>
<li>Đánh bóng (polish) game: thêm hiệu ứng hình ảnh/âm thanh đơn giản, cải thiện UI.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Xây dựng và hoàn thiện luồng chơi (game flow) hoàn chỉnh, đảm bảo người chơi có thể di chuyển mượt mà giữa các trạng thái/màn hình chính của game:
<ul>
<li>Sử dụng <code>UnityEngine.SceneManagement.SceneManager.LoadScene("TenScene");</code> để thực hiện việc chuyển đổi giữa các Scene trong game.</li>
<li>Viết các hàm C# (ví dụ: <code>LoadGameplayScene()</code>, <code>LoadMenuScene()</code>) và liên kết chúng với sự kiện <code>OnClick</code> của các nút bấm (Button) trên giao diện UI để người chơi có thể điều hướng.</li>
<li>Thiết kế và triển khai các màn hình hoặc panel UI để thông báo kết quả cuối cùng cho người chơi (Màn hình/Panel Thắng, Màn hình/Panel Thua). Hiển thị các thông tin liên quan như điểm số đạt được, nút chơi lại hoặc quay về menu. Kích hoạt các màn hình/panel này dựa trên logic thắng/thua đã xây dựng (ví dụ: khi <code>CheckWinCondition()</code> trả về <code>true</code>).</li>
</ul>
</li>
<li>Bổ sung các chức năng phụ trợ cần thiết để làm game hoàn chỉnh hơn:
<ul>
<li>Hiển thị thông tin trạng thái game lên giao diện người dùng (UI) theo thời gian thực. Ví dụ: cập nhật một đối tượng Text/TextMeshPro để hiển thị giá trị của biến <code>score</code> mỗi khi điểm thay đổi.</li>
<li>(Tùy chọn, nâng cao) Giới thiệu sơ lược về <code>PlayerPrefs</code>: một cách đơn giản để lưu trữ và truy xuất dữ liệu nhỏ (như điểm cao, cài đặt đơn giản, màn chơi đã mở khóa) giữa các lần chơi game.</li>
</ul>
</li>
<li>Thực hiện các bước “đánh bóng” (polishing) để nâng cao trải nghiệm người chơi:
<ul>
<li>Thêm các phản hồi nghe-nhìn (audio-visual feedback) rõ ràng cho các hành động của người chơi: Kích hoạt hiệu ứng âm thanh (SFX) khi nhấn nút, khi giải đố đúng/sai; Thêm các hiệu ứng hình ảnh đơn giản như đổi màu/kích thước nút khi di chuột qua/nhấn, hoặc hiệu ứng hạt (Particle System) nhỏ khi hoàn thành một mục tiêu.</li>
<li>Tinh chỉnh giao diện người dùng (UI): Đảm bảo bố cục các phần tử hợp lý, dễ nhìn; Sử dụng font chữ, màu sắc, kích thước một cách nhất quán và phù hợp với phong cách game.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Game có luồng chơi hoàn chỉnh từ đầu đến cuối.</li>
<li>Các chức năng như điểm số, chuyển màn, màn hình kết thúc hoạt động.</li>
<li>Giao diện và trải nghiệm người chơi được cải thiện cơ bản.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Sử dụng <code>SceneManager</code> để chuyển đổi giữa các Scene.</li>
<li>Hiển thị thông tin game (điểm số) lên UI.</li>
<li>Triển khai màn hình kết thúc game (thắng/thua).</li>
<li>Thêm các hiệu ứng âm thanh/hình ảnh đơn giản để tăng tính hấp dẫn.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> (Tổng hợp) 2.6, 11.x, 13.x, 18.x, 16.x. <em>Có thể giới thiệu:</em> 15.</li>
</ul>
<hr>
<p><strong>Buổi 1.4.12: Tổng kết Dự án và Showcase</strong></p>
<ul>
<li><strong>Mục tiêu chính:</strong>
<ul>
<li>Hoàn thiện những chi tiết cuối cùng của dự án “Puzzle Quest”.</li>
<li>Trình bày (showcase) sản phẩm của mình cho cả lớp.</li>
<li>Nhìn lại quá trình học tập và những kiến thức/kỹ năng đã đạt được trong học phần.</li>
<li>Thảo luận về các hướng phát triển tiếp theo.</li>
</ul>
</li>
<li><strong>Chi tiết hóa nội dung:</strong>
<ul>
<li>Cung cấp thời gian để học sinh rà soát lại toàn bộ dự án “Puzzle Quest”, sửa các lỗi nhỏ còn sót lại, bổ sung những chi tiết cuối cùng muốn thêm vào, và đảm bảo game hoạt động ổn định cho buổi trình bày.</li>
<li>Tổ chức buổi trình bày sản phẩm (showcase), tạo cơ hội cho mỗi học sinh (hoặc nhóm) giới thiệu dự án game của mình trước lớp:
<ul>
<li>Chạy demo trực tiếp các tính năng chính của game.</li>
<li>Trình bày về cách đã áp dụng các kiến thức đã học trong học phần, đặc biệt là việc sử dụng hàm/phương thức C# để cấu trúc và triển khai logic gameplay.</li>
<li>Chia sẻ về những khó khăn, thách thức đã gặp phải trong quá trình phát triển và cách đã vượt qua chúng.</li>
<li>(Khuyến khích) Nêu ra những ý tưởng hoặc kế hoạch để phát triển, mở rộng game trong tương lai.</li>
</ul>
</li>
<li>Giáo viên tổng kết lại toàn bộ hành trình học tập của Học phần 4, điểm lại các kiến thức và kỹ năng cốt lõi đã được trang bị (quản lý tài nguyên, lập trình C# với hàm/phương thức).</li>
<li>Đưa ra những nhận xét, phản hồi tích cực, khen ngợi sự nỗ lực và những thành quả mà học sinh đã đạt được qua dự án. Khuyến khích tinh thần tiếp tục học hỏi, khám phá và phát triển các dự án cá nhân.</li>
<li>Hướng dẫn học sinh cách đóng gói (build) game thành file thực thi (nếu có thời gian) và cách lưu trữ, sao lưu project một cách cẩn thận để tham khảo hoặc phát triển tiếp sau này.</li>
</ul>
</li>
<li><strong>Sản phẩm/Kết quả cụ thể:</strong>
<ul>
<li>Phiên bản hoàn thiện nhất của dự án “Puzzle Quest” của mỗi học sinh/nhóm.</li>
<li>Buổi trình bày sản phẩm trước lớp.</li>
</ul>
</li>
<li><strong>Outcome (Học sinh có thể làm được):</strong>
<ul>
<li>Trình bày và giới thiệu về sản phẩm game mình đã làm.</li>
<li>Phản ánh về quá trình học tập và những kỹ năng đã tiếp thu.</li>
<li>Nhận biết được các bước tiếp theo có thể thực hiện để phát triển kỹ năng lập trình game.</li>
</ul>
</li>
<li><strong>Liên kết UCA Objectives:</strong> <em>Tổng hợp toàn bộ học phần.</em></li>
</ul>
<h2 id="mô-tả-dự-án-mẫu-và-cách-triển-khai">Mô tả dự án mẫu và cách triển khai</h2>
<p><strong>Tên Dự án Mẫu:</strong> “Memory Match Madness” (Trò chơi Lật hình Ghi nhớ)</p>
<h3 id="concept--gameplay">1. Concept &amp; Gameplay:</h3>
<ul>
<li><strong>Thể loại:</strong> Game giải đố 2D (Puzzle).</li>
<li><strong>Mục tiêu:</strong> Người chơi lật các thẻ bài úp trên một lưới (grid). Mỗi thẻ có một biểu tượng (symbol) ẩn. Người chơi phải tìm và lật các cặp thẻ có biểu tượng giống hệt nhau. Khi tìm được một cặp, chúng sẽ biến mất hoặc giữ nguyên trạng thái ngửa. Mục tiêu là tìm tất cả các cặp trong thời gian ngắn nhất hoặc với số lượt lật ít nhất.</li>
<li><strong>Luồng chơi:</strong>
<ol>
<li><strong>Menu Chính:</strong> Hiển thị tên game, nút “Play”.</li>
<li><strong>Màn Chơi:</strong>
<ul>
<li>Hiển thị lưới thẻ bài úp (ví dụ: 4x4).</li>
<li>Người chơi click vào một thẻ để lật nó lên.</li>
<li>Người chơi click vào thẻ thứ hai.</li>
<li><strong>Nếu cặp thẻ trùng khớp:</strong> Hai thẻ giữ nguyên trạng thái ngửa (hoặc biến mất), người chơi nhận điểm, hiệu ứng âm thanh/hình ảnh báo hiệu thành công.</li>
<li><strong>Nếu cặp thẻ không trùng khớp:</strong> Hai thẻ úp lại sau một khoảng thời gian ngắn, hiệu ứng âm thanh báo hiệu thất bại.</li>
<li>Tiếp tục cho đến khi tất cả các cặp được tìm thấy.</li>
<li>Hiển thị điểm số/thời gian/số lượt lật.</li>
</ul>
</li>
<li><strong>Màn Hình Kết Thúc (Thắng):</strong> Hiển thị thông báo chiến thắng, điểm số cuối cùng, nút “Chơi lại” hoặc “Về Menu”.</li>
</ol>
</li>
</ul>
<h3 id="tài-nguyên-cần-thiết-minh-họa-việc-quản-lý-tài-nguyên">2. Tài nguyên Cần thiết (Minh họa việc Quản lý Tài nguyên):</h3>
<ul>
<li><strong>Sprites (Buổi 1.4.4):</strong>
<ul>
<li><code>Card_Back.png</code>: Hình ảnh mặt sau của thẻ bài (chỉ cần 1).</li>
<li><code>Card_Face_Symbol_01.png</code>, <code>Card_Face_Symbol_02.png</code>, … : Hình ảnh các biểu tượng khác nhau cho mặt trước thẻ bài (cần ít nhất 8 biểu tượng khác nhau cho lưới 4x4, mỗi biểu tượng 2 thẻ). Có thể lấy từ Asset Store miễn phí hoặc tự vẽ đơn giản. <em>-&gt; Thực hành Import Settings, Sprite Editor (nếu dùng sprite sheet).</em></li>
<li><code>Background.png</code>: Hình nền cho màn chơi (tùy chọn).</li>
<li><code>Button_Play.png</code>, <code>Button_Replay.png</code>: Hình ảnh cho các nút bấm (tùy chọn, có thể dùng UI Button mặc định).</li>
</ul>
</li>
<li><strong>Audio (Buổi 1.4.2):</strong>
<ul>
<li><code>BackgroundMusic.mp3</code> / <code>.ogg</code>: Nhạc nền cho game (tìm file loop miễn phí).</li>
<li><code>SFX_CardFlip.wav</code>: Âm thanh khi lật thẻ.</li>
<li><code>SFX_MatchSuccess.wav</code>: Âm thanh khi tìm đúng cặp.</li>
<li><code>SFX_MatchFail.wav</code>: Âm thanh khi lật sai cặp.</li>
<li><code>SFX_GameWin.wav</code>: Âm thanh khi thắng game.</li>
<li><em>-&gt; Thực hành Import Audio, sử dụng AudioSource, AudioListener, gọi Play/PlayOneShot từ script.</em></li>
</ul>
</li>
<li><strong>Prefabs (Giới thiệu ở 1.4.3, tạo ở 1.4.7):</strong>
<ul>
<li><code>CardPrefab</code>: Một GameObject chứa:
<ul>
<li>Sprite Renderer chính (hiển thị mặt sau hoặc mặt trước).</li>
<li>Component <code>BoxCollider2D</code> để nhận click chuột.</li>
<li>Script <code>Card.cs</code> (xem bên dưới).</li>
</ul>
</li>
</ul>
</li>
<li><strong>Packages (Buổi 1.4.3):</strong>
<ul>
<li>Có thể cần kiểm tra/cài đặt package <code>2D Sprite</code> qua Package Manager.</li>
<li>Khuyến khích dùng <code>TextMeshPro</code> để hiển thị text (điểm số) đẹp hơn.</li>
</ul>
</li>
<li><strong>Unity Asset Store (Buổi 1.4.3):</strong>
<ul>
<li>Nơi tìm kiếm các sprite biểu tượng thẻ bài, hình nền, âm thanh miễn phí.</li>
</ul>
</li>
</ul>
<h3 id="cấu-trúc-scene--ui">3. Cấu trúc Scene &amp; UI:</h3>
<ul>
<li><strong>Scene <code>MenuScene</code>:</strong>
<ul>
<li>Canvas: Chứa các UI element.</li>
<li>Image: Hiển thị Background (tùy chọn).</li>
<li>Text/TextMeshPro: Hiển thị tên game.</li>
<li>Button: Nút “Play” -&gt; Gọi script để load <code>GameplayScene</code>.</li>
</ul>
</li>
<li><strong>Scene <code>GameplayScene</code>:</strong>
<ul>
<li>Main Camera (có AudioListener).</li>
<li>GameObject <code>BoardManager</code> (hoặc <code>GameManager</code>): Chứa script chính điều khiển logic game.</li>
<li>GameObject <code>AudioManager</code>: Chứa AudioSource cho BGM và SFX.</li>
<li>Canvas:
<ul>
<li>Text/TextMeshPro <code>ScoreText</code>: Hiển thị điểm số.</li>
<li>(Tùy chọn) Panel <code>WinPanel</code>: Ban đầu ẩn, hiện lên khi thắng, chứa Text thông báo và Button “Chơi lại”/“Về Menu”.</li>
</ul>
</li>
<li>Các <code>CardPrefab</code> được tạo ra bởi script <code>BoardManager</code>.</li>
</ul>
</li>
</ul>
<h3 id="cấu-trúc-script-c--ứng-dụng-hàmphương-thức-trọng-tâm-học-phần">4. Cấu trúc Script C# &amp; Ứng dụng Hàm/Phương thức (Trọng tâm Học phần):</h3>
<ul>
<li>
<p><strong><code>BoardManager.cs</code> (Gắn vào GameObject <code>BoardManager</code>):</strong></p>
<ul>
<li><strong>Biến thành viên (Member Variables):</strong>
<ul>
<li><code>public GameObject cardPrefab;</code> (Gán CardPrefab từ Editor).</li>
<li><code>public Transform cardsParent;</code> (Nơi chứa các thẻ được tạo ra).</li>
<li><code>public List&lt;Sprite&gt; cardSymbols;</code> (Danh sách các sprite biểu tượng).</li>
<li><code>private List&lt;Card&gt; boardCards = new List&lt;Card&gt;();</code> (Lưu trữ các thẻ trên bàn).</li>
<li><code>private Card firstSelectedCard = null;</code></li>
<li><code>private Card secondSelectedCard = null;</code></li>
<li><code>private int score = 0;</code></li>
<li><code>private int pairsFound = 0;</code></li>
<li><code>private int totalPairs;</code></li>
<li><code>public TextMeshProUGUI scoreText;</code> (Gán từ Editor).</li>
<li><code>public GameObject winPanel;</code> (Gán từ Editor).</li>
<li><code>public float delayBeforeHide = 1f;</code> (Thời gian chờ trước khi úp thẻ sai).</li>
<li><code>private bool canPlayerClick = true;</code> (Chặn click khi đang xử lý cặp thẻ).</li>
</ul>
</li>
<li><strong>Hàm <code>Start()</code>:</strong>
<ul>
<li>Gọi <code>SetupBoard()</code>.</li>
<li>(Tùy chọn) Gọi hàm phát nhạc nền.</li>
</ul>
</li>
<li><strong>Hàm <code>void SetupBoard()</code> (Buổi 1.4.7, 1.4.10 - ứng dụng Random):</strong>
<ul>
<li>Xác định số lượng thẻ cần tạo (ví dụ: 16 cho lưới 4x4).</li>
<li><code>totalPairs = numberOfCards / 2;</code></li>
<li>Tạo danh sách các <code>Sprite</code> cần dùng (lấy <code>totalPairs</code> biểu tượng, mỗi biểu tượng 2 lần).</li>
<li><strong>Sử dụng <code>UnityEngine.Random</code> để xáo trộn (shuffle) danh sách <code>Sprite</code> này.</strong></li>
<li>Dùng vòng lặp để <code>Instantiate</code> các <code>CardPrefab</code> tại các vị trí trên lưới.</li>
<li>Gán <code>Sprite</code> biểu tượng đã xáo trộn cho từng thẻ (thông qua script <code>Card.cs</code>).</li>
<li>Lưu thẻ vào <code>boardCards</code>.</li>
</ul>
</li>
<li><strong>Hàm <code>public void CardSelected(Card card)</code> (Được gọi từ <code>Card.cs</code> khi click):</strong>
<ul>
<li>Kiểm tra <code>!canPlayerClick</code> hoặc thẻ đã được lật/khớp -&gt; <code>return;</code></li>
<li>Gọi <code>FlipCard(card, true);</code> -&gt; Lật thẻ lên.</li>
<li>Gọi <code>PlaySound(flipSound);</code></li>
<li>Nếu <code>firstSelectedCard == null</code>: Gán <code>card</code> cho <code>firstSelectedCard</code>.</li>
<li>Ngược lại (đã chọn thẻ thứ nhất):
<ul>
<li>Gán <code>card</code> cho <code>secondSelectedCard</code>.</li>
<li><code>canPlayerClick = false;</code> -&gt; Chặn click tiếp.</li>
<li>Gọi <code>CheckForMatch();</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Hàm <code>void CheckForMatch()</code> (Buổi 1.4.6 - logic so sánh):</strong>
<ul>
<li>So sánh <code>cardID</code> (hoặc <code>Sprite</code>) của <code>firstSelectedCard</code> và <code>secondSelectedCard</code>.</li>
<li><strong>Nếu trùng khớp (Match):</strong>
<ul>
<li>Gọi <code>HandleMatch();</code></li>
<li>Gọi <code>PlaySound(matchSuccessSound);</code></li>
<li>Reset <code>firstSelectedCard</code>, <code>secondSelectedCard</code> về <code>null</code>.</li>
<li><code>canPlayerClick = true;</code></li>
</ul>
</li>
<li><strong>Nếu không trùng khớp (Mismatch):</strong>
<ul>
<li>Gọi <code>PlaySound(matchFailSound);</code></li>
<li>Gọi <code>StartCoroutine(HideMismatchAfterDelay());</code> -&gt; Dùng Coroutine để tạo độ trễ.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Hàm <code>void HandleMatch()</code>:</strong>
<ul>
<li>Đánh dấu <code>isMatched = true</code> cho cả hai thẻ.</li>
<li><code>pairsFound++;</code></li>
<li>Gọi <code>UpdateScore(10);</code> (hoặc điểm tùy ý).</li>
<li>Gọi <code>CheckWinCondition();</code></li>
</ul>
</li>
<li><strong>Hàm <code>IEnumerator HideMismatchAfterDelay()</code> (Giới thiệu Coroutine - có thể thay bằng cách khác nếu phức tạp):</strong>
<ul>
<li><code>yield return new WaitForSeconds(delayBeforeHide);</code></li>
<li>Gọi <code>FlipCard(firstSelectedCard, false);</code> -&gt; Úp thẻ 1 lại.</li>
<li>Gọi <code>FlipCard(secondSelectedCard, false);</code> -&gt; Úp thẻ 2 lại.</li>
<li>Reset <code>firstSelectedCard</code>, <code>secondSelectedCard</code> về <code>null</code>.</li>
<li><code>canPlayerClick = true;</code></li>
</ul>
</li>
<li><strong>Hàm <code>void FlipCard(Card card, bool showFace)</code> (Buổi 1.4.6 - hàm có tham số):</strong>
<ul>
<li>Truy cập <code>SpriteRenderer</code> của thẻ và thay đổi <code>sprite</code> thành mặt trước (nếu <code>showFace</code> là true) hoặc mặt sau (nếu false).</li>
<li>Cập nhật trạng thái <code>isFlipped</code> của thẻ.</li>
</ul>
</li>
<li><strong>Hàm <code>void UpdateScore(int pointsToAdd)</code> (Buổi 1.4.6 - hàm có tham số):</strong>
<ul>
<li><code>score += pointsToAdd;</code></li>
<li>Cập nhật <code>scoreText.text = "Score: " + score;</code></li>
</ul>
</li>
<li><strong>Hàm <code>void CheckWinCondition()</code> (Buổi 1.4.6 - hàm trả về bool hoặc kiểm tra trực tiếp):</strong>
<ul>
<li>Nếu <code>pairsFound == totalPairs</code>:
<ul>
<li>Hiển thị <code>winPanel</code>.</li>
<li>Gọi <code>PlaySound(gameWinSound);</code></li>
<li>(Tùy chọn) Dừng nhạc nền.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Hàm <code>void PlaySound(AudioClip clip)</code> (Hàm tiện ích - Buổi 1.4.2, 1.4.6):</strong>
<ul>
<li>Tìm <code>AudioSource</code> (ví dụ: trên <code>AudioManager</code>) và gọi <code>audioSource.PlayOneShot(clip);</code></li>
</ul>
</li>
<li><strong>(Các hàm cho nút trên WinPanel):</strong> <code>public void RestartGame()</code>, <code>public void GoToMenu()</code>.</li>
</ul>
</li>
<li>
<p><strong><code>Card.cs</code> (Gắn vào <code>CardPrefab</code>):</strong></p>
<ul>
<li><strong>Biến thành viên:</strong>
<ul>
<li><code>public int cardID;</code> (Hoặc <code>public Sprite cardSymbol;</code>) -&gt; Được gán bởi <code>BoardManager</code>.</li>
<li><code>public bool isMatched = false;</code></li>
<li><code>public bool isFlipped = false;</code></li>
<li><code>private SpriteRenderer spriteRenderer;</code></li>
<li><code>public Sprite cardBackSprite;</code></li>
<li><code>public Sprite cardFaceSprite;</code> -&gt; Được gán bởi <code>BoardManager</code>.</li>
<li><code>private BoardManager boardManager;</code></li>
</ul>
</li>
<li><strong>Hàm <code>Awake()</code> / <code>Start()</code>:</strong>
<ul>
<li>Lấy component <code>spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();</code>.</li>
<li>Tìm <code>boardManager = FindObjectOfType&lt;BoardManager&gt;();</code> (Cách đơn giản, có thể tối ưu).</li>
<li><code>spriteRenderer.sprite = cardBackSprite;</code> (Đảm bảo thẻ úp lúc đầu).</li>
</ul>
</li>
<li><strong>Hàm <code>OnMouseDown()</code> (Unity tự động gọi khi click vào Collider):</strong>
<ul>
<li>Nếu thẻ chưa được khớp (<code>!isMatched</code>) và chưa được lật (<code>!isFlipped</code>):
<ul>
<li>Gọi <code>boardManager.CardSelected(this);</code> -&gt; Thông báo cho <code>BoardManager</code> biết thẻ này được chọn.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Hàm <code>public void Setup(Sprite faceSprite, BoardManager manager)</code> (Để <code>BoardManager</code> gọi khi tạo thẻ):</strong>
<ul>
<li><code>cardFaceSprite = faceSprite;</code></li>
<li><code>boardManager = manager;</code></li>
<li>// Gán cardID nếu dùng ID thay vì Sprite để so sánh.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>MenuController.cs</code> (Gắn vào GameObject trong <code>MenuScene</code>):</strong></p>
<ul>
<li><strong>Hàm <code>public void PlayGame()</code>:</strong>
<ul>
<li><code>UnityEngine.SceneManagement.SceneManager.LoadScene("GameplayScene");</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>AudioManager.cs</code> (Tùy chọn, đơn giản hóa quản lý âm thanh):</strong></p>
<ul>
<li><code>public AudioSource bgmSource;</code></li>
<li><code>public AudioSource sfxSource;</code></li>
<li>// Các hàm để phát BGM, SFX.</li>
</ul>
</li>
</ul>
<h3 id="trọng-tâm-liên-kết-với-học-phần">5. Trọng tâm Liên kết với Học phần:</h3>
<ul>
<li><strong>Quản lý Tài nguyên:</strong> Rõ ràng qua việc chuẩn bị Sprites, Audio, sử dụng Asset Store, Package Manager.</li>
<li><strong>Lập trình C# &amp; Hàm/Phương thức:</strong>
<ul>
<li>Sử dụng nhiều hàm <code>void</code> để chia nhỏ logic (<code>SetupBoard</code>, <code>CheckForMatch</code>, <code>HandleMatch</code>, <code>UpdateScore</code>, <code>CheckWinCondition</code>).</li>
<li>Sử dụng hàm có tham số (<code>CardSelected(Card card)</code>, <code>FlipCard(Card card, bool showFace)</code>, <code>UpdateScore(int pointsToAdd)</code>, <code>PlaySound(AudioClip clip)</code>).</li>
<li>Có thể có hàm trả về giá trị (ví dụ, sửa <code>CheckWinCondition</code> thành <code>bool IsGameWon()</code>).</li>
<li>Ứng dụng biến thành viên và biến cục bộ.</li>
<li>Sử dụng <code>if/else</code> để kiểm tra điều kiện.</li>
<li>Ứng dụng <code>UnityEngine.Random</code> để xáo trộn thẻ.</li>
<li>Sử dụng Coroutine (<code>IEnumerator</code>) để tạo độ trễ (nâng cao hơn một chút nhưng hữu ích).</li>
</ul>
</li>
<li><strong>UI &amp; Tương tác:</strong> Tạo UI cơ bản, xử lý click chuột (<code>OnMouseDown</code> hoặc Raycast), cập nhật UI Text.</li>
<li><strong>Luồng Game:</strong> Quản lý việc chuyển Scene (<code>SceneManager</code>).</li>
</ul>
<h2 id="giáo-án-chi-tiết">Giáo án chi tiết</h2>
<h3 id="giáo-án-buổi-học-1.4.1-giới-thiệu-học-phần-ý-tưởng-game--cấu-trúc-dự-án">Giáo án Buổi học 1.4.1: Giới thiệu Học phần, Ý tưởng Game &amp; Cấu trúc Dự án</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, bắt đầu học C# trong học phần này.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS trình bày được mục tiêu chính của Học phần 1.4, bao gồm việc quản lý tài nguyên và bắt đầu lập trình C# với hàm/phương thức.</li>
<li>HS tham gia phác thảo ý tưởng và luồng chơi cơ bản cho dự án game “Puzzle Quest”.</li>
<li>HS tạo được một project Unity mới sử dụng template 2D thông qua Unity Hub.</li>
<li>HS tạo được cấu trúc thư mục cơ bản trong cửa sổ Project để tổ chức tài nguyên hiệu quả.</li>
<li>HS tạo và lưu được các Scene đơn giản (ví dụ: Menu, Gameplay).</li>
<li>HS nhận biết và nêu được chức năng chính của các cửa sổ cơ bản trong Unity Editor (Hierarchy, Scene, Game, Inspector, Project, Console).</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity Hub.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Thiết lập Dự án Puzzle Quest &amp; Khám phá Unity Editor” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>Bảng trắng hoặc công cụ ghi chú kỹ thuật số để brainstorming ý tưởng game.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Thiết lập Dự án Puzzle Quest &amp; Khám phá Unity Editor"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Chào mừng bạn đến với Học phần 4! Trong học phần này, chúng ta sẽ xây dựng một game giải đố 2D tên là “Puzzle Quest”, tập trung vào việc quản lý tài nguyên (hình ảnh, âm thanh) và đặc biệt là bắt đầu viết code bằng ngôn ngữ C# để tạo ra gameplay. Bài hướng dẫn này sẽ giúp bạn thiết lập project ban đầu và làm quen lại với giao diện Unity.</li>
<li><strong>Bước 1: Mở Unity Hub:</strong>
<ul>
<li>Tìm và mở ứng dụng Unity Hub trên máy tính của bạn.</li>
<li><em>Hình ảnh minh họa giao diện Unity Hub.</em></li>
</ul>
</li>
<li><strong>Bước 2: Tạo Project Unity Mới:</strong>
<ul>
<li>Trong Unity Hub, nhấp vào nút “New project”.</li>
<li>Trong cửa sổ “Create a new project with Unity”:
<ul>
<li>Chọn tab “All templates”.</li>
<li>Chọn template “2D Core”.</li>
<li>Ở phần “Project Settings” bên phải:
<ul>
<li>Đặt “Project name” là <code>PuzzleQuest_TenCuaBan</code> (ví dụ: <code>PuzzleQuest_AnNguyen</code>).</li>
<li>Chọn “Location” để lưu project (ví dụ: một thư mục riêng cho các dự án Unity).</li>
</ul>
</li>
<li>Nhấp vào nút “Create project”.</li>
</ul>
</li>
<li>Chờ một chút để Unity tạo project mới và mở Unity Editor.</li>
<li><em>Hình ảnh minh họa các bước tạo project.</em></li>
</ul>
</li>
<li><strong>Bước 3: Khám phá Giao diện Unity Editor:</strong>
<ul>
<li>Khi Unity Editor mở ra, bạn sẽ thấy nhiều cửa sổ khác nhau. Đây là không gian làm việc chính của chúng ta.</li>
<li><strong>Quan trọng:</strong> Nếu giao diện của bạn trông khác, bạn có thể đặt lại về mặc định bằng cách vào <code>Window</code> -&gt; <code>Layouts</code> -&gt; <code>Default</code>.</li>
<li><em>Hình ảnh minh họa giao diện Unity Editor mặc định, có chú thích các cửa sổ chính.</em></li>
</ul>
</li>
<li><strong>Bước 4: Tìm hiểu Các Cửa sổ Chính:</strong>
<ul>
<li>Hãy dành vài phút để xác định vị trí và tìm hiểu chức năng sơ bộ của các cửa sổ sau:
<ul>
<li><strong>Hierarchy:</strong> Liệt kê tất cả các đối tượng (GameObjects) hiện có trong Scene đang mở (ví dụ: Main Camera). Giống như danh sách các diễn viên trên sân khấu.</li>
<li><strong>Scene View:</strong> Cửa sổ chính để bạn nhìn và sắp xếp các đối tượng trong không gian 2D/3D. Bạn có thể di chuyển, xoay, thay đổi kích thước đối tượng tại đây.</li>
<li><strong>Game View:</strong> Mô phỏng những gì người chơi sẽ thấy khi game chạy. Nhấn nút Play (hình tam giác) ở thanh công cụ trên cùng để xem trước game trong cửa sổ này. Nhấn Play lần nữa để dừng.</li>
<li><strong>Inspector:</strong> Hiển thị thông tin chi tiết, các thuộc tính (Properties) và các thành phần (Components) của đối tượng hoặc tài nguyên bạn đang chọn trong Hierarchy hoặc Project. Đây là nơi bạn tùy chỉnh đối tượng.</li>
<li><strong>Project Window:</strong> Hiển thị tất cả các file và thư mục tài nguyên (Assets) của dự án (hình ảnh, âm thanh, scripts, scenes…). Giống như kho chứa đạo cụ và kịch bản.</li>
<li><strong>Console:</strong> Hiển thị các thông báo, cảnh báo hoặc lỗi từ Unity hoặc từ code bạn viết (sẽ dùng rất nhiều khi lập trình!).</li>
</ul>
</li>
<li>Hãy thử nhấp vào “Main Camera” trong Hierarchy và xem thông tin của nó thay đổi trong Inspector.</li>
</ul>
</li>
<li><strong>Bước 5: Tổ chức Thư mục Dự án:</strong>
<ul>
<li>Một dự án có tổ chức sẽ dễ quản lý hơn rất nhiều. Trong cửa sổ <strong>Project</strong>, nhấp chuột phải vào vùng trống trong mục “Assets” -&gt; <code>Create</code> -&gt; <code>Folder</code>.</li>
<li>Tạo các thư mục sau và đặt tên chính xác:
<ul>
<li><code>_Scenes</code> (Dấu gạch dưới <code>_</code> giúp thư mục luôn nổi lên trên)</li>
<li><code>_Scripts</code></li>
<li><code>_Sprites</code></li>
<li><code>_Audio</code></li>
<li><code>_Prefabs</code> (Sẽ tìm hiểu sau)</li>
</ul>
</li>
<li>Việc tạo cấu trúc này ngay từ đầu là một thói quen tốt.</li>
<li><em>Hình ảnh minh họa cửa sổ Project với các thư mục vừa tạo.</em></li>
</ul>
</li>
<li><strong>Bước 6: Tạo và Lưu Scene:</strong>
<ul>
<li>Scene trong Unity giống như một màn chơi hoặc một màn hình riêng biệt (ví dụ: menu chính, màn chơi 1).</li>
<li>Vào menu <code>File</code> -&gt; <code>New Scene</code>.</li>
<li>Chọn “Basic 2D” (hoặc tương tự) và nhấn “Create”.</li>
<li>Một Scene mới trống sẽ được tạo. Ngay lập tức, hãy lưu nó lại: Vào menu <code>File</code> -&gt; <code>Save As...</code>.</li>
<li>Trong cửa sổ lưu file, điều hướng vào thư mục <code>_Scenes</code> bạn vừa tạo.</li>
<li>Đặt tên file là <code>MenuScene</code> và nhấn “Save”.</li>
<li>Lặp lại quy trình: <code>File</code> -&gt; <code>New Scene</code> -&gt; <code>Create</code> -&gt; <code>File</code> -&gt; <code>Save As...</code> -&gt; vào thư mục <code>_Scenes</code> -&gt; đặt tên là <code>GameplayScene</code> -&gt; “Save”.</li>
<li>Bây giờ bạn đã có 2 scene cơ bản trong thư mục <code>_Scenes</code>. Bạn có thể nhấp đúp vào tên scene trong cửa sổ Project để chuyển đổi giữa chúng.</li>
</ul>
</li>
<li><strong>Kết luận:</strong> Bạn đã hoàn tất việc thiết lập project “Puzzle Quest” ban đầu và làm quen lại với các cửa sổ làm việc chính của Unity. Project của bạn đã sẵn sàng cho các bước tiếp theo trong việc thêm tài nguyên và lập trình!</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 15 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chào mừng HS đến với Học phần 1.4. Giới thiệu chủ đề chính: Quản lý tài nguyên và bắt đầu hành trình lập trình game với C# thông qua dự án “Puzzle Quest”.</li>
<li>Đặt câu hỏi gợi mở: “Các bạn thích chơi những game giải đố nào? Điều gì làm nên một game giải đố hay?”</li>
<li>Thảo luận nhanh về các thể loại game giải đố phổ biến (tìm cặp, xếp hình, giải mã…).</li>
<li>Giới thiệu dự án “Puzzle Quest”: “Chúng ta sẽ cùng nhau xây dựng một game giải đố 2D, nơi các bạn sẽ tự tay quản lý hình ảnh, âm thanh và viết code C# để tạo ra luật chơi!”</li>
<li>Nêu mục tiêu chính của buổi học hôm nay: Thiết lập môi trường làm việc (project Unity) và thống nhất ý tưởng ban đầu cho game.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo hứng thú, giới thiệu học phần và dự án, liên hệ với kinh nghiệm của HS, nêu rõ mục tiêu buổi học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 45 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Thiết lập Dự án Puzzle Quest &amp; Khám phá Unity Editor”</strong>.</li>
<li>HS thực hiện theo từng bước trong tài liệu trên máy của mình:
<ul>
<li>Mở Unity Hub.</li>
<li>Tạo project Unity 2D mới, đặt tên, chọn vị trí lưu.</li>
<li>Quan sát giao diện Editor khi mở ra.</li>
<li>Xác định vị trí và thử tương tác cơ bản với các cửa sổ: Hierarchy, Scene, Game (Play/Stop), Inspector, Project, Console.</li>
<li>Tạo cấu trúc thư mục chuẩn (<code>_Scenes</code>, <code>_Scripts</code>…) trong cửa sổ Project.</li>
<li>Tạo mới và lưu 2 Scene (<code>MenuScene</code>, <code>GameplayScene</code>) vào thư mục <code>_Scenes</code>.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Đi vòng quanh lớp, đảm bảo HS tạo project đúng template và vị trí.</li>
<li>Giải đáp thắc mắc về chức năng của từng cửa sổ khi HS khám phá.</li>
<li>Kiểm tra xem HS có tạo đúng cấu trúc thư mục và lưu Scene đúng nơi không.</li>
<li>Khuyến khích HS tự thử nhấn Play/Stop, chọn đối tượng để xem Inspector thay đổi.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp việc tạo project, làm quen chủ động với giao diện và các thao tác cơ bản, xây dựng nền tảng dự án ban đầu.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu giao diện Unity Editor của project vừa tạo lên màn hình.</li>
<li><strong>Review các cửa sổ:</strong> GV chỉ vào từng cửa sổ chính (Hierarchy, Scene, Game, Inspector, Project, Console) và yêu cầu HS nêu lại chức năng chính của nó dựa trên những gì vừa khám phá. GV bổ sung, làm rõ và nhấn mạnh vai trò của từng cửa sổ trong quá trình phát triển game.</li>
<li><strong>Tầm quan trọng của Tổ chức:</strong> GV giải thích tại sao việc tạo cấu trúc thư mục (<code>_Scenes</code>, <code>_Scripts</code>…) lại quan trọng cho các dự án lớn và phức tạp hơn sau này (dễ tìm kiếm, dễ quản lý, làm việc nhóm hiệu quả).</li>
<li><strong>Khái niệm Scene:</strong> Giải thích rõ hơn Scene là gì trong Unity, tại sao cần nhiều Scene (ví dụ: Menu, Màn chơi, Màn kết thúc). Cách chuyển đổi giữa các Scene đã lưu.</li>
<li><strong>Brainstorm ý tưởng “Puzzle Quest”:</strong> GV dẫn dắt buổi thảo luận nhanh để thống nhất ý tưởng cơ bản cho game:
<ul>
<li>Loại câu đố chính sẽ làm là gì? (Ví dụ: Thống nhất làm game Lật hình Ghi nhớ - Memory Match).</li>
<li>Luồng chơi cơ bản sẽ như thế nào? (Menu -&gt; Chọn màn (nếu có) -&gt; Chơi -&gt; Thắng -&gt; Quay lại Menu/Chơi lại).</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Củng cố hiểu biết về chức năng của giao diện Unity, nhấn mạnh tầm quan trọng của việc tổ chức project, làm rõ khái niệm Scene, và định hình ý tưởng gameplay cốt lõi cho dự án.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử nghiệm nhanh):</strong>
<ul>
<li>GV yêu cầu HS:
<ul>
<li>Thử nhấp đúp vào <code>MenuScene</code> và <code>GameplayScene</code> trong cửa sổ Project để chuyển đổi qua lại giữa chúng.</li>
<li>Trong cửa sổ Project, thử tạo thêm một thư mục tạm thời (ví dụ: <code>_Temp</code>) rồi xóa nó đi (chuột phải -&gt; Delete).</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giúp HS thực hành ngay thao tác chuyển Scene và quản lý thư mục cơ bản, củng cố kỹ năng vừa học.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh:</strong> GV yêu cầu HS mở project của mình và đảm bảo có đủ các thư mục (<code>_Scenes</code>, <code>_Scripts</code>…) và 2 file Scene (<code>MenuScene</code>, <code>GameplayScene</code>) trong thư mục <code>_Scenes</code>.</li>
<li><strong>Câu hỏi nhanh (Miệng):</strong>
<ol>
<li>Cửa sổ nào liệt kê các đối tượng có trong màn chơi hiện tại? (Hierarchy)</li>
<li>Cửa sổ nào hiển thị chi tiết của đối tượng đang được chọn? (Inspector)</li>
<li>Chúng ta tạo thư mục trong cửa sổ nào? (Project)</li>
<li>Làm thế nào để lưu một màn chơi? (File -&gt; Save / Save As…)</li>
<li>Ý tưởng game “Puzzle Quest” chúng ta vừa thống nhất là gì? (Game lật hình tìm cặp giống nhau).</li>
</ol>
</li>
<li><strong>Quan sát:</strong> Mức độ hoàn thành các bước tạo project và thư mục/scene, khả năng trả lời câu hỏi về giao diện và ý tưởng game.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng thực hiện các thao tác cơ bản, mức độ nhận biết giao diện và nắm bắt được ý tưởng dự án của HS.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt: Hôm nay chúng ta đã khởi động Học phần 4, thiết lập thành công project “Puzzle Quest”, làm quen lại với môi trường Unity và xác định ý tưởng cốt lõi cho game.</li>
<li>Nhấn mạnh: Việc tổ chức project ngăn nắp ngay từ đầu rất quan trọng.</li>
<li>Giới thiệu buổi học tiếp theo: “Buổi sau, chúng ta sẽ bắt đầu đưa ‘sự sống’ vào game bằng cách tìm hiểu và thêm Âm thanh - Nhạc nền và Hiệu ứng!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.2-quản-lý-âm-thanh-cơ-bản">Giáo án Buổi học 1.4.2: Quản lý Âm thanh Cơ bản</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.1 (thiết lập project, làm quen giao diện).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS giải thích được vai trò cơ bản của <code>AudioListener</code> và <code>AudioSource</code> trong Unity.</li>
<li>HS tìm và nhập khẩu được các file âm thanh (BGM, SFX) vào dự án Unity và quản lý chúng trong thư mục <code>_Audio</code>.</li>
<li>HS tạo được GameObject quản lý âm thanh và cấu hình component <code>AudioSource</code> để phát nhạc nền (BGM) tự động và lặp lại.</li>
<li>HS cấu hình được một <code>AudioSource</code> khác để chuẩn bị phát hiệu ứng âm thanh (SFX).</li>
<li>HS viết được một script C# <em>cực kỳ đơn giản</em> để kích hoạt phát SFX khi nhấn một phím nhất định bằng cách sử dụng <code>GetComponent</code>, <code>Input.GetKeyDown</code> và <code>AudioSource.PlayOneShot()</code>.</li>
<li>HS phân biệt được mục đích sử dụng cơ bản của <code>Play On Awake</code>, <code>Loop</code> và phương thức <code>PlayOneShot()</code>.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án “Puzzle Quest” từ buổi 1.4.1.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li>Kết nối Internet để tìm và tải file âm thanh.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Thêm Nhạc nền và Hiệu ứng Âm thanh vào Puzzle Quest” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Một vài trang web gợi ý nguồn âm thanh miễn phí (ví dụ: <a href="http://freesound.org">freesound.org</a>, <a href="http://zapsplat.com">zapsplat.com</a> - <em>nhấn mạnh việc kiểm tra license</em>).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Thêm Nhạc nền và Hiệu ứng Âm thanh vào Puzzle Quest"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li>
<p><strong>Giới thiệu:</strong> Âm thanh là một phần không thể thiếu để tạo nên trải nghiệm game hấp dẫn. Hôm nay, chúng ta sẽ học cách thêm nhạc nền (Background Music - BGM) và hiệu ứng âm thanh (Sound Effects - SFX) vào game “Puzzle Quest”.</p>
</li>
<li>
<p><strong>Bước 1: Tìm và Chuẩn bị File Âm thanh:</strong></p>
<ul>
<li>Sử dụng trình duyệt web, truy cập một trang cung cấp âm thanh miễn phí (GV sẽ gợi ý).</li>
<li>Tìm và tải về:
<ul>
<li>1 file nhạc nền phù hợp với game giải đố (ưu tiên định dạng <code>.mp3</code> hoặc <code>.ogg</code>, có thể lặp lại tốt).</li>
<li>Khoảng 2-3 file hiệu ứng âm thanh ngắn (định dạng <code>.wav</code> thường tốt cho SFX): ví dụ tiếng lật thẻ, tiếng tìm đúng cặp, tiếng tìm sai cặp.</li>
</ul>
</li>
<li><strong>Quan trọng:</strong> Đọc kỹ giấy phép (license) của file âm thanh để đảm bảo bạn được phép sử dụng chúng trong dự án của mình.</li>
<li>Lưu các file âm thanh tải về vào một thư mục dễ tìm trên máy tính.</li>
</ul>
</li>
<li>
<p><strong>Bước 2: Nhập khẩu (Import) Âm thanh vào Unity:</strong></p>
<ul>
<li>Quay lại Unity Editor, mở cửa sổ <strong>Project</strong>.</li>
<li>Điều hướng vào thư mục <code>_Audio</code> bạn đã tạo ở buổi trước.</li>
<li>Kéo thả các file âm thanh vừa tải về từ thư mục trên máy tính vào thư mục <code>_Audio</code> trong cửa sổ Project của Unity.</li>
<li>Unity sẽ tự động xử lý và nhập khẩu các file này. Bạn có thể nhấp vào một file âm thanh trong cửa sổ Project để xem các tùy chọn Import Settings của nó trong Inspector (chúng ta sẽ tìm hiểu kỹ hơn sau).</li>
<li><em>Hình ảnh minh họa kéo thả file vào thư mục _Audio.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 3: Tìm hiểu về AudioListener và AudioSource:</strong></p>
<ul>
<li><strong>AudioListener:</strong> Đóng vai trò như “đôi tai” trong game, thường được tự động gắn sẵn vào “Main Camera”. Chỉ cần <em>một</em> AudioListener trong mỗi Scene để nghe được âm thanh.</li>
<li><strong>AudioSource:</strong> Đóng vai trò như “cái loa”, là component bạn gắn vào GameObject để <em>phát</em> ra âm thanh. Bạn có thể có nhiều AudioSource trong Scene. Nó cần một <code>AudioClip</code> (file âm thanh bạn vừa nhập) để phát.</li>
</ul>
</li>
<li>
<p><strong>Bước 4: Tạo GameObject Quản lý Âm thanh:</strong></p>
<ul>
<li>Trong cửa sổ <strong>Hierarchy</strong>, nhấp chuột phải -&gt; <code>Create Empty</code>.</li>
<li>Đặt tên cho GameObject mới này là <code>AudioManager</code>. Đây là nơi chúng ta sẽ quản lý các nguồn phát âm thanh chính.</li>
</ul>
</li>
<li>
<p><strong>Bước 5: Thêm Nhạc nền (BGM):</strong></p>
<ul>
<li>Chọn <code>AudioManager</code> trong Hierarchy.</li>
<li>Trong <strong>Inspector</strong>, nhấn nút “Add Component”.</li>
<li>Tìm và chọn “Audio Source”.</li>
<li>Một component Audio Source sẽ được thêm vào <code>AudioManager</code>. Hãy cấu hình nó cho BGM:
<ul>
<li><strong>AudioClip:</strong> Kéo thả file nhạc nền bạn đã nhập từ thư mục <code>_Audio</code> vào ô này.</li>
<li><strong>Play On Awake:</strong> Đánh dấu tick vào ô này (để nhạc tự phát khi game bắt đầu).</li>
<li><strong>Loop:</strong> Đánh dấu tick vào ô này (để nhạc lặp lại sau khi phát hết).</li>
<li>(Tùy chọn) Điều chỉnh <strong>Volume</strong> (âm lượng) nếu muốn.</li>
</ul>
</li>
<li><em>Hình ảnh minh họa cấu hình AudioSource cho BGM.</em></li>
<li><strong>Kiểm tra:</strong> Nhấn nút Play. Bạn có nghe thấy nhạc nền không? Nhấn Play lần nữa để dừng.</li>
</ul>
</li>
<li>
<p><strong>Bước 6: Chuẩn bị cho Hiệu ứng Âm thanh (SFX):</strong></p>
<ul>
<li>Chọn lại <code>AudioManager</code>.</li>
<li>Nhấn “Add Component” lần nữa, tìm và thêm một “Audio Source” <em>thứ hai</em>. Component này sẽ dùng để phát SFX.</li>
<li><strong>Quan trọng:</strong> Đối với AudioSource này, <em>không</em> đánh dấu tick vào “Play On Awake” và “Loop”. Chúng ta muốn tự kích hoạt SFX khi cần.</li>
<li>Để dễ phân biệt, bạn có thể nhấp vào tên “Audio Source” trong Inspector và đổi tên nó (ví dụ: “SFX Source”).</li>
<li><em>Hình ảnh minh họa thêm AudioSource thứ hai cho SFX.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 7: Tạo Script Đơn giản để Kích hoạt SFX:</strong></p>
<ul>
<li>Trong cửa sổ <strong>Project</strong>, vào thư mục <code>_Scripts</code>.</li>
<li>Chuột phải -&gt; <code>Create</code> -&gt; <code>C# Script</code>. Đặt tên là <code>SoundTester</code>.</li>
<li>Nhấp đúp vào script <code>SoundTester</code> để mở nó trong trình soạn thảo code.</li>
<li>Xóa nội dung mặc định và thay bằng code sau:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SoundTester</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> AudioClip soundToPlay<span class="token punctuation">;</span> <span class="token comment">// Biến public để kéo thả file SFX vào từ Inspector</span>
    <span class="token keyword">private</span> AudioSource sfxAudioSource<span class="token punctuation">;</span> <span class="token comment">// Biến để lưu trữ AudioSource phát SFX</span>

    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Tìm AudioSource phát SFX trên cùng GameObject này</span>
        <span class="token comment">// Lưu ý: Giả định script này gắn cùng nơi có AudioSource SFX</span>
        <span class="token comment">// Nếu không, cần cách tìm khác (sẽ học sau)</span>
        <span class="token comment">// Chúng ta sẽ tìm theo tên component để phân biệt với BGM Source</span>
        AudioSource<span class="token punctuation">[</span><span class="token punctuation">]</span> sources <span class="token operator">=</span> <span class="token generic-method function">GetComponents<span class="token punctuation">&lt;</span>AudioSource<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">foreach</span> <span class="token punctuation">(</span>AudioSource source <span class="token keyword">in</span> sources<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// Tìm AudioSource *không* bật Loop (giả định đó là SFX source)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>source<span class="token punctuation">.</span>loop<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                sfxAudioSource <span class="token operator">=</span> source<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// Dừng tìm khi đã thấy</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

         <span class="token keyword">if</span> <span class="token punctuation">(</span>sfxAudioSource <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
             Debug<span class="token punctuation">.</span><span class="token function">LogError</span><span class="token punctuation">(</span><span class="token string">"SFX AudioSource not found on this GameObject!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Kiểm tra nếu người dùng nhấn phím Space</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token function">GetKeyDown</span><span class="token punctuation">(</span>KeyCode<span class="token punctuation">.</span>Space<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// Kiểm tra xem soundToPlay đã được gán và sfxAudioSource tồn tại chưa</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>soundToPlay <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> sfxAudioSource <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment">// Phát âm thanh một lần</span>
                sfxAudioSource<span class="token punctuation">.</span><span class="token function">PlayOneShot</span><span class="token punctuation">(</span>soundToPlay<span class="token punctuation">)</span><span class="token punctuation">;</span>
                Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Played SFX: "</span> <span class="token operator">+</span> soundToPlay<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// In ra Console</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                 Debug<span class="token punctuation">.</span><span class="token function">LogWarning</span><span class="token punctuation">(</span><span class="token string">"Sound to play is not assigned or SFX source not found!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích nhanh:</strong>
<ul>
<li><code>public AudioClip soundToPlay;</code>: Cho phép bạn chọn file SFX trong Inspector.</li>
<li><code>GetComponent&lt;AudioSource&gt;()</code>: Tìm component Audio Source (ở đây dùng cách nâng cao hơn chút để tìm đúng cái SFX).</li>
<li><code>Update()</code>: Hàm chạy mỗi khung hình.</li>
<li><code>Input.GetKeyDown(KeyCode.Space)</code>: Kiểm tra xem phím Space có vừa được nhấn xuống không.</li>
<li><code>sfxAudioSource.PlayOneShot(soundToPlay);</code>: Phát file âm thanh (<code>soundToPlay</code>) một lần qua <code>sfxAudioSource</code>. <code>PlayOneShot</code> rất tốt cho SFX vì nó không ngắt âm thanh đang phát.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 8: Gắn Script và Gán Âm thanh:</strong></p>
<ul>
<li>Lưu script <code>SoundTester</code>. Quay lại Unity.</li>
<li>Kéo thả script <code>SoundTester</code> từ thư mục <code>_Scripts</code> vào GameObject <code>AudioManager</code> trong Hierarchy.</li>
<li>Chọn <code>AudioManager</code>. Trong Inspector, bạn sẽ thấy component <code>Sound Tester (Script)</code>.</li>
<li>Tìm ô “Sound To Play”. Kéo thả một file SFX (ví dụ: tiếng lật thẻ) từ thư mục <code>_Audio</code> vào ô này.</li>
<li><em>Hình ảnh minh họa gán AudioClip vào biến public của script.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 9: Kiểm tra SFX:</strong></p>
<ul>
<li>Mở cửa sổ <strong>Console</strong> (<code>Window</code> -&gt; <code>General</code> -&gt; <code>Console</code>).</li>
<li>Nhấn nút Play. Bạn vẫn nghe thấy BGM chứ?</li>
<li>Nhấn phím Space trên bàn phím. Bạn có nghe thấy tiếng SFX bạn vừa gán không? Đồng thời xem thông điệp trong Console.</li>
<li>Thử nhấn Space nhiều lần liên tiếp.</li>
<li>Nhấn Play lần nữa để dừng.</li>
</ul>
</li>
<li>
<p><strong>Kết luận:</strong> Bạn đã thành công thêm cả nhạc nền và hiệu ứng âm thanh cơ bản vào dự án! Bạn đã biết cách cấu hình <code>AudioSource</code> và cách kích hoạt âm thanh bằng một script đơn giản.</p>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chiếu một đoạn gameplay ngắn (có thể là video hoặc GIF) của một game giải đố đơn giản <em>không có âm thanh</em>. Hỏi HS cảm nhận.</li>
<li>Chiếu lại đoạn đó <em>có thêm âm thanh</em> (nhạc nền nhẹ nhàng, tiếng click, tiếng hiệu ứng đúng/sai). Hỏi HS sự khác biệt, vai trò của âm thanh.</li>
<li>GV: “Game của chúng ta ở buổi trước vẫn còn ‘im lặng’. Hôm nay, chúng ta sẽ thổi hồn vào nó bằng cách thêm những yếu tố quan trọng: Nhạc nền (BGM) và Hiệu ứng âm thanh (SFX)!”</li>
<li>Giới thiệu mục tiêu: Tìm hiểu cách Unity xử lý âm thanh và thực hành thêm BGM, SFX vào dự án “Puzzle Quest”.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Nhấn mạnh tầm quan trọng của âm thanh trong game, tạo sự hứng thú và liên kết với dự án đang làm, giới thiệu mục tiêu cụ thể của buổi học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 45 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Thêm Nhạc nền và Hiệu ứng Âm thanh vào Puzzle Quest”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li>Tìm và tải các file âm thanh BGM và SFX cần thiết (GV có thể cung cấp sẵn một bộ nhỏ hoặc hướng dẫn tìm nhanh).</li>
<li>Import các file âm thanh vào thư mục <code>_Audio</code>.</li>
<li>Tạo GameObject <code>AudioManager</code>.</li>
<li>Thêm và cấu hình AudioSource đầu tiên cho BGM (<code>Play On Awake</code>, <code>Loop</code>).</li>
<li>Play test để nghe BGM.</li>
<li>Thêm AudioSource thứ hai cho SFX (không <code>Play On Awake</code>, không <code>Loop</code>).</li>
<li>Tạo script <code>SoundTester</code>, copy/paste code mẫu.</li>
<li>Gắn script <code>SoundTester</code> vào <code>AudioManager</code>.</li>
<li>Gán một file SFX vào biến <code>Sound To Play</code> trong Inspector.</li>
<li>Mở Console, Play test và nhấn phím Space để nghe SFX và xem log.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp HS tìm nguồn âm thanh phù hợp và nhắc nhở về license.</li>
<li>Hỗ trợ import file, tạo GameObject/Component.</li>
<li>Kiểm tra cấu hình AudioSource (đúng BGM, đúng SFX).</li>
<li>Giúp HS nếu gặp lỗi khi copy/paste hoặc gắn script/gán AudioClip.</li>
<li>Đảm bảo HS mở Console để xem Debug.Log.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp quy trình tìm, nhập, cấu hình và kích hoạt âm thanh cơ bản trong Unity, làm quen với AudioSource và script đơn giản để tương tác.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu lại Inspector của <code>AudioManager</code> và script <code>SoundTester</code>.</li>
<li>Giải thích rõ ràng các khái niệm và thành phần chính:
<ul>
<li><strong>AudioListener vs AudioSource:</strong> Nhấn mạnh vai trò “tai nghe” và “loa”.</li>
<li><strong>AudioSource Properties:</strong> Giải thích lại ý nghĩa của <code>AudioClip</code>, <code>Play On Awake</code>, <code>Loop</code>, <code>Volume</code> dựa trên thực hành của HS.</li>
<li><strong>Multiple AudioSources:</strong> Tại sao lại dùng 2 AudioSource trên <code>AudioManager</code>? (Để quản lý BGM và SFX riêng, tránh xung đột cài đặt loop/play on awake).</li>
<li><strong>Script <code>SoundTester</code>:</strong>
<ul>
<li><code>public AudioClip soundToPlay;</code>: Giải thích biến public và cách nó hiện ra trong Inspector để gán dữ liệu.</li>
<li><code>GetComponent&lt;AudioSource&gt;()</code> (và cách tìm cụ thể trong code mẫu): Cách script lấy được tham chiếu đến component cần điều khiển.</li>
<li><code>Update()</code> và <code>Input.GetKeyDown()</code>: Cách bắt sự kiện nhấn phím (đây là phần C# đầu tiên HS thực sự dùng để tạo tương tác).</li>
<li><code>PlayOneShot()</code>: Giải thích tại sao nó phù hợp cho SFX (không ngắt tiếng, tiện lợi). So sánh nhanh với <code>Play()</code> (có thể tự ngắt nếu gọi lại).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Củng cố kiến thức lý thuyết về các component âm thanh, giải thích các thuộc tính quan trọng, và làm rõ cách script C# đơn giản tương tác với AudioSource để phát âm thanh theo sự kiện.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử nghiệm nhanh):</strong>
<ul>
<li>GV yêu cầu HS:
<ul>
<li>Chọn <code>AudioManager</code>, trong Inspector của AudioSource BGM, thử thay đổi <code>Volume</code> và <code>Pitch</code> khi game đang chạy và nghe sự khác biệt.</li>
<li>Trong Inspector của script <code>SoundTester</code>, kéo thả một file SFX <em>khác</em> vào ô “Sound To Play”. Chạy game và nhấn Space để nghe âm thanh mới.</li>
<li>(Thử thách nhỏ nếu có thời gian) Thử thay đổi <code>KeyCode.Space</code> trong script thành một phím khác (ví dụ <code>KeyCode.A</code>) và kiểm tra lại.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS tự khám phá các thuộc tính, thấy được sự linh hoạt của việc gán dữ liệu qua Inspector và thay đổi code đơn giản.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh:</strong> GV yêu cầu HS chạy game, đảm bảo nghe được BGM. Yêu cầu HS nhấn phím Space và xác nhận nghe được SFX và thấy log trong Console. Xem nhanh Inspector của <code>AudioManager</code> để đảm bảo có 2 AudioSource và script <code>SoundTester</code> với AudioClip đã gán.</li>
<li><strong>Câu hỏi nhanh (Miệng):</strong>
<ol>
<li>Để nhạc nền tự chạy khi vào game, bạn tick vào ô nào? (<code>Play On Awake</code>)</li>
<li>Để nhạc nền lặp lại, bạn tick vào ô nào? (<code>Loop</code>)</li>
<li>Component nào dùng để <em>phát</em> âm thanh? (<code>AudioSource</code>)</li>
<li>Trong script, lệnh <code>Input.GetKeyDown(KeyCode.Space)</code> dùng để làm gì? (Kiểm tra phím Space có vừa được nhấn không)</li>
<li>Lệnh nào trong script dùng để phát một hiệu ứng âm thanh ngắn? (<code>PlayOneShot()</code>)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng cấu hình AudioSource cho BGM/SFX và hiểu biết cơ bản về cách kích hoạt âm thanh bằng script đơn giản.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt: Hôm nay chúng ta đã mang âm thanh vào thế giới “Puzzle Quest”, học cách thêm nhạc nền và hiệu ứng âm thanh, cũng như viết những dòng code C# đầu tiên để điều khiển chúng.</li>
<li>Nhấn mạnh: Âm thanh là yếu tố quan trọng, và việc quản lý nó bằng <code>AudioSource</code> và script là kỹ năng cơ bản.</li>
<li>Giới thiệu buổi học tiếp theo: “Chúng ta đã có âm thanh. Buổi sau, chúng ta sẽ khám phá cách tìm kiếm và quản lý các loại tài nguyên khác từ Unity Asset Store và Package Manager để làm game phong phú hơn!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.3-quản-lý-packages-và-assets">Giáo án Buổi học 1.4.3: Quản lý Packages và Assets</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.2 (thêm âm thanh cơ bản).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS giải thích được mục đích và cách sử dụng cơ bản của Unity Package Manager để quản lý các gói chức năng của Unity.</li>
<li>HS nhận biết được các nguồn package chính (Unity Registry, My Assets).</li>
<li>HS thực hành xem thông tin và cài đặt một package đơn giản từ Unity Registry (ví dụ: TextMeshPro nếu chưa có).</li>
<li>HS giải thích được mục đích của Unity Asset Store và cách truy cập nó.</li>
<li>HS thực hành tìm kiếm, “lấy” (Add to My Assets) và nhập (Import) một gói tài nguyên (asset pack) miễn phí từ Asset Store vào dự án.</li>
<li>HS thực hành kỹ năng tổ chức lại thư mục dự án sau khi nhập tài nguyên mới.</li>
<li>HS hiểu sơ bộ về khái niệm Prefab như một cách đóng gói và tái sử dụng GameObject (thông qua việc xem xét asset pack nhập về).</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án “Puzzle Quest” từ buổi 1.4.2.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li>Kết nối Internet ổn định để truy cập Package Manager và Asset Store.</li>
<li>Tài khoản Unity ID (cần thiết để sử dụng Asset Store - có thể tạo miễn phí, nên chuẩn bị trước hoặc hướng dẫn nhanh).</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Khám phá Kho báu: Package Manager và Asset Store” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Một vài gợi ý về asset pack 2D miễn phí phù hợp cho game giải đố trên Asset Store.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Khám phá Kho báu: Package Manager và Asset Store"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Unity không chỉ là một công cụ làm game, mà còn là một hệ sinh thái rộng lớn với nhiều tính năng mở rộng và tài nguyên sẵn có. Hôm nay, chúng ta sẽ khám phá hai “kho báu” quan trọng: <strong>Package Manager</strong> (để quản lý các gói chức năng của Unity) và <strong>Asset Store</strong> (nơi tìm kiếm hàng ngàn tài nguyên làm game).</li>
<li><strong>Phần 1: Unity Package Manager - Quản lý Chức năng Mở rộng</strong>
<ul>
<li><strong>Mục đích:</strong> Package Manager giúp bạn thêm, xóa, và cập nhật các “gói” (packages) chức năng do Unity hoặc bên thứ ba phát triển. Các gói này có thể là công cụ mới, hệ thống vật lý 2D/3D, các tính năng đồ họa nâng cao, hỗ trợ nền tảng, v.v.</li>
<li><strong>Cách mở:</strong> Vào menu <code>Window</code> -&gt; <code>Package Manager</code>.</li>
<li><em>Hình ảnh minh họa cửa sổ Package Manager.</em></li>
<li><strong>Khám phá Giao diện:</strong>
<ul>
<li><strong>Nút Dropdown ở góc trên bên trái:</strong> Cho phép bạn lọc các package theo nguồn:
<ul>
<li><code>In Project</code>: Các package hiện đang được cài đặt trong dự án của bạn.</li>
<li><code>Unity Registry</code>: Danh sách các package chính thức được cung cấp và hỗ trợ bởi Unity. Đây là nguồn đáng tin cậy.</li>
<li><code>My Assets</code>: Các package bạn đã “lấy” (mua hoặc nhận miễn phí) từ Asset Store.</li>
</ul>
</li>
<li><strong>Danh sách Packages:</strong> Hiển thị tên, phiên bản, trạng thái (Installed, Install, Update).</li>
<li><strong>Khung bên phải:</strong> Hiển thị thông tin chi tiết về package đang chọn (mô tả, dependencies, các phiên bản).</li>
</ul>
</li>
<li><strong>Thực hành:</strong>
<ul>
<li>Chọn <code>Unity Registry</code> từ dropdown.</li>
<li>Tìm package có tên “TextMeshPro” (dùng để hiển thị chữ đẹp và linh hoạt hơn Text thường).</li>
<li>Nếu trạng thái là “Install”, hãy nhấn nút “Install” và chờ quá trình cài đặt hoàn tất. (Nếu đã có thì bỏ qua bước cài).</li>
<li>Quan sát cách package mới xuất hiện trong danh sách <code>In Project</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Phần 2: Unity Asset Store - Kho Tài nguyên Khổng lồ</strong>
<ul>
<li><strong>Mục đích:</strong> Asset Store là một thị trường trực tuyến nơi bạn có thể tìm thấy gần như mọi thứ cần thiết để làm game: mô hình 3D, hình ảnh 2D (sprites), âm thanh, hiệu ứng, công cụ, scripts, và thậm chí cả các dự án game hoàn chỉnh. Có cả tài nguyên miễn phí và trả phí.</li>
<li><strong>Cách truy cập:</strong>
<ul>
<li>Cách 1: Vào menu <code>Window</code> -&gt; <code>Asset Store</code> (sẽ mở một tab trong Unity Editor). <em>Lưu ý: Tab này có thể sẽ bị loại bỏ trong các phiên bản Unity mới, ưu tiên cách 2.</em></li>
<li>Cách 2 (Khuyến nghị): Mở trình duyệt web và truy cập địa chỉ <code>assetstore.unity.com</code>. Đăng nhập bằng tài khoản Unity ID của bạn.</li>
</ul>
</li>
<li><strong>Đăng nhập:</strong> Bạn cần có tài khoản Unity ID (miễn phí) để “lấy” tài nguyên, kể cả tài nguyên miễn phí. Nếu chưa có, hãy tạo một tài khoản.</li>
<li><em>Hình ảnh minh họa giao diện Asset Store trên web.</em></li>
<li><strong>Thực hành Tìm kiếm và Lấy Asset:</strong>
<ul>
<li>Sử dụng thanh tìm kiếm trên Asset Store, gõ từ khóa liên quan đến game Puzzle Quest, ví dụ: “puzzle icons”, “card sprites”, “2d icons free”.</li>
<li>Sử dụng bộ lọc (Filters) bên trái để chọn “2D”, “Free Assets”.</li>
<li>Duyệt qua kết quả, nhấp vào một asset pack bạn thấy phù hợp (ví dụ: một bộ icon đơn giản).</li>
<li>Xem trang chi tiết của asset: đọc mô tả, xem hình ảnh/video, kiểm tra đánh giá và quan trọng nhất là <strong>đọc kỹ License</strong> (giấy phép sử dụng).</li>
<li>Nếu đồng ý, nhấp vào nút “Add to My Assets” (hoặc tên tương tự). Bạn có thể cần xác nhận lại.</li>
</ul>
</li>
<li><strong>Thực hành Nhập Asset vào Dự án:</strong>
<ul>
<li>Quay lại Unity Editor.</li>
<li>Mở <strong>Package Manager</strong> (<code>Window</code> -&gt; <code>Package Manager</code>).</li>
<li>Chọn nguồn <code>My Assets</code> từ dropdown. Bạn sẽ thấy asset pack mình vừa “lấy” xuất hiện trong danh sách.</li>
<li>Chọn asset pack đó.</li>
<li>Nhấn nút “Download” nếu nó chưa được tải về máy.</li>
<li>Sau khi tải xong, nhấn nút “Import”.</li>
<li>Một cửa sổ “Import Unity Package” sẽ hiện ra, liệt kê tất cả các file trong gói. Thông thường, bạn cứ để mặc định chọn tất cả và nhấn “Import”.</li>
<li>Chờ Unity nhập các file vào dự án.</li>
</ul>
</li>
<li><em>Hình ảnh minh họa các bước Import asset từ Package Manager.</em></li>
</ul>
</li>
<li><strong>Bước 4: Tổ chức Lại Dự án:</strong>
<ul>
<li>Sau khi Import, bạn sẽ thấy các thư mục và file mới xuất hiện trong cửa sổ <strong>Project</strong>. Thường thì chúng sẽ nằm trong một thư mục gốc theo tên của asset pack.</li>
<li><strong>Quan trọng:</strong> Để giữ dự án gọn gàng, hãy xem xét di chuyển các tài nguyên vừa nhập vào các thư mục tương ứng bạn đã tạo (<code>_Sprites</code>, <code>_Prefabs</code>, <code>_Audio</code>…).
<ul>
<li>Ví dụ: Nếu asset pack có các file ảnh PNG, hãy kéo thả chúng vào thư mục <code>_Sprites</code>.</li>
<li>Nếu asset pack có các Prefab (biểu tượng hình khối màu xanh), hãy kéo chúng vào thư mục <code>_Prefabs</code>.</li>
</ul>
</li>
<li><strong>Lưu ý về Prefabs:</strong> Hãy để ý các file có biểu tượng hình khối màu xanh. Đó là Prefabs - các GameObject đã được cấu hình sẵn (có thể chứa Sprite Renderer, Collider, Script…). Chúng rất hữu ích để tái sử dụng. Chúng ta sẽ tìm hiểu kỹ hơn về cách tạo và sử dụng Prefab sau.</li>
<li><em>Hình ảnh minh họa việc di chuyển file sau khi import.</em></li>
</ul>
</li>
<li><strong>Kết luận:</strong> Bạn đã học cách sử dụng Package Manager để quản lý chức năng và Asset Store để tìm kiếm, nhập tài nguyên. Việc biết cách tận dụng các công cụ này sẽ giúp bạn tiết kiệm rất nhiều thời gian và công sức khi làm game. Đừng quên luôn giữ cho thư mục dự án của bạn được tổ chức tốt!</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV đặt câu hỏi: “Khi làm game, chúng ta cần rất nhiều thứ: hình ảnh nhân vật, đồ vật, âm thanh, hiệu ứng, đôi khi là cả những công cụ hỗ trợ đặc biệt. Làm thế nào để có được những thứ đó mà không phải tự làm tất cả từ đầu?”</li>
<li>Gợi ý về việc sử dụng các tài nguyên/công cụ có sẵn.</li>
<li>GV giới thiệu: “Unity cung cấp cho chúng ta hai công cụ mạnh mẽ để mở rộng khả năng và tìm kiếm tài nguyên: Package Manager và Asset Store. Hôm nay chúng ta sẽ khám phá chúng!”</li>
<li>Nêu mục tiêu: Học cách dùng Package Manager để cài thêm tính năng cho Unity và dùng Asset Store để tìm, nhập tài nguyên (hình ảnh, âm thanh…) miễn phí cho dự án “Puzzle Quest”.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo sự tò mò về cách mở rộng Unity và tìm tài nguyên, liên kết với nhu cầu thực tế khi làm game, giới thiệu mục tiêu buổi học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 50 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Khám phá Kho báu: Package Manager và Asset Store”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li><strong>Package Manager:</strong>
<ul>
<li>Mở Package Manager.</li>
<li>Chuyển đổi qua lại giữa các nguồn (In Project, Unity Registry, My Assets).</li>
<li>Tìm và xem thông tin package TextMeshPro (hoặc package 2D khác).</li>
<li>Thực hiện cài đặt nếu chưa có.</li>
</ul>
</li>
<li><strong>Asset Store &amp; Tài khoản Unity:</strong>
<ul>
<li>GV hướng dẫn nhanh cách tạo tài khoản Unity ID nếu HS chưa có.</li>
<li>Truy cập Asset Store (ưu tiên qua web). Đăng nhập.</li>
<li>Thực hành tìm kiếm asset 2D miễn phí phù hợp (icon, sprite…).</li>
<li>Thực hiện “Add to My Assets”.</li>
</ul>
</li>
<li><strong>Import vào Unity:</strong>
<ul>
<li>Quay lại Unity, mở Package Manager -&gt; My Assets.</li>
<li>Tìm, Download (nếu cần) và Import asset pack vừa lấy vào dự án.</li>
</ul>
</li>
<li><strong>Tổ chức:</strong>
<ul>
<li>Quan sát các file/thư mục mới trong cửa sổ Project.</li>
<li>Thực hành kéo thả, di chuyển các file hình ảnh/Prefab vào thư mục <code>_Sprites</code> / <code>_Prefabs</code> đã tạo.</li>
</ul>
</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp HS đăng nhập/tạo tài khoản Unity ID.</li>
<li>Hướng dẫn tìm kiếm hiệu quả trên Asset Store.</li>
<li>Nhắc nhở kiểm tra License của asset.</li>
<li>Hỗ trợ các bước Download/Import nếu gặp trục trặc.</li>
<li>Quan sát và hướng dẫn cách tổ chức lại thư mục sau khi Import.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp việc sử dụng Package Manager và quy trình đầy đủ từ tìm kiếm trên Asset Store đến nhập và tổ chức tài nguyên trong dự án.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu lại cửa sổ Package Manager và giao diện Asset Store.</li>
<li><strong>Package Manager:</strong>
<ul>
<li>Giải thích rõ hơn sự khác biệt giữa các nguồn (Registry vs My Assets).</li>
<li>Nhấn mạnh lợi ích của việc quản lý package tập trung (dễ cập nhật, quản lý dependencies).</li>
<li>Lấy ví dụ về các loại package hữu ích khác (ví dụ: Cinemachine cho camera, Input System mới…).</li>
</ul>
</li>
<li><strong>Asset Store:</strong>
<ul>
<li>Thảo luận về sự đa dạng của tài nguyên trên Asset Store (miễn phí vs trả phí, 2D vs 3D, models, audio, tools…).</li>
<li><strong>Nhấn mạnh tầm quan trọng của việc đọc kỹ mô tả và đặc biệt là License của asset.</strong> Giải thích sơ qua các loại license phổ biến (ví dụ: CC0, CC-BY…).</li>
<li>Giải thích quy trình “Add to My Assets” -&gt; Download -&gt; Import. Tại sao lại qua Package Manager? (Để quản lý tập trung các asset đã “sở hữu”).</li>
</ul>
</li>
<li><strong>Tổ chức Dự án:</strong> Thảo luận tại sao việc di chuyển file sau khi import lại quan trọng (tránh làm lộn xộn cấu trúc dự án, dễ tìm kiếm về sau).</li>
<li><strong>Giới thiệu Prefab (Sơ bộ):</strong> Chỉ vào các asset có biểu tượng khối xanh vừa import. Giải thích đó là Prefab - một “khuôn mẫu” GameObject đã được thiết lập sẵn, rất tiện để tái sử dụng. “Chúng ta sẽ học cách tự tạo Prefab ở các buổi sau.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Củng cố hiểu biết về chức năng, lợi ích của Package Manager và Asset Store, nhấn mạnh các điểm cần lưu ý (license, tổ chức), và giới thiệu sơ bộ khái niệm Prefab.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử nghiệm nhanh):</strong>
<ul>
<li>GV yêu cầu HS:
<ul>
<li>Mở Package Manager, chọn một package bất kỳ trong <code>Unity Registry</code> (chưa cài) và đọc phần mô tả của nó.</li>
<li>Trong cửa sổ Project, thử tạo một thư mục con bên trong thư mục <code>_Sprites</code> (ví dụ: <code>_Sprites/Icons</code>) và di chuyển một vài file sprite vừa import vào đó.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS tự tìm hiểu thêm thông tin package và thực hành sâu hơn kỹ năng quản lý thư mục.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh:</strong> GV yêu cầu HS mở cửa sổ Package Manager và chỉ ra vị trí để xem các package đã cài (<code>In Project</code>) và các asset đã lấy từ Store (<code>My Assets</code>). Yêu cầu HS mở cửa sổ Project và xác nhận có thư mục của asset pack vừa import, và một số file đã được di chuyển vào <code>_Sprites</code> hoặc <code>_Prefabs</code>.</li>
<li><strong>Câu hỏi nhanh (Miệng):</strong>
<ol>
<li>Công cụ nào dùng để cài đặt các tính năng mở rộng chính thức của Unity? (Package Manager)</li>
<li>Nơi nào để tìm kiếm hình ảnh, âm thanh, mô hình làm game? (Asset Store)</li>
<li>Trước khi sử dụng tài nguyên từ Asset Store, điều quan trọng cần kiểm tra là gì? (License/Giấy phép sử dụng)</li>
<li>Sau khi Import asset từ Store, bước tiếp theo nên làm gì để giữ dự án gọn gàng? (Tổ chức lại, di chuyển file vào các thư mục phù hợp)</li>
<li>(Nhìn hình) Biểu tượng khối màu xanh trong cửa sổ Project thường đại diện cho cái gì? (Prefab)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng sử dụng các công cụ, hiểu biết về quy trình làm việc với package/asset và tầm quan trọng của việc tổ chức, nhận biết khái niệm Prefab.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt: Hôm nay chúng ta đã mở khóa hai công cụ rất mạnh mẽ là Package Manager và Asset Store, học cách quản lý chức năng và làm giàu dự án bằng tài nguyên có sẵn.</li>
<li>Nhấn mạnh: Việc thành thạo các công cụ này và kỹ năng tổ chức project là nền tảng quan trọng.</li>
<li>Giới thiệu buổi học tiếp theo: “Đã có tài nguyên hình ảnh mới, buổi sau chúng ta sẽ học cách chuẩn bị chúng (đặc biệt là các sprite sheet) và bắt đầu dựng giao diện người dùng (UI) cơ bản cho màn hình Menu và màn chơi của ‘Puzzle Quest’!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.4-chuẩn-bị-tài-nguyên-hình-ảnh--thiết-kế-ui-cơ-bản">Giáo án Buổi học 1.4.4: Chuẩn bị Tài nguyên Hình ảnh &amp; Thiết kế UI Cơ bản</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest (Memory Match)<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.3 (biết dùng Package Manager, Asset Store, nhập tài nguyên).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS nhận biết và phân biệt được các loại tài nguyên hình ảnh phổ biến (Sprites, Textures, UI Elements) và cấu hình cơ bản Import Settings cho Sprites trong Unity.</li>
<li>HS sử dụng được Sprite Editor để xem và cắt (slice) các sprite riêng lẻ từ một sprite sheet (nếu có).</li>
<li>HS giải thích được vai trò của Canvas và Rect Transform trong hệ thống UI của Unity.</li>
<li>HS tạo và cấu hình được các thành phần UI cơ bản: <code>Image</code>, <code>Text</code> (hoặc <code>TextMeshPro</code>), <code>Button</code>.</li>
<li>HS xây dựng được bố cục giao diện người dùng (UI layout) đơn giản cho màn hình Menu và màn hình Gameplay sử dụng các tài nguyên hình ảnh đã chuẩn bị.</li>
<li>HS hiểu và thực hành cơ bản việc sử dụng Anchors và Pivots để định vị UI.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity và có dự án “Puzzle Quest” từ buổi 1.4.3 (đã import ít nhất một asset pack 2D chứa sprites/icons).</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Từ Ảnh đến Giao diện: Chuẩn bị Sprites và Dựng UI trong Unity” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Một sprite sheet đơn giản (ảnh chứa nhiều hình nhỏ) để thực hành cắt sprite. Nếu asset pack đã nhập không có, GV có thể cung cấp một file mẫu.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Từ Ảnh đến Giao diện: Chuẩn bị Sprites và Dựng UI trong Unity"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Giao diện người dùng (UI - User Interface) và hình ảnh đẹp mắt là yếu tố then chốt thu hút người chơi. Hôm nay, chúng ta sẽ học cách chuẩn bị các tài nguyên hình ảnh (sprites) và sử dụng hệ thống UI của Unity để xây dựng các màn hình cơ bản cho game “Puzzle Quest”.</li>
<li><strong>Bước 1: Chuẩn bị Tài nguyên Hình ảnh (Sprites):</strong>
<ul>
<li>Mở cửa sổ <strong>Project</strong> và điều hướng đến thư mục chứa các file hình ảnh bạn đã nhập ở buổi trước (ví dụ: <code>_Sprites</code> hoặc thư mục của asset pack).</li>
<li>Chọn một file ảnh (ví dụ: một icon, một sprite nhân vật, hoặc một sprite sheet).</li>
<li>Trong <strong>Inspector</strong>, xem phần <strong>Import Settings</strong>:
<ul>
<li><strong>Texture Type:</strong> Đảm bảo được đặt là <code>Sprite (2D and UI)</code>. Đây là cài đặt quan trọng để Unity biết đây là hình ảnh 2D dùng cho game hoặc UI.</li>
<li><strong>Sprite Mode:</strong>
<ul>
<li><code>Single</code>: Nếu file ảnh chỉ chứa một hình duy nhất.</li>
<li><code>Multiple</code>: Nếu file ảnh là một <em>sprite sheet</em> (chứa nhiều hình nhỏ).</li>
</ul>
</li>
<li><strong>Pixels Per Unit (PPU):</strong> Xác định có bao nhiêu pixel trong ảnh tương ứng với một đơn vị (unit) trong thế giới game của Unity. Giá trị mặc định thường là 100. (Tạm thời để mặc định).</li>
<li>Nhấn nút <strong>Apply</strong> ở dưới cùng nếu bạn có thay đổi cài đặt nào.</li>
</ul>
</li>
<li><em>Hình ảnh minh họa Import Settings cho Sprite.</em></li>
</ul>
</li>
<li><strong>Bước 2: Sử dụng Sprite Editor (Nếu có Sprite Sheet):</strong>
<ul>
<li>Nếu bạn chọn một file ảnh có <code>Sprite Mode</code> là <code>Multiple</code>, một nút <strong>Sprite Editor</strong> sẽ xuất hiện trong Inspector. Nhấn vào đó.</li>
<li>Cửa sổ Sprite Editor sẽ mở ra, hiển thị ảnh của bạn.</li>
<li><em>Hình ảnh minh họa cửa sổ Sprite Editor.</em></li>
<li><strong>Cắt (Slice) Sprite Sheet:</strong>
<ul>
<li>Ở góc trên bên trái cửa sổ Sprite Editor, tìm nút “Slice”.</li>
<li>Trong menu xổ xuống “Type”, chọn:
<ul>
<li><code>Automatic</code>: Unity sẽ cố gắng tự động nhận diện và cắt các hình.</li>
<li><code>Grid by Cell Size</code>: Nếu các hình trong sheet được xếp theo lưới đều đặn, bạn có thể nhập kích thước (Size) của mỗi ô (ví dụ: 64x64 pixels).</li>
</ul>
</li>
<li>Nhấn nút “Slice” ở dưới menu đó.</li>
<li>Bạn sẽ thấy các đường viền hình chữ nhật xuất hiện xung quanh các sprite riêng lẻ.</li>
<li>Nhấn nút <strong>Apply</strong> ở góc trên bên phải cửa sổ Sprite Editor để lưu các thay đổi. Đóng cửa sổ Sprite Editor.</li>
</ul>
</li>
<li>Bây giờ, khi bạn mở rộng (expand) sprite sheet trong cửa sổ Project (bằng cách nhấp vào mũi tên nhỏ bên cạnh tên file), bạn sẽ thấy các sprite riêng lẻ đã được cắt ra.</li>
<li><em>Hình ảnh minh họa kết quả sau khi Slice và Apply.</em></li>
</ul>
</li>
<li><strong>Bước 3: Giới thiệu Hệ thống UI - Canvas và Rect Transform:</strong>
<ul>
<li>Tất cả các yếu tố giao diện người dùng (UI) trong Unity phải nằm bên trong một đối tượng đặc biệt gọi là <strong>Canvas</strong>. Canvas giống như một tấm bảng vẽ lớn để bạn đặt các nút bấm, hình ảnh, văn bản lên đó.</li>
<li>Mỗi yếu tố UI bên trong Canvas không sử dụng component <code>Transform</code> thông thường mà sử dụng <strong>Rect Transform</strong>. Nó có thêm các thuộc tính đặc biệt để định vị và co giãn UI, quan trọng nhất là <strong>Anchors</strong> (điểm neo) và <strong>Pivot</strong> (điểm xoay/định vị).</li>
<li><strong>Anchors:</strong> Xác định cách một yếu tố UI bám vào các cạnh hoặc tâm của Canvas cha hoặc một yếu tố UI cha khác. Giúp UI tự động điều chỉnh vị trí khi kích thước màn hình thay đổi.</li>
<li><strong>Pivot:</strong> Điểm tham chiếu trên chính yếu tố UI (thường là tâm hoặc một góc) mà vị trí và phép xoay được tính toán dựa trên đó.</li>
</ul>
</li>
<li><strong>Bước 4: Tạo Canvas và Các Thành phần UI Cơ bản:</strong>
<ul>
<li>Mở Scene <code>MenuScene</code> (nhấp đúp vào nó trong thư mục <code>_Scenes</code>).</li>
<li>Trong <strong>Hierarchy</strong>, nhấp chuột phải -&gt; <code>UI</code> -&gt; <code>Canvas</code>. Một GameObject <code>Canvas</code> và một <code>EventSystem</code> sẽ được tạo. (EventSystem cần thiết để xử lý input cho UI).</li>
<li>Chọn <code>Canvas</code> trong Hierarchy. Trong Inspector, bạn có thể thấy component <code>Canvas</code> và <code>Canvas Scaler</code> (giúp điều chỉnh tỷ lệ UI).</li>
<li><strong>Thêm Image:</strong> Chuột phải vào <code>Canvas</code> trong Hierarchy -&gt; <code>UI</code> -&gt; <code>Image</code>. Một GameObject <code>Image</code> mới sẽ xuất hiện con của Canvas.
<ul>
<li>Chọn <code>Image</code>. Trong Inspector, bạn sẽ thấy component <code>Image</code>.</li>
<li>Tìm thuộc tính <code>Source Image</code>. Kéo thả một sprite (ví dụ: sprite nền, logo game) từ cửa sổ Project vào ô này. Hình ảnh sẽ hiện lên trong Scene/Game view.</li>
<li>Sử dụng các công cụ trong Scene view (Move Tool) hoặc điều chỉnh các giá trị <code>Pos X</code>, <code>Pos Y</code>, <code>Width</code>, <code>Height</code> trong Rect Transform của Image để đặt vị trí và kích thước.</li>
</ul>
</li>
<li><strong>Thêm Text (hoặc TextMeshPro):</strong> Chuột phải vào <code>Canvas</code> -&gt; <code>UI</code> -&gt; <code>Text - TextMeshPro</code> (khuyến nghị) hoặc <code>Legacy</code> -&gt; <code>Text</code>.
<ul>
<li>Chọn đối tượng Text mới. Trong Inspector, tìm component Text/TextMeshPro.</li>
<li>Thay đổi nội dung trong ô <code>Text Input</code>.</li>
<li>Tùy chỉnh Font, Font Size, Color, Alignment…</li>
<li>Đặt vị trí tương tự như Image.</li>
</ul>
</li>
<li><strong>Thêm Button:</strong> Chuột phải vào <code>Canvas</code> -&gt; <code>UI</code> -&gt; <code>Button - TextMeshPro</code> (khuyến nghị) hoặc <code>Legacy</code> -&gt; <code>Button</code>.
<ul>
<li>Một Button thường có một GameObject con là Text để hiển thị chữ trên nút.</li>
<li>Chọn Button. Trong Inspector, bạn có thể thay đổi <code>Source Image</code> của component <code>Image</code> để dùng sprite nút tùy chỉnh.</li>
<li>Chọn đối tượng Text con của Button để thay đổi chữ (ví dụ: “Play”, “Start”).</li>
<li>Phần quan trọng là component <code>Button</code>. Mục <code>On Click ()</code> sẽ được dùng để gọi hàm trong script khi nút được nhấn (sẽ học ở buổi sau).</li>
</ul>
</li>
<li><em>Hình ảnh minh họa thêm Image, Text, Button vào Canvas và các component tương ứng trong Inspector.</em></li>
</ul>
</li>
<li><strong>Bước 5: Thiết kế Bố cục UI Cơ bản:</strong>
<ul>
<li><strong>Màn hình Menu (<code>MenuScene</code>):</strong> Sử dụng các kỹ năng vừa học, hãy sắp xếp các yếu tố UI để tạo giao diện menu đơn giản:
<ul>
<li>Một <code>Image</code> làm nền (tùy chọn).</li>
<li>Một <code>Text</code>/<code>TextMeshPro</code> hiển thị tên game ở trên cùng.</li>
<li>Một <code>Button</code> ở giữa màn hình với chữ “Play”.</li>
</ul>
</li>
<li><strong>Màn hình Gameplay (<code>GameplayScene</code>):</strong> Mở Scene này. Tạo Canvas và thiết kế bố cục cơ bản:
<ul>
<li>Một <code>Text</code>/<code>TextMeshPro</code> ở góc trên (ví dụ: trái) để hiển thị điểm số (tạm ghi “Score: 0”).</li>
<li>(Tùy chọn) Một <code>Button</code> nhỏ ở góc khác (ví dụ: phải) làm nút tạm dừng (chưa cần chức năng).</li>
<li>(Tùy chọn) Một <code>Image</code> làm nền cho khu vực chơi game.</li>
</ul>
</li>
<li><strong>Sử dụng Anchors:</strong> Chọn một yếu tố UI (ví dụ: Text điểm số). Trong Inspector, tìm component <code>Rect Transform</code>. Nhấp vào biểu tượng Anchor Presets (hình vuông có các chấm). Thử chọn các preset khác nhau (ví dụ: top-left, top-center) và xem các giá trị Anchor Min/Max thay đổi thế nào. Mục tiêu là làm cho điểm số luôn bám ở góc trên bên trái màn hình dù kích thước Game view thay đổi. Thực hành tương tự với nút Play ở Menu (neo vào giữa).</li>
<li><em>Hình ảnh minh họa việc thiết kế layout cho Menu và Gameplay, và cách dùng Anchor Presets.</em></li>
</ul>
</li>
<li><strong>Kết luận:</strong> Bạn đã biết cách chuẩn bị sprites, sử dụng Sprite Editor, và quan trọng nhất là đã tạo được những giao diện người dùng đầu tiên cho game bằng hệ thống UI của Unity. Việc thiết kế UI tốt sẽ làm game của bạn chuyên nghiệp và dễ sử dụng hơn.</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV chiếu hình ảnh giao diện của một vài game giải đố quen thuộc. Hỏi HS: “Các bạn thấy những yếu tố nào trên màn hình? (Nút bấm, điểm số, hình ảnh, chữ…). Làm thế nào game hiển thị chúng và cho phép chúng ta tương tác?”</li>
<li>GV: “Sau khi có các tài nguyên hình ảnh từ buổi trước, hôm nay chúng ta sẽ học cách ‘biến’ chúng thành các nút bấm, tiêu đề, khung hình… và sắp xếp chúng thành giao diện người dùng (UI) cho game Puzzle Quest của chúng ta!”</li>
<li>Nhấn mạnh: “Đầu tiên, chúng ta cần đảm bảo các file hình ảnh được Unity ‘hiểu’ đúng cách, đặc biệt nếu chúng là sprite sheet.”</li>
<li>Giới thiệu mục tiêu: Chuẩn bị tài nguyên sprite, làm quen với hệ thống UI (Canvas, Rect Transform, các thành phần cơ bản), và dựng UI ban đầu cho Menu và màn chơi.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Liên hệ UI với các game thực tế, tạo nhu cầu tìm hiểu cách xây dựng UI trong Unity, giới thiệu mục tiêu buổi học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 50 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Từ Ảnh đến Giao diện: Chuẩn bị Sprites và Dựng UI trong Unity”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li><strong>Chuẩn bị Sprite:</strong>
<ul>
<li>Chọn các file ảnh trong Project, kiểm tra và đặt <code>Texture Type</code> thành <code>Sprite (2D and UI)</code>.</li>
<li>Nếu có sprite sheet, đặt <code>Sprite Mode</code> thành <code>Multiple</code>.</li>
<li>Mở Sprite Editor, thử các chế độ <code>Slice</code> (Automatic, Grid). Nhấn <code>Apply</code>. Kiểm tra kết quả trong Project window.</li>
</ul>
</li>
<li><strong>Tạo UI:</strong>
<ul>
<li>Mở <code>MenuScene</code>. Tạo <code>Canvas</code>.</li>
<li>Thêm <code>Image</code>, gán sprite, điều chỉnh vị trí/kích thước.</li>
<li>Thêm <code>Text</code> (hoặc TextMeshPro), thay đổi nội dung, tùy chỉnh font/size/color.</li>
<li>Thêm <code>Button</code>, thay đổi chữ trên nút.</li>
</ul>
</li>
<li><strong>Thiết kế Layout:</strong>
<ul>
<li>Sắp xếp các yếu tố UI trên <code>MenuScene</code> thành bố cục menu cơ bản.</li>
<li>Mở <code>GameplayScene</code>, tạo Canvas và thêm Text cho điểm số, Button tạm dừng (tùy chọn).</li>
<li>Thực hành sử dụng Anchor Presets để neo Text điểm số vào góc trên bên trái, neo nút Play ở Menu vào giữa.</li>
</ul>
</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp HS tìm đúng cài đặt Import Settings.</li>
<li>Hướng dẫn sử dụng Sprite Editor nếu HS gặp khó khăn với việc cắt.</li>
<li>Giải thích khi HS thắc mắc về Canvas, Rect Transform.</li>
<li>Hỗ trợ thêm và cấu hình các thành phần UI cơ bản.</li>
<li>Hướng dẫn cách sử dụng Anchor Presets hiệu quả.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp việc cấu hình sprite, cắt sprite sheet, tạo và sắp xếp các thành phần UI cơ bản, làm quen với Canvas, Rect Transform và Anchors.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu lại một Scene có Canvas và các yếu tố UI.</li>
<li><strong>Import Settings &amp; Sprite Editor:</strong> Giải thích lại tại sao cần đặt <code>Texture Type</code> là <code>Sprite (2D and UI)</code>. Khi nào dùng <code>Sprite Mode</code> là <code>Single</code> vs <code>Multiple</code>. Mục đích của việc <code>Slice</code> sprite sheet.</li>
<li><strong>Hệ thống UI:</strong>
<ul>
<li><strong>Canvas:</strong> Nhấn mạnh vai trò là gốc chứa mọi thứ UI. Giới thiệu sơ qua các chế độ Render Mode của Canvas (Screen Space - Overlay là mặc định và phổ biến nhất).</li>
<li><strong>Rect Transform:</strong> So sánh với <code>Transform</code> thông thường. Giải thích chi tiết hơn về <strong>Anchors</strong> (điểm neo - quyết định UI bám vào đâu khi màn hình thay đổi kích thước) và <strong>Pivot</strong> (điểm tham chiếu của chính UI). Dùng ví dụ trực quan để minh họa Anchors hoạt động.</li>
<li><strong>Các Thành phần UI:</strong> Review lại chức năng chính của <code>Image</code> (hiển thị ảnh), <code>Text</code>/<code>TextMeshPro</code> (hiển thị chữ), <code>Button</code> (tương tác nhấn). Chỉ ra các thuộc tính quan trọng nhất của từng component.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Củng cố kiến thức về chuẩn bị sprite, giải thích sâu hơn về các khái niệm cốt lõi của hệ thống UI (Canvas, Rect Transform, Anchors, Pivot) và chức năng của các thành phần UI cơ bản.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử nghiệm nhanh):</strong>
<ul>
<li>GV yêu cầu HS:
<ul>
<li>Chọn Button “Play” trong <code>MenuScene</code>. Trong Inspector của component Button, thử thay đổi các thuộc tính <code>Transition</code> (ví dụ: từ Color Tint sang Sprite Swap) và gán các sprite khác nhau cho các trạng thái (Highlighted, Pressed) nếu có sprite phù hợp. Nhấn Play để xem hiệu ứng khi di chuột/nhấn nút.</li>
<li>Chọn Text điểm số trong <code>GameplayScene</code>, thử thay đổi Alignment (căn lề) của text.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS khám phá thêm các tùy chọn của component UI, thấy được khả năng tùy biến giao diện.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh:</strong> GV yêu cầu HS mở <code>MenuScene</code> và <code>GameplayScene</code>, xác nhận đã có Canvas và các yếu tố UI cơ bản (Text tên game, nút Play; Text điểm số). Yêu cầu HS chọn Text điểm số và chỉ ra vị trí đặt Anchors trong Inspector.</li>
<li><strong>Câu hỏi nhanh (Miệng):</strong>
<ol>
<li>Khi import ảnh 2D cho UI, cần đặt <code>Texture Type</code> là gì? (<code>Sprite (2D and UI)</code>)</li>
<li>Công cụ nào dùng để cắt hình nhỏ từ một ảnh lớn chứa nhiều hình? (Sprite Editor)</li>
<li>Đối tượng gốc chứa tất cả UI trong Unity là gì? (Canvas)</li>
<li>Component nào dùng để định vị và co giãn UI? (Rect Transform)</li>
<li>Để một yếu tố UI luôn bám vào góc màn hình, ta cần chỉnh cái gì? (Anchors)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng thực hiện các bước chuẩn bị sprite và tạo UI, mức độ hiểu biết về các khái niệm Canvas, Rect Transform, Anchors và các thành phần UI cơ bản.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt: Hôm nay chúng ta đã chuẩn bị xong phần hình ảnh và dựng nên bộ mặt ban đầu cho game “Puzzle Quest” với các màn hình Menu và Gameplay cơ bản.</li>
<li>Nhấn mạnh: Việc thiết kế UI rõ ràng, dễ sử dụng là rất quan trọng.</li>
<li>Giới thiệu buổi học tiếp theo: “Giao diện đã có, nhưng chưa có ‘não’. Buổi sau, chúng ta sẽ chính thức bước vào thế giới lập trình C#, tìm hiểu về hàm và phương thức để bắt đầu viết những dòng code đầu tiên điều khiển logic cho game!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.5-giới-thiệu-hàm-và-phương-thức-c-1">Giáo án Buổi học 1.4.5: Giới thiệu Hàm và Phương thức C# (1)</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.4 (dựng UI cơ bản), <em>bắt đầu học C# trong học phần này</em>.<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS tạo và gắn được một C# script mới vào một GameObject trong Unity.</li>
<li>HS giải thích được cấu trúc cơ bản của một script C# kế thừa từ <code>MonoBehaviour</code> (namespace, class, <code>Start</code>, <code>Update</code>).</li>
<li>HS khai báo được các biến (variables) với các kiểu dữ liệu cơ bản (<code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code>) và access modifiers (<code>public</code>, <code>private</code>).</li>
<li>HS sử dụng được cấu trúc điều khiển <code>if</code>/<code>else</code> và các toán tử so sánh cơ bản.</li>
<li>HS sử dụng được <code>Debug.Log()</code> để in thông tin ra Console nhằm kiểm tra và gỡ lỗi.</li>
<li>HS giải thích được khái niệm và lợi ích cơ bản của việc sử dụng hàm/phương thức (tổ chức code, tái sử dụng).</li>
<li>HS định nghĩa và gọi được một hàm <code>void</code> đơn giản, không có tham số, từ bên trong hàm <code>Start()</code>.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity, Visual Studio (hoặc VS Code với Unity extension) và có dự án “Puzzle Quest” từ buổi 1.4.4.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Bước Chân Đầu Tiên vào Thế giới C# trong Unity: Biến, Điều kiện và Hàm Cơ bản” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Cheat sheet (bảng tóm tắt) cú pháp C# cơ bản (biến, if/else, Debug.Log, cấu trúc hàm void).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Bước Chân Đầu Tiên vào Thế giới C# trong Unity: Biến, Điều kiện và Hàm Cơ bản"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li>
<p><strong>Giới thiệu:</strong> Chào mừng bạn đến với lập trình C# trong Unity! Scripts C# chính là “bộ não” điều khiển mọi hành vi, logic và tương tác trong game của bạn. Hôm nay, chúng ta sẽ tìm hiểu những khái niệm nền tảng nhất: cách tạo script, lưu trữ dữ liệu bằng biến, ra quyết định bằng câu lệnh <code>if</code>, và bắt đầu tổ chức code bằng các hàm đơn giản.</p>
</li>
<li>
<p><strong>Bước 1: Tạo C# Script Đầu Tiên:</strong></p>
<ul>
<li>Mở dự án “Puzzle Quest” trong Unity.</li>
<li>Trong cửa sổ <strong>Project</strong>, điều hướng đến thư mục <code>_Scripts</code>.</li>
<li>Nhấp chuột phải vào vùng trống -&gt; <code>Create</code> -&gt; <code>C# Script</code>.</li>
<li>Đặt tên cho script là <code>GameManager</code> (quy ước đặt tên class viết hoa chữ cái đầu mỗi từ - PascalCase). Nhấn Enter.</li>
<li><em>Hình ảnh minh họa tạo C# Script.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 2: Gắn Script vào GameObject:</strong></p>
<ul>
<li>Để script có thể chạy trong game, nó cần được gắn vào một GameObject trong Scene. Chúng ta sẽ tạo một GameObject rỗng để quản lý game.</li>
<li>Trong cửa sổ <strong>Hierarchy</strong>, nhấp chuột phải -&gt; <code>Create Empty</code>.</li>
<li>Đặt tên cho GameObject mới này là <code>GameManager</code> (trùng tên với script cho dễ quản lý).</li>
<li>Kéo thả file script <code>GameManager</code> từ cửa sổ Project vào GameObject <code>GameManager</code> trong Hierarchy (hoặc vào Inspector của nó).</li>
<li>Chọn GameObject <code>GameManager</code>, kiểm tra trong Inspector xem component <code>Game Manager (Script)</code> đã xuất hiện chưa.</li>
<li><em>Hình ảnh minh họa gắn script vào GameObject.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 3: Mở và Tìm hiểu Cấu trúc Script:</strong></p>
<ul>
<li>Nhấp đúp vào file script <code>GameManager</code> trong cửa sổ Project để mở nó bằng Visual Studio (hoặc trình soạn thảo code mặc định của bạn).</li>
<li>Bạn sẽ thấy đoạn code mặc định như sau:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span> <span class="token comment">// Cần thiết để dùng các hàm Unity</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameManager</span> <span class="token punctuation">:</span> MonoBehaviour <span class="token comment">// Tên class trùng tên file, kế thừa MonoBehaviour</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Hàm Start được gọi trước frame đầu tiên khi script được kích hoạt</span>
    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Code khởi tạo sẽ viết ở đây</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Hàm Update được gọi mỗi frame một lần</span>
    <span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Code cập nhật liên tục sẽ viết ở đây</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích cấu trúc:</strong>
<ul>
<li><code>using ...;</code>: Khai báo sử dụng các thư viện (namespaces) chứa các lớp và hàm cần thiết. <code>UnityEngine</code> là quan trọng nhất.</li>
<li><code>public class GameManager : MonoBehaviour</code>: Định nghĩa một lớp (class) tên là <code>GameManager</code>. Dấu <code>:</code> có nghĩa là lớp này <em>kế thừa</em> từ lớp <code>MonoBehaviour</code> của Unity. Chỉ những script kế thừa từ <code>MonoBehaviour</code> mới có thể gắn vào GameObject và sử dụng các hàm sự kiện như <code>Start</code>, <code>Update</code>.</li>
<li><code>void Start()</code>: Một hàm đặc biệt (hàm sự kiện) được Unity tự động gọi <em>một lần</em> khi GameObject chứa script này được kích hoạt và game bắt đầu. Thường dùng để khởi tạo giá trị ban đầu, lấy tham chiếu đến các đối tượng khác.</li>
<li><code>void Update()</code>: Một hàm sự kiện khác được Unity gọi <em>liên tục mỗi khung hình</em> (frame). Thường dùng để kiểm tra input, di chuyển đối tượng, cập nhật logic game diễn ra theo thời gian.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 4: Làm việc với Biến (Variables):</strong></p>
<ul>
<li>Biến dùng để lưu trữ dữ liệu. Bạn cần khai báo kiểu dữ liệu và tên cho biến.</li>
<li>Thêm các dòng sau <em>bên trong</em> lớp <code>GameManager</code> nhưng <em>bên ngoài</em> các hàm <code>Start</code> và <code>Update</code>:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameManager</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token comment">// --- Khai báo biến ở đây ---</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> playerScore <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// Lưu điểm người chơi (số nguyên), public để xem trong Inspector</span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> gameTimer <span class="token operator">=</span> <span class="token number">60.0f</span><span class="token punctuation">;</span>   <span class="token comment">// Lưu thời gian chơi (số thực), public</span>
    <span class="token keyword">public</span> <span class="token keyword">string</span> playerName <span class="token operator">=</span> <span class="token string">"Player One"</span><span class="token punctuation">;</span> <span class="token comment">// Lưu tên người chơi (chuỗi ký tự)</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> isGameOver <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>   <span class="token comment">// Lưu trạng thái game kết thúc chưa (đúng/sai)</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> internalCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// Biến private, không thấy trong Inspector</span>
    <span class="token comment">// --- Kết thúc khai báo biến ---</span>

    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong>
<ul>
<li><code>public</code>/<code>private</code>: Access Modifiers. <code>public</code> làm biến xuất hiện trong Inspector của Unity, cho phép bạn thay đổi giá trị trực tiếp mà không cần sửa code. <code>private</code> chỉ dùng được bên trong script này.</li>
<li><code>int</code>, <code>float</code>, <code>string</code>, <code>bool</code>: Các kiểu dữ liệu cơ bản. Lưu ý <code>f</code> sau số thực (<code>60.0f</code>).</li>
</ul>
</li>
<li><strong>Lưu script</strong> (Ctrl+S) và quay lại Unity. Chọn GameObject <code>GameManager</code>. Trong Inspector, bạn sẽ thấy các biến <code>public</code> (Player Score, Game Timer, Player Name, Is Game Over) xuất hiện và có thể chỉnh sửa giá trị.</li>
<li><em>Hình ảnh minh họa các biến public trong Inspector.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 5: Sử dụng Debug.Log() để Kiểm tra:</strong></p>
<ul>
<li><code>Debug.Log()</code> là người bạn tốt nhất của lập trình viên Unity! Nó giúp in thông tin ra cửa sổ Console để kiểm tra giá trị biến hoặc xem code có chạy đến một đoạn nào đó không.</li>
<li>Thêm dòng sau vào <em>bên trong</em> hàm <code>Start()</code>:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Game Manager script has started!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Initial Player Score: "</span> <span class="token operator">+</span> playerScore<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Nối chuỗi với biến</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Game Timer set to: "</span> <span class="token operator">+</span> gameTimer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// internalCounter = 10; // Có thể gán giá trị cho biến ở đây</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>Lưu script. Quay lại Unity. Mở cửa sổ <strong>Console</strong> (<code>Window</code> -&gt; <code>General</code> -&gt; <code>Console</code>).</li>
<li>Nhấn nút <strong>Play</strong>. Quan sát các thông điệp bạn vừa viết xuất hiện trong Console.</li>
<li><em>Hình ảnh minh họa cửa sổ Console với output từ Debug.Log.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 6: Ra Quyết định với <code>if</code>/<code>else</code>:</strong></p>
<ul>
<li>Câu lệnh <code>if</code> cho phép code chạy một đoạn lệnh chỉ khi một điều kiện nào đó là đúng.</li>
<li>Thêm đoạn code sau vào <em>bên trong</em> hàm <code>Update()</code> (vì chúng ta muốn kiểm tra liên tục):</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Giảm thời gian chơi game mỗi giây</span>
    <span class="token comment">// Time.deltaTime là khoảng thời gian (giây) giữa frame này và frame trước</span>
    gameTimer <span class="token operator">-</span><span class="token operator">=</span> Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">;</span>

    <span class="token comment">// Kiểm tra xem game đã kết thúc chưa VÀ thời gian còn lại không</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isGameOver <span class="token operator">==</span> <span class="token keyword">false</span> <span class="token operator">&amp;&amp;</span> gameTimer <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Nếu game chưa kết thúc và còn thời gian -&gt; làm gì đó (ví dụ: cho phép chơi)</span>
        <span class="token comment">// Debug.Log("Game is running... Time left: " + gameTimer); // Có thể bỏ log này đi vì nó chạy liên tục</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token comment">// Ngược lại (game đã kết thúc HOẶC hết giờ)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Nếu trạng thái chưa phải là Game Over thì đặt lại và thông báo</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isGameOver <span class="token operator">==</span> <span class="token keyword">false</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
             isGameOver <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment">// Đặt trạng thái game kết thúc</span>
             Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"TIME'S UP or GAME OVER!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment">// Ở đây sau này sẽ thêm logic hiển thị màn hình thua/kết thúc</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Ví dụ kiểm tra điểm số</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>playerScore <span class="token operator">&gt;=</span> <span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"WOW! Player reached 100 points!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// isGameOver = true; // Cũng có thể kết thúc game khi đủ điểm</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong>
<ul>
<li><code>gameTimer -= Time.deltaTime;</code>: Cách cơ bản để tạo bộ đếm ngược.</li>
<li><code>if (điều_kiện)</code>: Khối lệnh bên trong <code>{}</code> chỉ chạy nếu <code>điều_kiện</code> là <code>true</code>.</li>
<li><code>==</code> (So sánh bằng), <code>&gt;</code> (Lớn hơn), <code>&amp;&amp;</code> (Toán tử VÀ - cả hai điều kiện phải đúng), <code>!=</code> (Không bằng - không dùng ở đây).</li>
<li><code>else</code>: Khối lệnh chạy nếu điều kiện của <code>if</code> là <code>false</code>.</li>
</ul>
</li>
<li>Lưu script. Quay lại Unity. Nhấn Play. Quan sát giá trị <code>Game Timer</code> giảm dần trong Inspector. Xem thông điệp “TIME’S UP…” xuất hiện trong Console khi hết giờ. Thử đặt <code>Player Score</code> thành 100 trong Inspector và xem log tương ứng.</li>
</ul>
</li>
<li>
<p><strong>Bước 7: Giới thiệu Hàm/Phương thức (Function/Method):</strong></p>
<ul>
<li>Khi code trở nên phức tạp, việc viết tất cả vào <code>Start()</code> hay <code>Update()</code> sẽ rất khó quản lý và dễ bị lặp lại code.</li>
<li><strong>Hàm (hay Phương thức trong C#)</strong> là một khối code được đặt tên, dùng để thực hiện một nhiệm vụ cụ thể.</li>
<li><strong>Lợi ích:</strong>
<ul>
<li><strong>Tổ chức:</strong> Chia nhỏ chương trình thành các phần dễ quản lý.</li>
<li><strong>Tái sử dụng:</strong> Gọi cùng một hàm từ nhiều nơi khác nhau thay vì viết lại code.</li>
<li><strong>Dễ đọc/bảo trì:</strong> Code rõ ràng hơn, dễ hiểu mục đích của từng phần.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 8: Viết Hàm <code>void</code> Đầu Tiên:</strong></p>
<ul>
<li>Hàm <code>void</code> là hàm không trả về giá trị nào sau khi thực hiện xong.</li>
<li>Thêm đoạn code sau <em>bên trong</em> lớp <code>GameManager</code> nhưng <em>bên ngoài</em> các hàm <code>Start</code> và <code>Update</code> (ngang hàng với <code>Start</code> và <code>Update</code>):</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameManager</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token comment">// ... (Phần biến đã khai báo) ...</span>

    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Game Manager script has started!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Initial Player Score: "</span> <span class="token operator">+</span> playerScore<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Game Timer set to: "</span> <span class="token operator">+</span> gameTimer<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// --- Gọi hàm tùy chỉnh từ Start() ---</span>
        <span class="token function">PrintWelcomeMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// --- Kết thúc gọi hàm ---</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// ... (Code trong Update) ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// --- Định nghĩa hàm tùy chỉnh ở đây ---</span>
    <span class="token comment">// Hàm này không trả về gì (void) và không cần thông tin đầu vào (không có tham số trong ngoặc đơn)</span>
    <span class="token keyword">void</span> <span class="token function">PrintWelcomeMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"===================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Welcome to Puzzle Quest!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Try to match all the pairs!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Current High Score (not implemented yet): 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"===================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// --- Kết thúc định nghĩa hàm ---</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong>
<ul>
<li><code>void PrintWelcomeMessage()</code>: Định nghĩa một hàm mới tên là <code>PrintWelcomeMessage</code>.</li>
<li>Bên trong <code>{}</code> của hàm là các lệnh <code>Debug.Log</code> để in thông điệp chào mừng.</li>
<li><code>PrintWelcomeMessage();</code>: Đây là cách <em>gọi</em> hàm. Khi <code>Start()</code> chạy đến dòng này, nó sẽ nhảy đến thực thi toàn bộ code bên trong hàm <code>PrintWelcomeMessage</code>, sau đó quay lại <code>Start()</code> để chạy tiếp (nếu còn lệnh).</li>
</ul>
</li>
<li>Lưu script. Quay lại Unity. Nhấn Play. Quan sát Console, bạn sẽ thấy thông điệp chào mừng được in ra <em>sau</em> các thông điệp về điểm và thời gian trong <code>Start()</code>.</li>
</ul>
</li>
<li>
<p><strong>Kết luận:</strong> Bạn đã viết những dòng code C# đầu tiên, học cách dùng biến, câu lệnh <code>if</code>, <code>Debug.Log</code> và quan trọng nhất là đã tạo và gọi được hàm tùy chỉnh đầu tiên của mình! Đây là nền tảng vững chắc để xây dựng các tính năng phức tạp hơn cho game.</p>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV: “Chúng ta đã có giao diện cơ bản. Nhưng làm sao để game biết người chơi được bao nhiêu điểm? Làm sao để có bộ đếm thời gian? Làm sao để kiểm tra xem người chơi đã thắng hay thua? Tất cả những logic đó cần được ‘viết ra’ bằng một ngôn ngữ mà Unity hiểu được.”</li>
<li>Giới thiệu C#: “Ngôn ngữ đó chính là C# (đọc là ‘C sharp’). Đây là một ngôn ngữ lập trình mạnh mẽ và phổ biến, là ‘bộ não’ đằng sau hầu hết các game Unity.”</li>
<li>GV: “Hôm nay, chúng ta sẽ cùng nhau viết những dòng lệnh C# đầu tiên, học cách ra lệnh cho máy tính lưu trữ thông tin, đưa ra quyết định, và bắt đầu tổ chức các lệnh đó một cách khoa học bằng ‘hàm’.”</li>
<li>Nêu mục tiêu: Tạo script C#, làm quen với biến, câu lệnh <code>if</code>, <code>Debug.Log</code>, và hiểu khái niệm, cách tạo/gọi hàm <code>void</code> đơn giản.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo sự chuyển tiếp mượt mà sang lập trình, giới thiệu ngôn ngữ C# và vai trò của nó, nêu bật các khái niệm cốt lõi sẽ học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 50 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Bước Chân Đầu Tiên vào Thế giới C# trong Unity: Biến, Điều kiện và Hàm Cơ bản”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li>Tạo script <code>GameManager</code> và GameObject tương ứng, gắn script vào GameObject.</li>
<li>Mở script, quan sát cấu trúc mặc định (<code>Start</code>, <code>Update</code>).</li>
<li>Khai báo các biến <code>public</code> và <code>private</code> với các kiểu dữ liệu cơ bản.</li>
<li>Lưu script, quay lại Unity, kiểm tra các biến <code>public</code> trong Inspector.</li>
<li>Thêm các lệnh <code>Debug.Log</code> vào <code>Start()</code> để in giá trị biến. Mở Console và Play test.</li>
<li>Thêm logic <code>if</code>/<code>else</code> và bộ đếm thời gian vào <code>Update()</code>. Play test và quan sát Console, Inspector.</li>
<li>Định nghĩa hàm <code>void PrintWelcomeMessage()</code>.</li>
<li>Gọi hàm <code>PrintWelcomeMessage()</code> từ <code>Start()</code>. Play test và kiểm tra Console.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp HS khắc phục lỗi cú pháp cơ bản khi gõ code (thiếu <code>;</code>, sai tên biến/hàm, sai dấu ngoặc…).</li>
<li>Giải thích lại ý nghĩa của <code>public</code>/<code>private</code> khi HS kiểm tra Inspector.</li>
<li>Hướng dẫn cách đọc thông báo lỗi (nếu có) trong Console.</li>
<li>Đảm bảo HS hiểu cách gọi hàm từ <code>Start()</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp các thao tác cơ bản nhất của lập trình C# trong Unity: tạo script, khai báo biến, dùng <code>Debug.Log</code>, viết <code>if/else</code>, định nghĩa và gọi hàm <code>void</code>.</li>
</ul>
<p><strong>3. Explain (Giải thích - 30 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu script <code>GameManager</code> lên màn hình và giải thích kỹ từng phần cốt lõi HS vừa thực hành:
<ul>
<li><strong>Cấu trúc Script MonoBehaviour:</strong> Nhắc lại vai trò <code>MonoBehaviour</code>, <code>Start()</code>, <code>Update()</code>.</li>
<li><strong>Biến:</strong> Cách khai báo, ý nghĩa các kiểu dữ liệu cơ bản, sự khác biệt và công dụng của <code>public</code> và <code>private</code>. Cách truy cập biến <code>public</code> từ Inspector.</li>
<li><strong><code>Debug.Log()</code>:</strong> Nhấn mạnh lại tầm quan trọng của nó trong việc kiểm tra và gỡ lỗi. Cách nối chuỗi với biến để in giá trị.</li>
<li><strong><code>if</code>/<code>else</code>:</strong> Cách hoạt động, các toán tử so sánh (<code>==</code>, <code>&gt;</code>, <code>&lt;</code>…), toán tử logic (<code>&amp;&amp;</code>, <code>||</code>). Cách lồng các câu lệnh <code>if</code>.</li>
<li><strong><code>Time.deltaTime</code>:</strong> Giải thích tại sao cần dùng nó để làm cho các hoạt động liên quan đến thời gian (như bộ đếm ngược, di chuyển) trở nên mượt mà và độc lập với tốc độ khung hình (frame rate).</li>
<li><strong>Hàm/Phương thức:</strong> Định nghĩa lại khái niệm, nhấn mạnh các lợi ích (tổ chức, tái sử dụng, dễ đọc).</li>
<li><strong>Cú pháp Hàm <code>void</code>:</strong> Giải thích <code>void</code> nghĩa là gì (không trả về giá trị), cấu trúc <code>TenHam() { ... }</code>. Cách gọi hàm bằng tên và dấu <code>()</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Cung cấp giải thích chi tiết, hệ thống hóa các khái niệm và cú pháp C# cơ bản mà HS vừa được trải nghiệm, đảm bảo HS hiểu “tại sao” chứ không chỉ “làm thế nào”.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 0 phút)</strong></p>
<ul>
<li><em>(Do nội dung buổi này đã khá nhiều kiến thức nền tảng, phần Elaborate có thể được giảm bớt hoặc tích hợp vào Explain/Evaluate).</em></li>
<li><em>(Nếu có thời gian)</em> GV có thể đặt câu hỏi nhanh: “Nếu muốn thông báo ‘Bạn đã thắng!’ khi điểm số đạt 50 thì sửa code ở đâu và như thế nào?” (Sửa điều kiện trong <code>if (playerScore &gt;= 100)</code>).</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh Code &amp; Console:</strong> GV yêu cầu HS chạy game lần cuối, đảm bảo Console hiển thị đúng các log từ <code>Start()</code> và hàm <code>PrintWelcomeMessage()</code>, và log “TIME’S UP…” xuất hiện khi hết giờ. Xem nhanh script của một vài HS để kiểm tra cấu trúc cơ bản.</li>
<li><strong>Câu hỏi nhanh (Miệng/Viết):</strong>
<ol>
<li>Làm thế nào để tạo một file C# script mới trong Unity? (Chuột phải Project -&gt; Create -&gt; C# Script)</li>
<li>Hàm nào chạy một lần khi game bắt đầu? (<code>Start</code>)</li>
<li>Từ khóa nào dùng để khai báo biến có thể thấy trong Inspector? (<code>public</code>)</li>
<li>Lệnh nào dùng để in thông tin ra Console? (<code>Debug.Log()</code>)</li>
<li>Từ khóa nào dùng để bắt đầu một khối lệnh chỉ chạy khi điều kiện đúng? (<code>if</code>)</li>
<li>Việc tạo ra các hàm riêng (như <code>PrintWelcomeMessage</code>) có lợi ích gì? (Tổ chức code, tái sử dụng, dễ đọc…)</li>
<li>Từ <code>void</code> trước tên hàm có nghĩa là gì? (Hàm không trả về giá trị)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá mức độ nắm bắt các thao tác cơ bản, cú pháp C# nền tảng, khái niệm về hàm và khả năng sử dụng <code>Debug.Log</code>.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV khen ngợi nỗ lực của HS: “Chúc mừng các bạn đã viết những dòng code C# đầu tiên và tạo ra ‘bộ não’ ban đầu cho game! Đây là một bước tiến lớn.”</li>
<li>Tóm tắt các khái niệm chính: Script, MonoBehaviour, Biến, <code>if/else</code>, <code>Debug.Log</code>, Hàm <code>void</code>.</li>
<li>Giới thiệu buổi học tiếp theo: “Chúng ta đã biết cách tạo hàm đơn giản. Buổi sau, chúng ta sẽ nâng cấp hàm lên một tầm cao mới: học cách truyền dữ liệu vào hàm (tham số) và cách hàm trả về kết quả tính toán, giúp code của chúng ta linh hoạt và mạnh mẽ hơn rất nhiều!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.6-ứng-dụng-hàm-và-phương-thức-c-2---tham-số-và-giá-trị-trả-về">Giáo án Buổi học 1.4.6: Ứng dụng Hàm và Phương thức C# (2) - Tham số và Giá trị trả về</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.5 (biết tạo script, biến, if/else, Debug.Log, hàm void cơ bản).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS giải thích được khái niệm và lợi ích của việc sử dụng tham số (parameters) trong hàm.</li>
<li>HS định nghĩa và gọi được các hàm có một hoặc nhiều tham số với các kiểu dữ liệu khác nhau.</li>
<li>HS giải thích được khái niệm và lợi ích của việc hàm trả về giá trị (return values).</li>
<li>HS định nghĩa và gọi được các hàm có kiểu trả về khác <code>void</code> (ví dụ: <code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code>).</li>
<li>HS sử dụng được giá trị trả về từ một hàm trong các biểu thức hoặc câu lệnh khác.</li>
<li>HS phân biệt được phạm vi (scope) của biến cục bộ (local variables) và biến thành viên (member/instance variables).</li>
<li>HS bắt đầu áp dụng hàm có tham số và trả về giá trị để phác thảo cấu trúc logic cho game “Puzzle Quest”.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity, Visual Studio (hoặc VS Code) và có dự án “Puzzle Quest” từ buổi 1.4.5 (với script <code>GameManager</code> đã có).</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Nâng Cấp Hàm C#: Truyền Dữ liệu và Nhận Kết quả” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Sơ đồ hoặc ví dụ minh họa luồng dữ liệu vào/ra của hàm có tham số và trả về giá trị.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Nâng Cấp Hàm C#: Truyền Dữ liệu và Nhận Kết quả"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Ở buổi trước, chúng ta đã tạo hàm <code>void</code> đơn giản. Tuy nhiên, để hàm thực sự linh hoạt và mạnh mẽ, chúng cần có khả năng nhận dữ liệu đầu vào (tham số) và đôi khi cần trả về kết quả sau khi xử lý (giá trị trả về). Hôm nay, chúng ta sẽ học cách làm điều đó!</li>
<li><strong>Phần 1: Hàm có Tham số (Parameters) - Đưa Dữ liệu vào Hàm</strong>
<ul>
<li><strong>Tại sao cần Tham số?</strong> Hãy tưởng tượng bạn có một hàm để cộng điểm, nhưng bạn muốn cộng số điểm khác nhau mỗi lần (ví dụ: 10 điểm khi tìm đúng cặp, 50 điểm khi hoàn thành màn). Thay vì viết nhiều hàm cộng điểm khác nhau, chúng ta dùng <em>tham số</em> để cho hàm biết cần cộng bao nhiêu điểm.</li>
<li><strong>Cú pháp Định nghĩa:</strong> Khi định nghĩa hàm, bạn khai báo các tham số bên trong dấu ngoặc đơn <code>()</code>, giống như khai báo biến:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token comment">// Hàm nhận một tham số kiểu int tên là 'pointsToAdd'</span>
<span class="token keyword">void</span> <span class="token function">AddScore</span><span class="token punctuation">(</span><span class="token keyword">int</span> pointsToAdd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Sử dụng tham số bên trong hàm</span>
    playerScore <span class="token operator">+</span><span class="token operator">=</span> pointsToAdd<span class="token punctuation">;</span> <span class="token comment">// Giả sử playerScore là biến thành viên</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Added "</span> <span class="token operator">+</span> pointsToAdd <span class="token operator">+</span> <span class="token string">" points. Current score: "</span> <span class="token operator">+</span> playerScore<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Hàm nhận nhiều tham số với kiểu khác nhau</span>
<span class="token keyword">void</span> <span class="token function">DisplayMessage</span><span class="token punctuation">(</span><span class="token keyword">string</span> message<span class="token punctuation">,</span> <span class="token keyword">int</span> repeatCount<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> repeatCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// Vòng lặp for cơ bản (có thể giới thiệu nhanh)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><strong>Cú pháp Gọi hàm:</strong> Khi gọi hàm, bạn cần cung cấp các giá trị (gọi là <strong>đối số - arguments</strong>) tương ứng với các tham số đã định nghĩa, theo đúng thứ tự và kiểu dữ liệu:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token comment">// Gọi hàm AddScore với đối số là 10</span>
<span class="token function">AddScore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Gọi hàm AddScore với đối số là 50</span>
<span class="token function">AddScore</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Gọi hàm DisplayMessage</span>
<span class="token function">DisplayMessage</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Sẽ in "Hello!" 3 lần</span>
</code></pre>
</li>
<li><strong>Thực hành:</strong>
<ul>
<li>Mở script <code>GameManager</code>.</li>
<li>Xóa hoặc comment out dòng <code>playerScore = 0;</code> trong phần khai báo biến nếu có.</li>
<li>Định nghĩa hàm <code>void AddScore(int pointsToAdd)</code> như ví dụ trên.</li>
<li>Trong hàm <code>Update()</code>, thay vì chỉ log khi điểm &gt;= 100, hãy thêm một điều kiện để thử cộng điểm, ví dụ:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">if</span> <span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token function">GetKeyDown</span><span class="token punctuation">(</span>KeyCode<span class="token punctuation">.</span>UpArrow<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Nhấn mũi tên lên để cộng điểm</span>
<span class="token punctuation">{</span>
    <span class="token function">AddScore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Gọi hàm cộng 10 điểm</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li>Lưu script, quay lại Unity, nhấn Play. Thử nhấn phím mũi tên lên và xem điểm số tăng trong Console/Inspector.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Phần 2: Hàm có Giá trị trả về (Return Values) - Lấy Kết quả từ Hàm</strong>
<ul>
<li><strong>Tại sao cần Giá trị trả về?</strong> Đôi khi, bạn muốn hàm thực hiện một phép tính hoặc kiểm tra một điều kiện và <em>trả về</em> kết quả để bạn có thể sử dụng ở nơi khác. Ví dụ: hàm kiểm tra xem game đã kết thúc chưa, hàm lấy điểm số hiện tại.</li>
<li><strong>Cú pháp Định nghĩa:</strong> Thay vì dùng <code>void</code>, bạn chỉ định <em>kiểu dữ liệu</em> mà hàm sẽ trả về trước tên hàm. Bên trong hàm, bạn phải sử dụng từ khóa <code>return</code> để trả về một giá trị có kiểu dữ liệu tương ứng.<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token comment">// Hàm trả về kiểu int (điểm số hiện tại)</span>
<span class="token keyword">int</span> <span class="token function">GetCurrentScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> playerScore<span class="token punctuation">;</span> <span class="token comment">// Trả về giá trị của biến thành viên playerScore</span>
<span class="token punctuation">}</span>

<span class="token comment">// Hàm trả về kiểu bool (trạng thái game)</span>
<span class="token keyword">bool</span> <span class="token function">IsGameFinished</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Kiểm tra điều kiện thắng (ví dụ: tìm hết cặp) HOẶC hết giờ</span>
    <span class="token keyword">bool</span> winConditionMet <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span> <span class="token comment">// Giả sử chưa thắng</span>
    <span class="token comment">// ... (Sau này sẽ thêm logic kiểm tra thắng ở đây) ...</span>
    <span class="token keyword">bool</span> timeUp <span class="token operator">=</span> <span class="token punctuation">(</span>gameTimer <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> winConditionMet <span class="token operator">||</span> timeUp <span class="token operator">||</span> isGameOver<span class="token punctuation">;</span> <span class="token comment">// Trả về true nếu thắng HOẶC hết giờ HOẶC trạng thái là Over</span>
<span class="token punctuation">}</span>

<span class="token comment">// Hàm trả về kiểu string (tạo thông báo) - ví dụ có tham số</span>
<span class="token keyword">string</span> <span class="token function">CreateStatusMessage</span><span class="token punctuation">(</span><span class="token keyword">string</span> prefix<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">string</span> status <span class="token operator">=</span> prefix <span class="token operator">+</span> <span class="token string">" | Score: "</span> <span class="token operator">+</span> playerScore <span class="token operator">+</span> <span class="token string">" | Time: "</span> <span class="token operator">+</span> Mathf<span class="token punctuation">.</span><span class="token function">RoundToInt</span><span class="token punctuation">(</span>gameTimer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mathf.RoundToInt làm tròn số thực</span>
    <span class="token keyword">return</span> status<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><strong>Cú pháp Gọi hàm và Sử dụng kết quả:</strong> Khi gọi hàm có giá trị trả về, bạn thường gán kết quả vào một biến có cùng kiểu dữ liệu, hoặc sử dụng trực tiếp trong một biểu thức/câu lệnh khác.<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token comment">// Gọi hàm và lưu kết quả vào biến</span>
<span class="token keyword">int</span> currentScore <span class="token operator">=</span> <span class="token function">GetCurrentScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Current score obtained from function: "</span> <span class="token operator">+</span> currentScore<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Sử dụng trực tiếp trong câu lệnh if</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsGameFinished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"The game has finished!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... (Xử lý kết thúc game) ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// Gọi hàm tạo thông báo và in ra</span>
<span class="token keyword">string</span> status <span class="token operator">=</span> <span class="token function">CreateStatusMessage</span><span class="token punctuation">(</span><span class="token string">"Game Status:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li><strong>Thực hành:</strong>
<ul>
<li>Trong script <code>GameManager</code>, định nghĩa hàm <code>int GetCurrentScore()</code> và hàm <code>bool IsGameFinished()</code> (có thể dùng phiên bản đơn giản ban đầu chỉ dựa vào <code>isGameOver</code> và <code>gameTimer</code>).</li>
<li>Trong hàm <code>Update()</code>, thay vì kiểm tra <code>isGameOver</code> và <code>gameTimer</code> trực tiếp trong <code>if</code>, hãy gọi hàm <code>IsGameFinished()</code>:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsGameFinished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Gọi hàm kiểm tra</span>
<span class="token punctuation">{</span>
     <span class="token comment">// Nếu game đã kết thúc... (Xử lý tương tự như trước)</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>isGameOver <span class="token operator">==</span> <span class="token keyword">false</span><span class="token punctuation">)</span> <span class="token comment">// Chỉ đặt lại và log một lần</span>
     <span class="token punctuation">{</span>
         isGameOver <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
         Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"GAME FINISHED!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{</span>
     <span class="token comment">// Game đang chạy... (có thể bỏ log ở đây)</span>
     <span class="token comment">// Giảm timer</span>
     gameTimer <span class="token operator">-</span><span class="token operator">=</span> Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Gọi hàm lấy điểm và in ra (chỉ để test)</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token function">GetKeyDown</span><span class="token punctuation">(</span>KeyCode<span class="token punctuation">.</span>DownArrow<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> scoreFromFunc <span class="token operator">=</span> <span class="token function">GetCurrentScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Checked score via function: "</span> <span class="token operator">+</span> scoreFromFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre>
</li>
<li>Lưu script, quay lại Unity, nhấn Play. Kiểm tra xem logic hết giờ có còn hoạt động đúng không. Thử nhấn mũi tên xuống để xem điểm số được lấy từ hàm.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Phần 3: Phạm vi Biến (Variable Scope) - Biến Sống Ở đâu?</strong>
<ul>
<li><strong>Biến Thành viên (Member/Instance Variables):</strong> Là các biến bạn khai báo <em>bên trong lớp</em> nhưng <em>bên ngoài tất cả các hàm</em> (như <code>playerScore</code>, <code>gameTimer</code> chúng ta đã khai báo). Chúng tồn tại và giữ giá trị trong suốt thời gian GameObject chứa script tồn tại. Chúng có thể được truy cập từ <em>bất kỳ hàm nào</em> bên trong lớp đó.</li>
<li><strong>Biến Cục bộ (Local Variables):</strong> Là các biến bạn khai báo <em>bên trong một hàm</em> (ví dụ: <code>int i</code> trong vòng lặp <code>for</code>, hoặc biến <code>status</code> trong hàm <code>CreateStatusMessage</code>). Chúng chỉ tồn tại và chỉ có thể được truy cập <em>từ bên trong hàm đó</em> mà thôi. Khi hàm kết thúc, biến cục bộ sẽ bị hủy.<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">ExampleScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> localValue <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Biến cục bộ</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Local value inside function: "</span> <span class="token operator">+</span> localValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Debug.Log(playerScore); // OK - Có thể truy cập biến thành viên</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">AnotherFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Debug.Log(localValue); // LỖI! Không thể truy cập biến cục bộ của hàm khác</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><strong>Tại sao quan trọng?</strong> Hiểu về scope giúp bạn tránh lỗi truy cập biến không tồn tại và giúp quản lý bộ nhớ hiệu quả hơn (biến cục bộ tự giải phóng khi không cần).</li>
</ul>
</li>
<li><strong>Áp dụng vào Puzzle Quest:</strong>
<ul>
<li>Bây giờ hãy suy nghĩ về các hàm cần thiết cho game “Puzzle Quest” (Memory Match) và chúng cần nhận/trả về gì:
<ul>
<li><code>SetupBoard(int rows, int cols)</code>: Nhận số hàng/cột, không trả về gì (<code>void</code>).</li>
<li><code>CardClicked(GameObject cardObject)</code>: Nhận đối tượng thẻ được click, không trả về gì (<code>void</code>).</li>
<li><code>CheckForMatch()</code>: Không cần tham số, không trả về gì (<code>void</code>), nhưng sẽ gọi các hàm khác.</li>
<li><code>bool AreCardsMatching(Card card1, Card card2)</code>: Nhận 2 thẻ, trả về <code>true</code> nếu trùng, <code>false</code> nếu không.</li>
<li><code>void AwardPoints(int amount)</code>: Nhận số điểm, không trả về gì (<code>void</code>).</li>
<li><code>bool CheckWinCondition()</code>: Không cần tham số, trả về <code>true</code> nếu thắng, <code>false</code> nếu chưa.</li>
</ul>
</li>
<li>Hãy thử viết <em>khung sườn</em> (chỉ có định nghĩa hàm, chưa cần code bên trong) cho một vài hàm này trong script <code>GameManager</code> của bạn.</li>
</ul>
</li>
<li><strong>Kết luận:</strong> Sử dụng tham số và giá trị trả về giúp hàm của bạn trở nên cực kỳ linh hoạt và hữu ích. Chúng là công cụ cốt lõi để xây dựng logic game phức tạp một cách có tổ chức. Hãy luyện tập sử dụng chúng thường xuyên!</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV review nhanh hàm <code>void</code> từ buổi trước: “Chúng ta đã tạo hàm <code>PrintWelcomeMessage</code>. Nó làm tốt một việc cố định. Nhưng nếu chúng ta muốn hàm <code>AddScore</code> có thể cộng 10 điểm lúc này, 50 điểm lúc khác thì sao? Hoặc nếu chúng ta muốn biết <em>kết quả</em> sau khi hàm <code>CheckWinCondition</code> chạy xong là thắng hay chưa?”</li>
<li>Đặt vấn đề: “Hàm <code>void</code> đơn giản có giới hạn. Chúng ta cần cách để ‘gửi’ thông tin vào hàm và cách để hàm ‘báo cáo’ kết quả trở lại.”</li>
<li>Giới thiệu chủ đề: “Hôm nay, chúng ta sẽ nâng cấp kỹ năng viết hàm bằng cách tìm hiểu về <strong>Tham số</strong> (Parameters - cách đưa dữ liệu vào) và <strong>Giá trị trả về</strong> (Return Values - cách lấy kết quả ra).”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo ra nhu cầu về chức năng nâng cao của hàm, giới thiệu hai khái niệm chính của buổi học (tham số, giá trị trả về).</li>
</ul>
<p><strong>2. Explore (Khám phá - 45 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Nâng Cấp Hàm C#: Truyền Dữ liệu và Nhận Kết quả”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu trên script <code>GameManager</code>:
<ul>
<li><strong>Tham số:</strong>
<ul>
<li>Định nghĩa hàm <code>void AddScore(int pointsToAdd)</code>.</li>
<li>Thêm code vào <code>Update()</code> để gọi <code>AddScore(10)</code> khi nhấn phím (ví dụ: UpArrow).</li>
<li>Play test, nhấn phím và kiểm tra kết quả (điểm tăng).</li>
</ul>
</li>
<li><strong>Giá trị trả về:</strong>
<ul>
<li>Định nghĩa hàm <code>int GetCurrentScore()</code>.</li>
<li>Định nghĩa hàm <code>bool IsGameFinished()</code> (phiên bản đơn giản).</li>
<li>Sửa đổi <code>Update()</code> để gọi <code>IsGameFinished()</code> trong câu lệnh <code>if</code>.</li>
<li>Thêm code vào <code>Update()</code> để gọi <code>GetCurrentScore()</code> khi nhấn phím khác (ví dụ: DownArrow) và <code>Debug.Log</code> kết quả.</li>
<li>Play test, kiểm tra logic hết giờ và log điểm khi nhấn phím.</li>
</ul>
</li>
<li><strong>Phạm vi Biến:</strong> Đọc và hiểu phần giải thích về biến cục bộ và biến thành viên.</li>
<li><strong>Áp dụng Puzzle Quest:</strong> Viết khung sườn (chỉ định nghĩa tên hàm, tham số, kiểu trả về) cho một vài hàm logic chính của game Puzzle Quest như gợi ý trong tài liệu.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giải thích cú pháp định nghĩa/gọi hàm có tham số/trả về nếu HS gặp khó khăn.</li>
<li>Đảm bảo HS hiểu cách truyền đối số và cách nhận/sử dụng giá trị trả về.</li>
<li>Kiểm tra việc áp dụng hàm mới vào logic <code>Update()</code>.</li>
<li>Gợi ý cách đặt tên hàm và xác định tham số/kiểu trả về cho các hàm của Puzzle Quest.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp việc định nghĩa, gọi hàm có tham số và trả về giá trị, sử dụng kết quả trả về, hiểu về scope và bắt đầu áp dụng vào cấu trúc game.</li>
</ul>
<p><strong>3. Explain (Giải thích - 30 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu lại script <code>GameManager</code> với các hàm vừa thêm.</li>
<li><strong>Tham số:</strong>
<ul>
<li>Giải thích lại “Tại sao cần?” bằng ví dụ <code>AddScore</code>. Phân biệt rõ <strong>Tham số</strong> (khai báo trong định nghĩa hàm) và <strong>Đối số</strong> (giá trị truyền vào khi gọi hàm).</li>
<li>Cách khai báo nhiều tham số, thứ tự quan trọng.</li>
</ul>
</li>
<li><strong>Giá trị trả về:</strong>
<ul>
<li>Giải thích lại “Tại sao cần?” bằng ví dụ <code>IsGameFinished</code>.</li>
<li>Nhấn mạnh việc phải chỉ định <strong>kiểu dữ liệu trả về</strong> (thay cho <code>void</code>).</li>
<li>Giải thích vai trò của từ khóa <code>return</code> (trả về giá trị VÀ kết thúc hàm ngay lập tức). Một hàm chỉ có thể <code>return</code> một giá trị.</li>
<li>Cách sử dụng giá trị trả về (gán vào biến, dùng trong <code>if</code>,…).</li>
</ul>
</li>
<li><strong>Phạm vi Biến (Scope):</strong>
<ul>
<li>Vẽ sơ đồ đơn giản hoặc dùng ví dụ code để minh họa sự khác biệt giữa biến khai báo trong hàm (local) và ngoài hàm (member). Nhấn mạnh vòng đời và khả năng truy cập.</li>
</ul>
</li>
<li><strong>Liên hệ Puzzle Quest:</strong> Thảo luận về các hàm khung sườn HS đã viết. Tại sao hàm <code>SetupBoard</code> cần tham số? Tại sao hàm <code>AreCardsMatching</code> cần trả về <code>bool</code>?</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Cung cấp giải thích sâu sắc về cơ chế hoạt động, cú pháp và lợi ích của tham số, giá trị trả về, làm rõ khái niệm scope, và kết nối lý thuyết với việc thiết kế cấu trúc game.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử nghiệm nhanh):</strong>
<ul>
<li>GV yêu cầu HS:
<ul>
<li>Thử tạo một hàm mới <code>void DisplayScore()</code> chỉ để gọi <code>Debug.Log("Current Score: " + GetCurrentScore());</code>. Sau đó gọi <code>DisplayScore()</code> từ <code>Update()</code> thay vì gọi <code>GetCurrentScore()</code> và <code>Debug.Log</code> trực tiếp. Thấy được tính tổ chức tốt hơn.</li>
<li>Thử thêm một tham số <code>string prefix</code> vào hàm <code>AddScore</code> để in ra thông báo như: <code>AddScore(10, "MATCH BONUS:")</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS tự tổ chức lại code bằng hàm và thực hành thêm với tham số, củng cố kỹ năng.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh Code:</strong> GV yêu cầu HS chỉ ra hàm <code>AddScore</code> (có tham số) và hàm <code>IsGameFinished</code> (có trả về <code>bool</code>) trong script của mình. Yêu cầu chỉ ra dòng code gọi các hàm đó.</li>
<li><strong>Câu hỏi nhanh (Miệng/Viết):</strong>
<ol>
<li>Để một hàm có thể nhận dữ liệu đầu vào, ta khai báo cái gì trong dấu <code>()</code> khi định nghĩa hàm? (Tham số/Parameters)</li>
<li>Khi gọi hàm <code>AddScore(int points)</code>, <code>points</code> là tham số, vậy số <code>10</code> trong <code>AddScore(10);</code> được gọi là gì? (Đối số/Argument)</li>
<li>Nếu muốn hàm trả về một kết quả dạng số nguyên, ta dùng kiểu trả về nào thay cho <code>void</code>? (<code>int</code>)</li>
<li>Từ khóa nào dùng để trả về giá trị từ bên trong hàm? (<code>return</code>)</li>
<li>Biến khai báo bên trong một hàm được gọi là gì và chỉ dùng được ở đâu? (Biến cục bộ/Local variable, chỉ dùng trong hàm đó)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng định nghĩa và gọi hàm có tham số/trả về giá trị, hiểu biết về cú pháp và khái niệm scope.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV khen ngợi HS: “Các bạn đã làm chủ được những công cụ rất mạnh mẽ của hàm trong C#! Khả năng truyền dữ liệu và nhận kết quả sẽ giúp chúng ta xây dựng logic game phức tạp hơn rất nhiều.”</li>
<li>Tóm tắt các khái niệm chính: Tham số, Đối số, Kiểu trả về, <code>return</code>, Phạm vi Biến.</li>
<li>Giới thiệu buổi học tiếp theo: “Với nền tảng về hàm đã vững chắc, buổi sau chúng ta sẽ chính thức bắt tay vào việc áp dụng chúng để xây dựng logic cốt lõi cho màn chơi đầu tiên của ‘Puzzle Quest’ - tạo bàn chơi và xử lý việc lật thẻ!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.7-project---phát-triển-cấp-độ-và-thách-thức-xây-dựng-logic-game-cơ-bản">Giáo án Buổi học 1.4.7: Project - Phát triển Cấp độ và Thách Thức (Xây dựng Logic Game Cơ bản)</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest (Memory Match)<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.6 (biết về hàm có tham số, trả về giá trị, scope).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS phân tích và xác định được các bước logic chính cần thiết để triển khai một màn chơi Memory Match.</li>
<li>HS tạo được một Prefab đơn giản cho đối tượng thẻ bài (<code>CardPrefab</code>).</li>
<li>HS viết được hàm <code>SetupLevel()</code> trong script <code>GameManager</code> sử dụng <code>Instantiate</code> để tạo ra các thẻ bài từ Prefab và sắp xếp chúng trên màn hình.</li>
<li>HS viết được script <code>Card.cs</code> gắn vào <code>CardPrefab</code> để lưu trữ thông tin thẻ và xử lý sự kiện <code>OnMouseDown()</code> để thông báo cho <code>GameManager</code> khi thẻ được click.</li>
<li>HS triển khai được hàm <code>CardSelected()</code> trong <code>GameManager</code> để xử lý logic cơ bản khi một hoặc hai thẻ được chọn (lật thẻ, lưu trữ thẻ đã chọn).</li>
<li>HS sử dụng được <code>Debug.Log</code> tích cực để theo dõi luồng thực thi và trạng thái game trong quá trình phát triển.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity, VS Code/Visual Studio và có dự án “Puzzle Quest” từ buổi 1.4.6 (đã có script <code>GameManager</code> với các hàm khung sườn, đã import các sprite thẻ bài).</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Lập trình Màn chơi Puzzle Quest: Tạo Thẻ và Xử lý Lượt chọn” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Sơ đồ luồng logic (flowchart) cho game Memory Match.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Lập trình Màn chơi Puzzle Quest: Tạo Thẻ và Xử lý Lượt chọn"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li>
<p><strong>Giới thiệu:</strong> Đã đến lúc biến những ý tưởng và hàm khung sườn thành hiện thực! Hôm nay, chúng ta sẽ tập trung vào việc lập trình logic cốt lõi cho màn chơi “Puzzle Quest”: tạo ra các thẻ bài trên màn hình và xử lý khi người chơi lật chúng lên.</p>
</li>
<li>
<p><strong>Bước 1: Phân tích Logic Game Memory Match:</strong></p>
<ul>
<li>Hãy cùng xem lại các bước chính khi chơi:
<ol>
<li>Bắt đầu màn chơi: Các thẻ bài úp được sắp xếp ngẫu nhiên.</li>
<li>Người chơi chọn thẻ 1 -&gt; Thẻ được lật lên.</li>
<li>Người chơi chọn thẻ 2 -&gt; Thẻ 2 được lật lên.</li>
<li><strong>Kiểm tra:</strong>
<ul>
<li>Nếu 2 thẻ giống nhau -&gt; Giữ nguyên, ghi điểm, kiểm tra thắng.</li>
<li>Nếu 2 thẻ khác nhau -&gt; Úp cả 2 thẻ lại sau một chút.</li>
</ul>
</li>
<li>Lặp lại từ bước 2 cho đến khi tìm hết các cặp.</li>
</ol>
</li>
<li>Từ logic này, chúng ta cần các chức năng chính trong code: Tạo bàn chơi, Xử lý click thẻ, Lật thẻ, Lưu trữ thẻ đang chọn, Kiểm tra trùng khớp, Xử lý khi trùng/không trùng, Kiểm tra thắng.</li>
</ul>
</li>
<li>
<p><strong>Bước 2: Tạo Prefab cho Thẻ bài (<code>CardPrefab</code>):</strong></p>
<ul>
<li>Prefab giống như một “bản thiết kế” cho GameObject, giúp chúng ta tạo ra nhiều bản sao giống hệt nhau một cách dễ dàng.</li>
<li>Trong Scene <code>GameplayScene</code> (hoặc một Scene tạm), tạo một GameObject 2D: <code>GameObject</code> -&gt; <code>2D Object</code> -&gt; <code>Sprite</code>.</li>
<li>Đặt tên GameObject này là <code>CardTemplate</code>.</li>
<li>Chọn <code>CardTemplate</code>. Trong Inspector, component <code>Sprite Renderer</code>:
<ul>
<li>Tìm thuộc tính <code>Sprite</code>. Kéo thả sprite mặt sau của thẻ bài (<code>Card_Back.png</code>) từ thư mục <code>_Sprites</code> vào đây.</li>
</ul>
</li>
<li><strong>Thêm Collider:</strong> Nhấn “Add Component”, tìm và thêm <code>Box Collider 2D</code>. Nó sẽ tự động điều chỉnh kích thước theo sprite. Collider này cần thiết để phát hiện click chuột.</li>
<li><strong>Tạo Script cho Thẻ:</strong> Trong thư mục <code>_Scripts</code>, tạo một C# Script mới tên là <code>Card</code>.</li>
<li>Gắn script <code>Card</code> vào GameObject <code>CardTemplate</code>.</li>
<li><em>Hình ảnh minh họa GameObject CardTemplate với Sprite Renderer, Box Collider 2D và Script Card.</em></li>
<li><strong>Tạo Prefab:</strong> Kéo thả GameObject <code>CardTemplate</code> từ cửa sổ <strong>Hierarchy</strong> vào thư mục <code>_Prefabs</code> trong cửa sổ <strong>Project</strong>. Bạn sẽ thấy một file mới <code>CardTemplate.prefab</code> xuất hiện với biểu tượng khối màu xanh. Giờ bạn có thể xóa <code>CardTemplate</code> khỏi Hierarchy (vì chúng ta sẽ tạo thẻ bằng code).</li>
<li><em>Hình ảnh minh họa kéo thả tạo Prefab.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 3: Lập trình Script <code>Card.cs</code>:</strong></p>
<ul>
<li>Mở script <code>Card</code>. Script này sẽ chứa thông tin của <em>một</em> thẻ bài và xử lý khi nó được click.</li>
<li>Thêm code sau:</li>
</ul>
<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Card</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token comment">// Thông tin của thẻ (sẽ được GameManager gán)</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> cardID<span class="token punctuation">;</span> <span class="token comment">// Một mã số định danh cho biểu tượng thẻ</span>
    <span class="token keyword">public</span> Sprite cardFaceSprite<span class="token punctuation">;</span> <span class="token comment">// Sprite mặt trước của thẻ</span>
    <span class="token keyword">public</span> Sprite cardBackSprite<span class="token punctuation">;</span> <span class="token comment">// Sprite mặt sau (có thể lấy từ GameManager hoặc gán sẵn)</span>

    <span class="token comment">// Trạng thái của thẻ</span>
    <span class="token keyword">private</span> <span class="token keyword">bool</span> isFlipped <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> isMatched <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span> <span class="token comment">// Public để GameManager kiểm tra</span>

    <span class="token comment">// Tham chiếu cần thiết</span>
    <span class="token keyword">private</span> SpriteRenderer spriteRenderer<span class="token punctuation">;</span>
    <span class="token keyword">private</span> GameManager gameManager<span class="token punctuation">;</span> <span class="token comment">// Để gọi hàm xử lý khi được click</span>

    <span class="token keyword">void</span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Awake chạy trước Start, tốt cho việc lấy component</span>
    <span class="token punctuation">{</span>
        spriteRenderer <span class="token operator">=</span> <span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>SpriteRenderer<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        gameManager <span class="token operator">=</span> <span class="token generic-method function">FindObjectOfType<span class="token punctuation">&lt;</span>GameManager<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tìm GameManager trong Scene</span>

        <span class="token comment">// Lấy sprite mặt sau (có thể cải tiến cách này sau)</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>spriteRenderer<span class="token punctuation">.</span>sprite <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// Kiểm tra xem đã có sprite chưa</span>
         <span class="token punctuation">{</span>
            cardBackSprite <span class="token operator">=</span> spriteRenderer<span class="token punctuation">.</span>sprite<span class="token punctuation">;</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            Debug<span class="token punctuation">.</span><span class="token function">LogError</span><span class="token punctuation">(</span><span class="token string">"Card Back Sprite not assigned to Sprite Renderer on Card Prefab!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Hàm này được Unity tự động gọi khi click chuột lên Collider của GameObject này</span>
    <span class="token keyword">void</span> <span class="token function">OnMouseDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Chỉ xử lý click nếu thẻ chưa bị khớp và đang được phép click (do GameManager quản lý)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMatched <span class="token operator">&amp;&amp;</span> gameManager<span class="token punctuation">.</span><span class="token function">CanPlayerClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Thêm hàm CanPlayerClick() vào GameManager</span>
        <span class="token punctuation">{</span>
            <span class="token function">Flip</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Lật thẻ lên mặt trước</span>
            gameManager<span class="token punctuation">.</span><span class="token function">CardSelected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Thông báo cho GameManager thẻ này được chọn</span>
                                           <span class="token comment">// 'this' tham chiếu đến chính đối tượng Card này</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Hàm để lật thẻ (hiển thị mặt trước hoặc mặt sau)</span>
    <span class="token comment">// Public để GameManager có thể gọi khi cần úp thẻ lại</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Flip</span><span class="token punctuation">(</span><span class="token keyword">bool</span> showFace<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>showFace<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            spriteRenderer<span class="token punctuation">.</span>sprite <span class="token operator">=</span> cardFaceSprite<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            spriteRenderer<span class="token punctuation">.</span>sprite <span class="token operator">=</span> cardBackSprite<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        isFlipped <span class="token operator">=</span> showFace<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Hàm để GameManager thiết lập thông tin ban đầu cho thẻ</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SetCardInfo</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> Sprite faceSprite<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cardID <span class="token operator">=</span> id<span class="token punctuation">;</span>
        cardFaceSprite <span class="token operator">=</span> faceSprite<span class="token punctuation">;</span>
        <span class="token comment">// Đảm bảo thẻ bắt đầu úp</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>spriteRenderer <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Đảm bảo đã lấy SpriteRenderer</span>
        spriteRenderer<span class="token punctuation">.</span>sprite <span class="token operator">=</span> cardBackSprite<span class="token punctuation">;</span>
        isFlipped <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
        isMatched <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>Giải thích:</strong>
<ul>
<li>Lưu trữ <code>cardID</code>, <code>cardFaceSprite</code>, <code>cardBackSprite</code>.</li>
<li>Lưu trạng thái <code>isFlipped</code>, <code>isMatched</code>.</li>
<li><code>Awake()</code>: Lấy <code>SpriteRenderer</code> và <code>GameManager</code>.</li>
<li><code>OnMouseDown()</code>: Hàm quan trọng xử lý click, gọi hàm trong <code>GameManager</code>.</li>
<li><code>Flip()</code>: Hàm thay đổi sprite hiển thị (mặt trước/sau).</li>
<li><code>SetCardInfo()</code>: Hàm để <code>GameManager</code> gán dữ liệu khi tạo thẻ.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Bước 4: Lập trình Script <code>GameManager.cs</code> - Tạo Bàn Chơi:</strong></p>
<ul>
<li>Mở script <code>GameManager</code>.</li>
<li><strong>Thêm các biến thành viên cần thiết:</strong><pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">public</span> GameObject cardPrefab<span class="token punctuation">;</span> <span class="token comment">// Kéo CardPrefab vào đây trong Inspector</span>
<span class="token keyword">public</span> Transform cardsParent<span class="token punctuation">;</span> <span class="token comment">// Một GameObject rỗng trong Scene để chứa các thẻ cho gọn</span>
<span class="token keyword">public</span> List<span class="token operator">&lt;</span>Sprite<span class="token operator">&gt;</span> availableCardFaces<span class="token punctuation">;</span> <span class="token comment">// Danh sách các sprite mặt trước có thể dùng</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> gridRows <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// Số hàng</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> gridCols <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// Số cột</span>
<span class="token keyword">public</span> <span class="token keyword">float</span> offsetX <span class="token operator">=</span> <span class="token number">2f</span><span class="token punctuation">;</span> <span class="token comment">// Khoảng cách giữa các thẻ theo trục X</span>
<span class="token keyword">public</span> <span class="token keyword">float</span> offsetY <span class="token operator">=</span> <span class="token number">2.5f</span><span class="token punctuation">;</span> <span class="token comment">// Khoảng cách giữa các thẻ theo trục Y</span>

<span class="token keyword">private</span> List<span class="token operator">&lt;</span>Card<span class="token operator">&gt;</span> boardCards <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>Card<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Danh sách lưu các thẻ đã tạo</span>
<span class="token keyword">private</span> List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> cardIDs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Danh sách ID để xáo trộn</span>
<span class="token comment">// ... (Các biến khác đã có: firstSelectedCard, secondSelectedCard, ...)</span>
<span class="token keyword">private</span> <span class="token keyword">bool</span> canPlayerClick <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment">// Thêm biến này</span>
</code></pre>
</li>
<li><strong>Viết hàm <code>SetupBoard()</code>:</strong> (Sửa hàm khung sườn đã có)<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">SetupBoard</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    boardCards<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Xóa thẻ cũ nếu chơi lại</span>
    cardIDs<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> totalCards <span class="token operator">=</span> gridRows <span class="token operator">*</span> gridCols<span class="token punctuation">;</span>
    <span class="token keyword">int</span> totalPairs <span class="token operator">=</span> totalCards <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>availableCardFaces<span class="token punctuation">.</span>Count <span class="token operator">&lt;</span> totalPairs<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">LogError</span><span class="token punctuation">(</span><span class="token string">"Not enough card faces provided for the grid size!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 1. Chuẩn bị danh sách ID (mỗi ID xuất hiện 2 lần)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalPairs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cardIDs<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cardIDs<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 2. Xáo trộn danh sách ID (Fisher-Yates Shuffle - có thể dùng thuật toán đơn giản hơn ban đầu)</span>
    <span class="token comment">// Thuật toán đơn giản: Lặp nhiều lần, swap 2 vị trí ngẫu nhiên</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cardIDs<span class="token punctuation">.</span>Count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> randomIndex <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> cardIDs<span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> cardIDs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        cardIDs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cardIDs<span class="token punctuation">[</span>randomIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        cardIDs<span class="token punctuation">[</span>randomIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Shuffled IDs: "</span> <span class="token operator">+</span> <span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">,</span> cardIDs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// In ra để kiểm tra</span>

    <span class="token comment">// 3. Tạo các thẻ bài bằng Prefab</span>
    Vector3 startPos <span class="token operator">=</span> cardsParent<span class="token punctuation">.</span>position<span class="token punctuation">;</span> <span class="token comment">// Vị trí bắt đầu (của GameObject cardsParent)</span>
    <span class="token keyword">int</span> cardIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> row <span class="token operator">&lt;</span> gridRows<span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> gridCols<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// Tính toán vị trí cho thẻ hiện tại</span>
            <span class="token keyword">float</span> posX <span class="token operator">=</span> startPos<span class="token punctuation">.</span>x <span class="token operator">+</span> col <span class="token operator">*</span> offsetX<span class="token punctuation">;</span>
            <span class="token keyword">float</span> posY <span class="token operator">=</span> startPos<span class="token punctuation">.</span>y <span class="token operator">-</span> row <span class="token operator">*</span> offsetY<span class="token punctuation">;</span> <span class="token comment">// Dùng trừ để đi xuống</span>
            Vector3 cardPosition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector3</span><span class="token punctuation">(</span>posX<span class="token punctuation">,</span> posY<span class="token punctuation">,</span> startPos<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// Tạo một bản sao của CardPrefab tại vị trí tính toán</span>
            GameObject newCardObject <span class="token operator">=</span> <span class="token function">Instantiate</span><span class="token punctuation">(</span>cardPrefab<span class="token punctuation">,</span> cardPosition<span class="token punctuation">,</span> Quaternion<span class="token punctuation">.</span>identity<span class="token punctuation">,</span> cardsParent<span class="token punctuation">)</span><span class="token punctuation">;</span>
            newCardObject<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Card_"</span> <span class="token operator">+</span> row <span class="token operator">+</span> <span class="token string">"_"</span> <span class="token operator">+</span> col<span class="token punctuation">;</span> <span class="token comment">// Đặt tên cho dễ debug</span>

            <span class="token comment">// Lấy script Card từ đối tượng vừa tạo</span>
            Card newCard <span class="token operator">=</span> newCardObject<span class="token punctuation">.</span><span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>Card<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>newCard <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment">// Lấy ID và Sprite tương ứng từ danh sách đã xáo trộn</span>
                <span class="token keyword">int</span> id <span class="token operator">=</span> cardIDs<span class="token punctuation">[</span>cardIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
                Sprite faceSprite <span class="token operator">=</span> availableCardFaces<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>

                <span class="token comment">// Thiết lập thông tin cho thẻ</span>
                newCard<span class="token punctuation">.</span><span class="token function">SetCardInfo</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> faceSprite<span class="token punctuation">)</span><span class="token punctuation">;</span>

                boardCards<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>newCard<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Thêm vào danh sách quản lý</span>
                cardIndex<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                 Debug<span class="token punctuation">.</span><span class="token function">LogError</span><span class="token punctuation">(</span><span class="token string">"Card script not found on prefab!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
     canPlayerClick <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment">// Cho phép click sau khi tạo xong</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><strong>Gọi <code>SetupBoard()</code> từ <code>Start()</code>:</strong> Đảm bảo trong hàm <code>Start()</code> có dòng <code>SetupBoard();</code>.</li>
<li><strong>Thêm hàm <code>CanPlayerClick()</code>:</strong><pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">CanPlayerClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> canPlayerClick<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Bước 5: Lập trình <code>GameManager.cs</code> - Xử lý Chọn Thẻ:</strong></p>
<ul>
<li><strong>Thêm biến thành viên:</strong><pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">private</span> Card firstSelectedCard <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> Card secondSelectedCard <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li><strong>Viết hàm <code>CardSelected(Card card)</code>:</strong> (Sửa hàm khung sườn)<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CardSelected</span><span class="token punctuation">(</span>Card card<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstSelectedCard <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// Chưa có thẻ nào được chọn</span>
    <span class="token punctuation">{</span>
        firstSelectedCard <span class="token operator">=</span> card<span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"First card selected: ID "</span> <span class="token operator">+</span> card<span class="token punctuation">.</span>cardID<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Đã chọn thẻ thứ nhất, và thẻ vừa click *không phải* là thẻ thứ nhất</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>secondSelectedCard <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> card <span class="token operator">!=</span> firstSelectedCard<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        secondSelectedCard <span class="token operator">=</span> card<span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Second card selected: ID "</span> <span class="token operator">+</span> card<span class="token punctuation">.</span>cardID<span class="token punctuation">)</span><span class="token punctuation">;</span>
        canPlayerClick <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span> <span class="token comment">// Không cho click nữa trong khi kiểm tra</span>
        <span class="token comment">// --- Sẽ gọi hàm kiểm tra trùng khớp ở đây (Buổi sau) ---</span>
         <span class="token comment">// Invoke("CheckMatch", 1f); // Ví dụ gọi hàm CheckMatch sau 1 giây</span>
         Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Checking for match..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tạm thời log</span>
         <span class="token comment">// Tạm thời reset để có thể chọn lại (cho mục đích test buổi này)</span>
         <span class="token function">StartCoroutine</span><span class="token punctuation">(</span><span class="token function">TemporaryResetForTesting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Trường hợp click lại vào thẻ đầu tiên thì không làm gì cả (hoặc có thể cho úp lại)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Hàm tạm thời để test</span>
 System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>IEnumerator <span class="token function">TemporaryResetForTesting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
      <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WaitForSeconds</span><span class="token punctuation">(</span><span class="token number">1.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Chờ 1.5 giây</span>

      <span class="token comment">// Nếu 2 thẻ đã được chọn (chưa xử lý khớp/trượt) -&gt; úp lại</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>firstSelectedCard <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> secondSelectedCard <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>firstSelectedCard<span class="token punctuation">.</span>isMatched<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
           firstSelectedCard<span class="token punctuation">.</span><span class="token function">Flip</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           secondSelectedCard<span class="token punctuation">.</span><span class="token function">Flip</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Resetting selection (Temporary)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      firstSelectedCard <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      secondSelectedCard <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      canPlayerClick <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment">// Cho phép click lại</span>
 <span class="token punctuation">}</span>
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Bước 6: Thiết lập trong Unity Editor:</strong></p>
<ul>
<li>Mở Scene <code>GameplayScene</code>.</li>
<li>Tạo một GameObject rỗng tên là <code>CardsParent</code>. Đặt vị trí của nó ở nơi bạn muốn lưới thẻ bắt đầu (ví dụ: góc trên bên trái màn hình).</li>
<li>Chọn GameObject <code>GameManager</code>. Trong Inspector:
<ul>
<li>Kéo Prefab <code>CardTemplate.prefab</code> từ thư mục <code>_Prefabs</code> vào ô <code>Card Prefab</code>.</li>
<li>Kéo GameObject <code>CardsParent</code> từ Hierarchy vào ô <code>Cards Parent</code>.</li>
<li>Trong ô <code>Available Card Faces</code>:
<ul>
<li>Đặt <code>Size</code> bằng số lượng cặp thẻ bạn muốn (ví dụ: 8 cho lưới 4x4).</li>
<li>Kéo thả các sprite mặt trước khác nhau từ thư mục <code>_Sprites</code> vào từng ô <code>Element 0</code>, <code>Element 1</code>, …</li>
</ul>
</li>
<li>Điều chỉnh <code>Grid Rows</code>, <code>Grid Cols</code>, <code>Offset X</code>, <code>Offset Y</code> nếu cần.</li>
</ul>
</li>
<li><em>Hình ảnh minh họa việc gán các biến public trong Inspector của GameManager.</em></li>
</ul>
</li>
<li>
<p><strong>Bước 7: Play Test và Debug:</strong></p>
<ul>
<li>Mở cửa sổ <strong>Console</strong>.</li>
<li>Nhấn <strong>Play</strong>.</li>
<li>Quan sát: Các thẻ bài có được tạo ra và sắp xếp thành lưới không? Thông điệp “Shuffled IDs” có hiện ra không?</li>
<li>Thử click vào một thẻ. Nó có lật lên mặt trước không? Log “First card selected…” có hiện ra không?</li>
<li>Thử click vào thẻ thứ hai. Nó có lật lên không? Log “Second card selected…” và “Checking for match…” có hiện ra không? Sau khoảng 1.5 giây, hai thẻ có úp lại không?</li>
<li>Sử dụng <code>Debug.Log</code> thêm vào những chỗ nghi ngờ trong code nếu gặp lỗi để tìm ra vấn đề.</li>
</ul>
</li>
<li>
<p><strong>Kết luận:</strong> Chúc mừng! Bạn đã xây dựng được phần nền tảng quan trọng nhất của màn chơi: tạo ra bàn chơi ngẫu nhiên và xử lý được lượt chọn thẻ của người chơi. Buổi sau, chúng ta sẽ hoàn thiện logic kiểm tra trùng khớp và xử lý thắng thua.</p>
</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV: “Chúng ta đã có hàm, đã có ý tưởng về các hàm cần thiết cho Puzzle Quest. Giờ là lúc ‘lắp ráp’ chúng lại để tạo ra màn chơi thực sự!”</li>
<li>Đặt câu hỏi: “Để bắt đầu màn chơi lật hình, việc đầu tiên cần làm là gì?” (HS trả lời: Tạo ra các thẻ bài úp, sắp xếp chúng). “Làm sao để tạo nhiều thẻ bài giống nhau một cách hiệu quả?” (Gợi ý về Prefab). “Làm sao để biết người chơi click vào thẻ nào?” (Gợi ý về Collider và sự kiện click).</li>
<li>Nêu mục tiêu: “Hôm nay, chúng ta sẽ tập trung vào việc lập trình để: tạo ra bàn chơi với các thẻ bài từ Prefab, và xử lý khi người chơi click chọn một hoặc hai thẻ.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Kết nối kiến thức hàm với việc xây dựng gameplay cụ thể, nêu bật các nhiệm vụ chính của buổi học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 55 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Lập trình Màn chơi Puzzle Quest: Tạo Thẻ và Xử lý Lượt chọn”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li><strong>Phân tích Logic:</strong> Đọc và hiểu các bước logic của game.</li>
<li><strong>Tạo CardPrefab:</strong> Tạo GameObject <code>CardTemplate</code>, thêm Sprite Renderer (mặt sau), Box Collider 2D, script <code>Card</code>, rồi kéo vào thư mục <code>_Prefabs</code>.</li>
<li><strong>Lập trình <code>Card.cs</code>:</strong> Copy/gõ code cho script <code>Card</code>, bao gồm các biến, <code>Awake</code>, <code>OnMouseDown</code>, <code>Flip</code>, <code>SetCardInfo</code>.</li>
<li><strong>Lập trình <code>GameManager.cs</code> (Phần Setup):</strong> Thêm các biến cần thiết, viết hoàn chỉnh hàm <code>SetupBoard</code> (tạo ID, xáo trộn, <code>Instantiate</code> thẻ, gọi <code>SetCardInfo</code>). Gọi <code>SetupBoard</code> từ <code>Start</code>. Thêm hàm <code>CanPlayerClick</code>.</li>
<li><strong>Lập trình <code>GameManager.cs</code> (Phần Chọn thẻ):</strong> Thêm biến lưu thẻ đã chọn, viết hàm <code>CardSelected</code> để xử lý việc chọn thẻ 1, thẻ 2. Thêm hàm tạm thời <code>TemporaryResetForTesting</code>.</li>
<li><strong>Thiết lập Editor:</strong> Tạo <code>CardsParent</code>, gán các biến public (Prefab, Parent, Sprites…) cho <code>GameManager</code> trong Inspector.</li>
<li><strong>Play Test &amp; Debug:</strong> Chạy game, mở Console, kiểm tra việc tạo thẻ, click thẻ, log thông tin, xem thẻ có úp lại sau khi chọn 2 thẻ không. Sử dụng <code>Debug.Log</code> để tự gỡ lỗi nếu cần.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp HS tạo Prefab đúng cách.</li>
<li>Giải thích các hàm mới trong <code>Card.cs</code> (<code>Awake</code>, <code>OnMouseDown</code>).</li>
<li>Hỗ trợ HS viết hàm <code>SetupBoard</code>, đặc biệt là logic tạo/xáo trộn ID và vòng lặp <code>Instantiate</code>.</li>
<li>Giúp HS hiểu logic của hàm <code>CardSelected</code> và hàm reset tạm thời.</li>
<li>Kiểm tra kỹ việc gán các biến public trong Inspector (đây là nơi dễ gây lỗi).</li>
<li>Hướng dẫn cách đọc Console và đặt <code>Debug.Log</code> hiệu quả để tìm lỗi.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành áp dụng kiến thức về hàm, Prefab, Instantiate, xử lý sự kiện click (<code>OnMouseDown</code>), và debugging để xây dựng logic tạo bàn chơi và xử lý lượt chọn thẻ cơ bản.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu code <code>Card.cs</code> và các phần liên quan trong <code>GameManager.cs</code>.</li>
<li><strong>Prefab:</strong> Giải thích lại lợi ích của Prefab trong việc tạo nhiều đối tượng giống nhau.</li>
<li><strong><code>Card.cs</code>:</strong>
<ul>
<li><code>Awake()</code> vs <code>Start()</code>: Khi nào nên dùng <code>Awake</code> (thường để lấy component nội bộ).</li>
<li><code>OnMouseDown()</code>: Giải thích cách Unity tự động gọi hàm này khi có Collider và click chuột. Cách dùng <code>this</code> để tham chiếu đến chính script/GameObject hiện tại.</li>
<li>Sự phối hợp giữa <code>Card</code> và <code>GameManager</code>: <code>Card</code> chỉ biết thông tin của chính nó và báo cho <code>GameManager</code> khi được click. <code>GameManager</code> quản lý tổng thể.</li>
</ul>
</li>
<li><strong><code>GameManager.cs</code>:</strong>
<ul>
<li><strong><code>SetupBoard()</code>:</strong> Phân tích lại các bước: chuẩn bị dữ liệu (ID, Sprites), xáo trộn, tạo đối tượng (<code>Instantiate</code>), thiết lập thông tin cho đối tượng mới (<code>GetComponent</code>, gọi hàm <code>SetCardInfo</code>). Giải thích <code>Instantiate(prefab, position, rotation, parent)</code>.</li>
<li><strong>Logic Xáo trộn:</strong> Giải thích thuật toán xáo trộn đơn giản đã dùng.</li>
<li><strong><code>CardSelected()</code>:</strong> Phân tích luồng xử lý: kiểm tra thẻ 1, thẻ 2, chặn click, gọi hàm xử lý (tạm thời là reset).</li>
<li><strong>Coroutine (<code>TemporaryResetForTesting</code>)</strong>: Giới thiệu sơ bộ Coroutine là cách để thực hiện một hành động có độ trễ mà không làm đứng game (khác với việc dùng <code>Thread.Sleep</code>). <code>yield return new WaitForSeconds()</code> là cách phổ biến. <em>(Lưu ý: Nếu thấy phức tạp, có thể thay bằng cách dùng Invoke, hoặc chỉ log và yêu cầu HS tự reset game để test).</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Củng cố hiểu biết về Prefab, các hàm sự kiện (<code>Awake</code>, <code>OnMouseDown</code>), quy trình tạo đối tượng bằng code (<code>Instantiate</code>), logic xử lý sự kiện, và giới thiệu sơ bộ về Coroutine (hoặc Invoke) để tạo độ trễ.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử nghiệm nhanh):</strong>
<ul>
<li>GV yêu cầu HS:
<ul>
<li>Trong <code>GameManager</code>, thay đổi giá trị <code>gridRows</code> hoặc <code>gridCols</code> (ví dụ: 2x2) và xem <code>SetupBoard</code> có tự động tạo đúng số thẻ không (cần đảm bảo <code>availableCardFaces</code> đủ).</li>
<li>Trong hàm <code>TemporaryResetForTesting</code>, thay đổi giá trị <code>WaitForSeconds</code> và xem độ trễ úp thẻ thay đổi thế nào.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS thấy được tính linh hoạt của code khi thay đổi tham số đầu vào và tự điều chỉnh các giá trị để quan sát kết quả.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh:</strong> GV yêu cầu HS chạy game. Quan sát xem bàn chơi có được tạo ra đúng không. Yêu cầu HS click 2 thẻ và xác nhận chúng lật lên rồi úp lại sau một khoảng chờ. Xem nhanh Inspector của <code>GameManager</code> để đảm bảo các biến public đã được gán.</li>
<li><strong>Câu hỏi nhanh (Miệng):</strong>
<ol>
<li>Để tạo nhiều bản sao của một GameObject đã thiết kế sẵn, ta dùng cái gì? (Prefab)</li>
<li>Lệnh nào dùng để tạo một đối tượng mới từ Prefab bằng code? (<code>Instantiate</code>)</li>
<li>Hàm nào trong script được gọi khi người dùng click chuột lên Collider của GameObject đó? (<code>OnMouseDown</code>)</li>
<li>Tại sao script <code>Card</code> cần gọi hàm trong <code>GameManager</code> khi được click? (Để <code>GameManager</code> xử lý logic chung của game)</li>
<li>Trong hàm <code>SetupBoard</code>, tại sao chúng ta cần xáo trộn danh sách ID? (Để vị trí các cặp thẻ là ngẫu nhiên)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng tạo và sử dụng Prefab, <code>Instantiate</code>, xử lý <code>OnMouseDown</code>, và hiểu được luồng logic cơ bản của việc tạo bàn chơi và chọn thẻ.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV khen ngợi HS: “Tuyệt vời! Các bạn đã xây dựng được phần khung xương chính cho màn chơi Puzzle Quest. Các thẻ bài đã xuất hiện và chúng ta đã có thể tương tác lật chúng lên.”</li>
<li>Tóm tắt các kỹ năng chính: Prefab, Instantiate, OnMouseDown, phối hợp giữa các script.</li>
<li>Giới thiệu buổi học tiếp theo: “Phần thú vị nhất đang chờ đợi: buổi sau, chúng ta sẽ hoàn thiện logic kiểm tra xem hai thẻ có trùng khớp hay không, xử lý khi trùng/không trùng, và kiểm tra điều kiện chiến thắng!”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.8-project---tối-ưu-hóa-và-kiểm-tra-game">Giáo án Buổi học 1.4.8: Project - Tối Ưu Hóa và Kiểm Tra Game</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest (Memory Match)<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.7 (xây dựng xong logic cơ bản: tạo bàn, chọn thẻ, kiểm tra khớp, xử lý thắng - <em>giả định logic này đã hoàn thiện ở một bước trung gian hoặc được cung cấp code hoàn chỉnh</em>).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS nhận biết được một số vấn đề hiệu năng cơ bản có thể xảy ra trong game (ví dụ: gọi <code>GetComponent</code> trong <code>Update</code>, tạo/hủy đối tượng liên tục - <em>mặc dù game này ít gặp vấn đề này</em>).</li>
<li>HS thực hành kỹ thuật <strong>caching components</strong> (lưu tham chiếu component vào biến thành viên trong <code>Awake</code>/<code>Start</code>).</li>
<li>HS làm quen và sử dụng cơ bản công cụ <strong>Unity Profiler</strong> (<code>Window &gt; Analysis &gt; Profiler</code>) để xem thông tin về CPU Usage và Memory.</li>
<li>HS làm quen với việc sử dụng <strong>Breakpoints</strong> trong Visual Studio/VS Code để dừng và kiểm tra code từng bước (debug nâng cao).</li>
<li>HS tham gia vào quy trình <strong>playtesting</strong> (chơi thử game của bạn bè) và đưa ra phản hồi có cấu trúc về lỗi, trải nghiệm người chơi.</li>
<li>HS hiểu khái niệm <strong>Refactoring</strong> và thực hành tái cấu trúc code đơn giản (ví dụ: tách hàm, đổi tên biến/hàm cho rõ nghĩa) để cải thiện chất lượng code.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity, VS Code/Visual Studio và có dự án “Puzzle Quest” <em>đã hoàn thiện logic gameplay cơ bản</em> (bao gồm kiểm tra trùng khớp, xử lý thắng).</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Đánh bóng Puzzle Quest: Tối ưu hóa, Debug Nâng cao và Kiểm thử” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Phiếu phản hồi (Feedback Form) đơn giản cho buổi playtesting.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Đánh bóng Puzzle Quest: Tối ưu hóa, Debug Nâng cao và Kiểm thử"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Game của chúng ta đã có thể chơi được! Nhưng để nó thực sự tốt, chúng ta cần đảm bảo nó chạy mượt mà, không có lỗi ẩn, và mang lại trải nghiệm tốt cho người chơi. Hôm nay, chúng ta sẽ học các kỹ thuật để “đánh bóng” game: tối ưu hóa code, sử dụng công cụ debug mạnh mẽ hơn, kiểm thử game và cải thiện cấu trúc code.</li>
<li><strong>Phần 1: Tối ưu hóa Code Cơ bản (Code Optimization)</strong>
<ul>
<li><strong>Vấn đề:</strong> Đôi khi code chạy không hiệu quả có thể làm game bị chậm, giật (lag), đặc biệt trên các thiết bị yếu hơn.</li>
<li><strong>Kỹ thuật 1: Caching Components (Lưu trữ Tham chiếu Component):</strong>
<ul>
<li><strong>Vấn đề:</strong> Gọi hàm <code>GetComponent&lt;T&gt;()</code> (ví dụ: <code>GetComponent&lt;SpriteRenderer&gt;()</code>) nhiều lần, đặc biệt là trong <code>Update()</code> hoặc các hàm chạy thường xuyên, có thể tốn chi phí hiệu năng.</li>
<li><strong>Giải pháp:</strong> Gọi <code>GetComponent&lt;T&gt;()</code> <em>một lần</em> trong <code>Awake()</code> hoặc <code>Start()</code> và lưu kết quả vào một biến thành viên (private). Sau đó, sử dụng biến này bất cứ khi nào cần truy cập component đó.</li>
<li><strong>Ví dụ áp dụng cho <code>Card.cs</code>:</strong><pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Card</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token comment">// ... (Các biến khác) ...</span>
    <span class="token keyword">private</span> SpriteRenderer spriteRenderer<span class="token punctuation">;</span> <span class="token comment">// Biến thành viên để cache</span>
    <span class="token keyword">private</span> GameManager gameManager<span class="token punctuation">;</span> <span class="token comment">// Cache luôn GameManager</span>

    <span class="token keyword">void</span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Gọi GetComponent một lần ở đây và lưu vào biến</span>
        spriteRenderer <span class="token operator">=</span> <span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>SpriteRenderer<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        gameManager <span class="token operator">=</span> <span class="token generic-method function">FindObjectOfType<span class="token punctuation">&lt;</span>GameManager<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// FindObjectOfType cũng tốn, nên cache</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>spriteRenderer <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> Debug<span class="token punctuation">.</span><span class="token function">LogError</span><span class="token punctuation">(</span><span class="token string">"Sprite Renderer not found!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>gameManager <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> Debug<span class="token punctuation">.</span><span class="token function">LogError</span><span class="token punctuation">(</span><span class="token string">"Game Manager not found!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ... (Lấy cardBackSprite) ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Trong các hàm khác (Flip, OnMouseDown), dùng trực tiếp biến 'spriteRenderer' và 'gameManager'</span>
    <span class="token comment">// thay vì gọi lại GetComponent/FindObjectOfType</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Flip</span><span class="token punctuation">(</span><span class="token keyword">bool</span> showFace<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Dùng biến đã cache:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>showFace<span class="token punctuation">)</span> spriteRenderer<span class="token punctuation">.</span>sprite <span class="token operator">=</span> cardFaceSprite<span class="token punctuation">;</span>
        <span class="token keyword">else</span> spriteRenderer<span class="token punctuation">.</span>sprite <span class="token operator">=</span> cardBackSprite<span class="token punctuation">;</span>
        isFlipped <span class="token operator">=</span> showFace<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     <span class="token keyword">void</span> <span class="token function">OnMouseDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMatched <span class="token operator">&amp;&amp;</span> gameManager<span class="token punctuation">.</span><span class="token function">CanPlayerClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Dùng biến gameManager đã cache</span>
             <span class="token function">Flip</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             gameManager<span class="token punctuation">.</span><span class="token function">CardSelected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><strong>Thực hành:</strong> Mở script <code>Card.cs</code> và áp dụng kỹ thuật caching cho <code>SpriteRenderer</code> và <code>GameManager</code>.</li>
</ul>
</li>
<li><strong>Kỹ thuật 2: Hạn chế Code trong <code>Update()</code>:</strong>
<ul>
<li><strong>Vấn đề:</strong> <code>Update()</code> chạy mỗi frame. Nếu bạn đặt quá nhiều logic phức tạp hoặc các vòng lặp nặng trong <code>Update()</code>, nó có thể làm giảm frame rate.</li>
<li><strong>Giải pháp:</strong> Chỉ đặt những gì thực sự cần cập nhật mỗi frame vào <code>Update()</code> (ví dụ: kiểm tra input, cập nhật bộ đếm thời gian đơn giản). Cân nhắc chuyển các logic xử lý sự kiện sang các hàm riêng và chỉ gọi chúng khi cần thiết (ví dụ: hàm <code>CheckMatch</code> chỉ gọi khi người chơi đã chọn đủ 2 thẻ). <em>Trong game Puzzle Quest này, <code>Update</code> của chúng ta khá nhẹ nên ít ảnh hưởng.</em></li>
</ul>
</li>
<li><strong>(Giới thiệu nhanh) Vấn đề Garbage Collection (GC):</strong>
<ul>
<li>Việc tạo ra nhiều đối tượng tạm thời (đặc biệt là chuỗi string khi nối bằng <code>+</code> trong các vòng lặp, hoặc tạo <code>new Vector3()</code> liên tục trong <code>Update</code>) và sau đó bỏ đi sẽ khiến GC phải chạy để dọn dẹp bộ nhớ, gây khựng game. <em>Game này ít tạo đối tượng tạm nên chưa phải vấn đề lớn, nhưng cần biết để tránh sau này.</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>Phần 2: Debug Nâng cao - Unity Profiler và Breakpoints</strong>
<ul>
<li><strong>Unity Profiler:</strong> Công cụ cực mạnh để xem game đang tiêu tốn tài nguyên (CPU, bộ nhớ…) ở đâu.
<ul>
<li><strong>Cách mở:</strong> <code>Window</code> -&gt; <code>Analysis</code> -&gt; <code>Profiler</code>.</li>
<li><strong>Sử dụng cơ bản:</strong>
<ul>
<li>Nhấn nút “Record” trong cửa sổ Profiler.</li>
<li>Nhấn Play trong Unity Editor. Chơi game một lúc.</li>
<li>Nhấn Stop trong Editor.</li>
<li>Quan sát các biểu đồ trong Profiler, đặc biệt là “CPU Usage” và “Memory”. Nhấp vào một điểm trên biểu đồ CPU Usage, khung dưới sẽ hiển thị chi tiết các hàm nào đang chiếm nhiều thời gian xử lý nhất.</li>
</ul>
</li>
<li><em>Hình ảnh minh họa cửa sổ Profiler và cách đọc biểu đồ CPU Usage cơ bản.</em></li>
<li><strong>Thực hành:</strong> Mở Profiler, Record và chạy thử game của bạn. Xem biểu đồ CPU Usage. Có hàm nào trong script của bạn (ví dụ: <code>Update</code> trong <code>GameManager</code>) chiếm tỷ lệ cao bất thường không? (Trong game này thường là không đáng kể).</li>
</ul>
</li>
<li><strong>Breakpoints (Điểm dừng):</strong> Cho phép bạn tạm dừng game tại một dòng code cụ thể để kiểm tra giá trị biến và xem luồng thực thi từng bước.
<ul>
<li><strong>Cách đặt Breakpoint:</strong> Mở script trong Visual Studio/VS Code. Nhấp chuột vào lề trái của dòng code bạn muốn dừng lại. Một chấm đỏ sẽ xuất hiện.</li>
<li><strong>Cách Debug:</strong>
<ul>
<li>Trong Unity Editor, vào menu <code>Edit</code> -&gt; <code>Preferences</code> -&gt; <code>External Tools</code>. Đảm bảo “Editor Attaching” được bật.</li>
<li>Trong Visual Studio/VS Code, tìm nút “Attach to Unity” (thường là hình Play màu xanh lá có logo Unity) và nhấn vào đó. Chờ kết nối thành công.</li>
<li>Quay lại Unity Editor, nhấn Play.</li>
<li>Khi game chạy đến dòng code có breakpoint, nó sẽ tự động dừng lại và Visual Studio/VS Code sẽ hiện lên.</li>
<li>Bạn có thể di chuột qua tên biến để xem giá trị, xem các cửa sổ Locals/Watch để theo dõi biến, và sử dụng các nút Step Over (F10), Step Into (F11), Continue (F5) để điều khiển luồng thực thi.</li>
</ul>
</li>
<li><em>Hình ảnh minh họa đặt breakpoint và các nút điều khiển debug.</em></li>
<li><strong>Thực hành:</strong> Đặt một breakpoint trong hàm <code>CardSelected</code> của <code>GameManager</code> ngay sau khi thẻ thứ hai được chọn. Chạy game với Attach to Unity, click 2 thẻ và quan sát giá trị của <code>firstSelectedCard</code>, <code>secondSelectedCard</code> khi chương trình dừng lại. Thử nhấn Step Over để xem code chạy tiếp như thế nào.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Phần 3: Playtesting - Để Người khác Chơi Thử Game:</strong>
<ul>
<li><strong>Mục đích:</strong> Bạn làm game nên có thể bỏ qua những lỗi hoặc điểm khó hiểu mà người chơi mới sẽ gặp phải. Playtesting giúp tìm ra những vấn đề đó.</li>
<li><strong>Quy trình:</strong>
<ul>
<li>Trao đổi máy với một bạn khác.</li>
<li>Chơi thử game của bạn mình từ đầu đến cuối.</li>
<li>Trong quá trình chơi, ghi chú lại:
<ul>
<li><strong>Lỗi (Bugs):</strong> Có gì hoạt động sai không? (Ví dụ: thẻ không lật, điểm không cộng, không thắng được…).</li>
<li><strong>Trải nghiệm người dùng (UX):</strong> Có dễ hiểu cách chơi không? Có hướng dẫn đủ rõ? Âm thanh/hình ảnh có phù hợp? Có gì gây khó chịu?</li>
<li><strong>Điểm thú vị/Chưa thú vị:</strong> Thích nhất điểm nào? Có gì cần cải thiện?</li>
</ul>
</li>
<li>Sử dụng phiếu phản hồi (nếu có) hoặc ghi chú đơn giản.</li>
<li>Sau khi chơi xong, trao đổi lại các ghi chú/phản hồi với bạn mình một cách lịch sự và xây dựng.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Phần 4: Refactoring - Cải thiện Chất lượng Code:</strong>
<ul>
<li><strong>Mục đích:</strong> Sau khi game đã chạy đúng chức năng, chúng ta nên xem lại code để làm nó sạch sẽ, dễ đọc, dễ bảo trì hơn. Đây gọi là Refactoring.</li>
<li><strong>Các kỹ thuật đơn giản:</strong>
<ul>
<li><strong>Đổi tên rõ nghĩa:</strong> Đảm bảo tên biến, tên hàm thể hiện rõ mục đích của chúng (ví dụ: thay vì <code>int x</code>, dùng <code>int numberOfMatches</code>).</li>
<li><strong>Tách Hàm (Extract Method):</strong> Nếu một hàm trở nên quá dài và làm nhiều việc, hãy tách các khối logic có liên quan ra thành các hàm nhỏ hơn, có tên rõ ràng.
<ul>
<li><strong>Ví dụ:</strong> Trong <code>GameManager</code>, phần logic kiểm tra trùng khớp và xử lý kết quả (nếu đang nằm chung trong <code>CardSelected</code> hoặc một hàm lớn khác) có thể tách thành hàm riêng <code>ProcessMatchResult(bool isMatch)</code>.</li>
</ul>
</li>
<li><strong>Xóa Code Thừa/Comment Thừa:</strong> Loại bỏ những đoạn code không còn sử dụng hoặc các comment giải thích những điều hiển nhiên.</li>
</ul>
</li>
<li><strong>Thực hành:</strong> Xem lại script <code>GameManager</code> và <code>Card</code> của bạn. Có biến nào tên chưa rõ nghĩa không? Có hàm nào quá dài có thể tách nhỏ hơn không? (Ví dụ: phần xáo trộn thẻ trong <code>SetupBoard</code> có thể tách thành hàm <code>ShuffleCards()</code>). Tự thực hiện một vài cải tiến nhỏ.</li>
</ul>
</li>
<li><strong>Kết luận:</strong> Tối ưu hóa, debug nâng cao, playtesting và refactoring là những bước quan trọng để nâng tầm game của bạn từ “chạy được” thành “chạy tốt” và “dễ phát triển tiếp”. Hãy tập thói quen áp dụng chúng trong các dự án sau này.</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV: “Game Puzzle Quest của chúng ta về cơ bản đã hoàn thành logic! Nhưng liệu nó đã thực sự ‘tốt’ chưa? Nó chạy có mượt không? Người khác chơi có thấy dễ hiểu và không gặp lỗi không? Code chúng ta viết đã dễ đọc và dễ sửa sau này chưa?”</li>
<li>Đặt vấn đề: “Một game chạy đúng chức năng chỉ là bước đầu. Để làm game chuyên nghiệp, chúng ta cần quan tâm đến hiệu năng (performance), sửa lỗi triệt để (debugging), lắng nghe người chơi (playtesting) và làm cho code ‘sạch’ hơn (refactoring).”</li>
<li>Giới thiệu mục tiêu: “Hôm nay, chúng ta sẽ học cách sử dụng các công cụ và kỹ thuật để đánh bóng game: tối ưu code cơ bản, dùng Profiler và Breakpoint để tìm lỗi sâu hơn, tổ chức chơi thử và cải thiện cấu trúc code.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Nâng cao nhận thức về các khía cạnh chất lượng game ngoài chức năng cơ bản, giới thiệu các công cụ và khái niệm mới của buổi học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 50 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Đánh bóng Puzzle Quest: Tối ưu hóa, Debug Nâng cao và Kiểm thử”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li><strong>Tối ưu hóa:</strong> Áp dụng Caching Components cho <code>SpriteRenderer</code> và <code>GameManager</code> trong <code>Card.cs</code>. Đọc hiểu về hạn chế code trong <code>Update</code>.</li>
<li><strong>Profiler:</strong> Mở Profiler, Record, chạy game, quan sát biểu đồ CPU Usage và Memory cơ bản.</li>
<li><strong>Breakpoints:</strong> Đặt breakpoint trong <code>CardSelected</code> (hoặc hàm xử lý match), Attach to Unity, chạy game, quan sát giá trị biến khi game dừng lại, thử Step Over.</li>
<li><strong>Playtesting:</strong> Trao đổi máy với bạn bên cạnh. Chơi thử game của bạn và ghi lại phản hồi (lỗi, UX, điểm hay/dở) vào giấy hoặc phiếu. Sau đó nhận lại phản hồi về game của mình.</li>
<li><strong>Refactoring:</strong> Dựa trên hiểu biết và phản hồi, tự xem lại code <code>GameManager</code> hoặc <code>Card</code>. Thử đổi tên một biến cho rõ hơn hoặc tách một đoạn logic nhỏ ra hàm riêng (nếu thấy hợp lý).</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giúp HS áp dụng đúng kỹ thuật caching.</li>
<li>Hướng dẫn cách đọc Profiler ở mức cơ bản.</li>
<li>Hỗ trợ các bước Attach to Unity và sử dụng Breakpoint (phần này có thể mới và hơi phức tạp).</li>
<li>Quan sát và điều phối buổi playtesting, nhắc nhở đưa phản hồi xây dựng.</li>
<li>Gợi ý các điểm có thể refactor trong code của HS.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp các kỹ thuật tối ưu hóa cơ bản, làm quen với Profiler và Breakpoint, trải nghiệm quy trình playtesting và refactoring đơn giản.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu lại Profiler, cửa sổ Debug của VS Code/Visual Studio.</li>
<li><strong>Tối ưu hóa:</strong> Giải thích lại lý do tại sao Caching Components lại hiệu quả. Thảo luận nhanh về các tình huống khác có thể cần tối ưu (vật lý phức tạp, nhiều đối tượng, đồ họa nặng - dù không áp dụng nhiều cho game này).</li>
<li><strong>Profiler:</strong> Giải thích sâu hơn một chút về cách đọc biểu đồ CPU Usage: Hierarchy view (xem hàm nào gọi hàm nào), Self vs Total time. Mục tiêu là tìm ra " узкое место" (bottleneck).</li>
<li><strong>Breakpoints &amp; Debugging:</strong> Nhấn mạnh lợi ích so với <code>Debug.Log</code> (dừng lại xem được mọi thứ, chạy từng bước). Giải thích các nút điều khiển Step Over, Step Into, Continue.</li>
<li><strong>Playtesting:</strong> Thảo luận về tầm quan trọng của việc lấy phản hồi từ người chơi thực tế. Các loại phản hồi cần thu thập. Cách đưa và nhận phản hồi hiệu quả.</li>
<li><strong>Refactoring:</strong> Định nghĩa lại khái niệm. Mục tiêu: làm code dễ đọc, dễ hiểu, dễ bảo trì, dễ mở rộng hơn (không nhất thiết phải nhanh hơn). Lấy ví dụ cụ thể về việc tách hàm hoặc đổi tên biến.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Cung cấp hiểu biết sâu hơn về các công cụ và khái niệm, nhấn mạnh lợi ích và cách áp dụng hiệu quả trong quá trình phát triển game.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thảo luận nhanh):</strong>
<ul>
<li>GV đặt câu hỏi: “Dựa trên phản hồi playtesting, bạn nghĩ mình nên ưu tiên sửa lỗi nào trước? Hoặc cải thiện tính năng nào để game thú vị hơn?”</li>
<li>“Nếu muốn thêm một loại thẻ đặc biệt (ví dụ: thẻ cộng thêm giờ), bạn sẽ cần thay đổi những gì trong cấu trúc code hiện tại?” (Gợi ý về việc sửa <code>Card.cs</code>, <code>GameManager.cs</code>, thêm logic mới).</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS suy nghĩ về việc áp dụng phản hồi và mở rộng game dựa trên cấu trúc code hiện có, liên hệ refactoring với khả năng bảo trì/mở rộng.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh:</strong> GV yêu cầu HS mở Profiler khi chạy game. Yêu cầu HS chỉ ra vị trí đặt breakpoint trong code. Hỏi nhanh về một phản hồi cụ thể nhận được từ playtesting.</li>
<li><strong>Câu hỏi nhanh (Miệng):</strong>
<ol>
<li>Để tránh gọi <code>GetComponent</code> nhiều lần, ta dùng kỹ thuật gì? (Caching Components)</li>
<li>Công cụ nào của Unity dùng để xem hiệu năng CPU, Memory của game? (Profiler)</li>
<li>Tính năng nào trong trình soạn thảo code giúp dừng game tại một dòng code để kiểm tra? (Breakpoints)</li>
<li>Việc cho người khác chơi thử game của mình gọi là gì? (Playtesting)</li>
<li>Việc cải thiện cấu trúc code mà không làm thay đổi chức năng gọi là gì? (Refactoring)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá mức độ làm quen với các công cụ mới, hiểu biết về các khái niệm tối ưu hóa, playtesting, refactoring và khả năng áp dụng cơ bản.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt: “Hôm nay chúng ta đã học những kỹ năng quan trọng để nâng cao chất lượng game vượt ra ngoài việc chỉ chạy đúng chức năng. Tối ưu hóa, debug chuyên sâu, lắng nghe người chơi và làm code tốt hơn là những gì làm nên một nhà phát triển game giỏi.”</li>
<li>Nhấn mạnh: “Đây là những công cụ và quy trình các bạn nên tiếp tục sử dụng và cải thiện trong các dự án tương lai.”</li>
<li>Giới thiệu buổi học tiếp theo (nếu có): Có thể là buổi kiểm tra lý thuyết, hoặc bắt đầu một chủ đề mới/dự án mới, hoặc thời gian để hoàn thiện/mở rộng dự án Puzzle Quest dựa trên playtesting. (Ví dụ: “Buổi sau, chúng ta sẽ ôn tập lại toàn bộ kiến thức của học phần qua bài kiểm tra lý thuyết.”)</li>
</ul>
<hr>
<p>Okay, đây là dự thảo chi tiết cho Buổi 1.4.9, tập trung vào việc Kiểm tra Lý thuyết tổng kết Học phần 1.4, theo cấu trúc bạn mong muốn.</p>
<hr>
<h3 id="giáo-án-buổi-học-1.4.9-kiểm-tra-lý-thuyết-tổng-kết-học-phần-1.4">Giáo án Buổi học 1.4.9: Kiểm tra Lý thuyết Tổng kết Học phần 1.4</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest (Kiến thức áp dụng từ dự án này)<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành các buổi học trước của Học phần 1.4 (từ 1.4.1 đến 1.4.8).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS hệ thống hóa và nhớ lại các kiến thức, kỹ năng cốt lõi đã học trong Học phần 1.4, bao gồm: quản lý tài nguyên (Audio, Packages, Assets, Sprites), thiết kế UI cơ bản, và lập trình C# cơ bản với hàm/phương thức (biến, điều kiện, hàm void, hàm có tham số, hàm trả về giá trị, scope).</li>
<li>HS thực hiện một bài kiểm tra lý thuyết tổng hợp để đánh giá mức độ hiểu và ghi nhớ các khái niệm đã học.</li>
<li>HS xác định được những mảng kiến thức nào mình còn yếu hoặc chưa hiểu rõ để có kế hoạch tự ôn tập hoặc đặt câu hỏi.</li>
<li>HS có cơ hội đặt câu hỏi và được giải đáp các thắc mắc còn lại về nội dung học phần.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính cho HS (có thể không cần thiết nếu kiểm tra trên giấy).</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li>Đề kiểm tra lý thuyết (in giấy hoặc chuẩn bị trên nền tảng online - Google Forms, Quizizz, etc.). Nội dung bao quát các chủ đề chính của học phần.</li>
<li>Đáp án và thang điểm (nếu có) cho đề kiểm tra.</li>
<li><strong>Tài liệu ôn tập:</strong> (Tùy chọn - GV có thể cung cấp trước) Bảng tóm tắt các khái niệm chính, thuật ngữ, cú pháp C# cơ bản, chức năng các công cụ Unity đã học trong học phần.</li>
</ul>
<p><strong>Nội dung Đề kiểm tra Lý thuyết (Gợi ý):</strong><br>
<em>(Bao gồm các dạng câu hỏi trắc nghiệm, điền khuyết, nối cặp, trả lời ngắn)</em></p>
<ul>
<li><strong>Quản lý Tài nguyên &amp; Unity Editor:</strong>
<ul>
<li>Chức năng chính của <code>AudioListener</code> và <code>AudioSource</code>.</li>
<li>Thuộc tính nào của <code>AudioSource</code> dùng để lặp lại âm thanh? (Loop)</li>
<li>Công cụ nào dùng để quản lý các gói chức năng (packages) của Unity? (Package Manager)</li>
<li>Nơi nào để tìm và tải tài nguyên (hình ảnh, âm thanh…) cho game Unity? (Asset Store)</li>
<li>Khi import ảnh 2D cho game, <code>Texture Type</code> nên đặt là gì? (<code>Sprite (2D and UI)</code>)</li>
<li>Công cụ nào dùng để cắt ảnh từ sprite sheet? (Sprite Editor)</li>
<li>Đối tượng gốc chứa tất cả các yếu tố UI là gì? (Canvas)</li>
<li>Component nào dùng để định vị và co giãn UI? (Rect Transform)</li>
<li>Khái niệm nào giúp UI bám vào cạnh màn hình khi thay đổi kích thước? (Anchors)</li>
<li>Kể tên 2-3 thành phần UI cơ bản (Image, Text/TextMeshPro, Button).</li>
</ul>
</li>
<li><strong>Lập trình C# Cơ bản &amp; Hàm/Phương thức:</strong>
<ul>
<li>Làm thế nào để tạo một C# script mới trong Unity?</li>
<li>Lớp nào mà các script Unity thường kế thừa để tương tác với engine? (<code>MonoBehaviour</code>)</li>
<li>Hàm nào chạy 1 lần khi game bắt đầu? (<code>Start</code>) Hàm nào chạy mỗi frame? (<code>Update</code>)</li>
<li>Từ khóa nào khai báo biến có thể thấy trong Inspector? (<code>public</code>)</li>
<li>Kể tên 3 kiểu dữ liệu cơ bản trong C# (int, float, bool, string).</li>
<li>Lệnh nào dùng để in thông tin ra Console? (<code>Debug.Log()</code>)</li>
<li>Lệnh <code>if (condition) { ... }</code> dùng để làm gì? (Rẽ nhánh, thực thi code dựa trên điều kiện)</li>
<li>Lợi ích của việc sử dụng hàm/phương thức là gì? (Tổ chức code, tái sử dụng…)</li>
<li>Từ <code>void</code> trong <code>void MyFunction()</code> nghĩa là gì? (Hàm không trả về giá trị)</li>
<li>Trong định nghĩa hàm <code>void DoSomething(int number)</code>, <code>number</code> được gọi là gì? (Tham số/Parameter)</li>
<li>Trong lời gọi hàm <code>DoSomething(5)</code>, số <code>5</code> được gọi là gì? (Đối số/Argument)</li>
<li>Nếu muốn hàm trả về một giá trị kiểu số thực, ta dùng kiểu trả về nào? (<code>float</code>)</li>
<li>Từ khóa nào dùng để trả về giá trị từ hàm? (<code>return</code>)</li>
<li>Biến khai báo bên trong hàm gọi là gì? (Biến cục bộ/Local variable)</li>
</ul>
</li>
<li><strong>Tối ưu hóa &amp; Debugging (Cơ bản):</strong>
<ul>
<li>Kỹ thuật lưu trữ component vào biến để tránh gọi <code>GetComponent</code> nhiều lần gọi là gì? (Caching Components)</li>
<li>Công cụ nào dùng để xem hiệu năng CPU/Memory của game? (Profiler)</li>
<li>Tính năng nào giúp dừng code tại một dòng để kiểm tra? (Breakpoints)</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV: “Chúng ta đã cùng nhau đi qua một hành trình thú vị trong Học phần 1.4, từ việc quản lý âm thanh, hình ảnh, khám phá kho tài nguyên của Unity, cho đến việc viết những dòng code C# đầu tiên và xây dựng logic cho game Puzzle Quest.”</li>
<li>Đặt câu hỏi gợi nhớ: “Hãy kể tên một khái niệm hoặc kỹ năng mới mà bạn thấy ấn tượng nhất trong học phần này?” (Cho một vài HS chia sẻ nhanh).</li>
<li>GV: “Để đảm bảo chúng ta đã nắm vững những kiến thức nền tảng quan trọng này trước khi đi tiếp, hôm nay chúng ta sẽ có một buổi ôn tập và kiểm tra lại toàn bộ nội dung của Học phần 1.4.”</li>
<li>Nêu mục tiêu: Hệ thống lại kiến thức, thực hiện bài kiểm tra lý thuyết tổng kết, và giải đáp các thắc mắc cuối cùng về học phần.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo tâm thế ôn tập, nhắc lại phạm vi kiến thức của học phần, giới thiệu mục đích của buổi kiểm tra.</li>
</ul>
<p><strong>2. Explore (Khám phá - 20 phút - Ôn tập)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV dẫn dắt buổi ôn tập nhanh, hệ thống lại kiến thức theo các chủ đề chính của học phần:
<ul>
<li><strong>Quản lý Tài nguyên:</strong> Lướt nhanh qua vai trò AudioSource/Listener, Package Manager, Asset Store, Import Settings, Sprite Editor.</li>
<li><strong>Thiết kế UI:</strong> Nhắc lại Canvas, Rect Transform, Anchors, các thành phần UI cơ bản.</li>
<li><strong>Lập trình C# &amp; Hàm:</strong> Review cấu trúc script, biến (public/private, kiểu dữ liệu), <code>if/else</code>, <code>Debug.Log</code>, khái niệm hàm, hàm <code>void</code>, hàm có tham số, hàm trả về giá trị, scope.</li>
<li><strong>Tối ưu/Debug:</strong> Nhắc lại Caching, Profiler, Breakpoints.</li>
</ul>
</li>
<li>GV có thể đặt câu hỏi nhanh xen kẽ trong quá trình ôn tập để khuyến khích HS tham gia.</li>
<li>HS có thể đặt câu hỏi ngay trong quá trình ôn tập nếu có điểm nào chưa rõ.</li>
<li><em>(Nếu có tài liệu ôn tập)</em> GV có thể yêu cầu HS xem lại tài liệu tóm tắt trong thời gian này.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giúp HS hệ thống hóa lại kiến thức một cách có cấu trúc trước khi làm bài kiểm tra, giải đáp nhanh các thắc mắc phổ biến.</li>
</ul>
<p><strong>3. Explain (Giải thích - 45 phút - Làm bài kiểm tra)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV phổ biến quy chế làm bài kiểm tra (thời gian, hình thức, các quy định nếu có).</li>
<li>Phát đề kiểm tra (giấy hoặc link online).</li>
<li>HS tập trung làm bài kiểm tra trong khoảng thời gian quy định (ví dụ: 40-45 phút).</li>
<li>GV giữ không khí nghiêm túc, quan sát và giải đáp các câu hỏi về <em>cách hiểu đề</em> (nếu cần) nhưng không giải thích kiến thức.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khách quan mức độ nắm vững kiến thức lý thuyết của từng HS thông qua bài kiểm tra tổng hợp.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 15 phút - Chữa bài &amp; Giải đáp)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV thu bài kiểm tra (hoặc hệ thống online tự chấm).</li>
<li>GV chữa nhanh một số câu hỏi trọng tâm hoặc những câu HS thường sai trong bài kiểm tra.</li>
<li>Giải thích đáp án đúng và làm rõ các khái niệm liên quan đến câu hỏi đó.</li>
<li>Mở rộng phần hỏi đáp: Dành thời gian để HS đặt bất kỳ câu hỏi nào còn vướng mắc về toàn bộ nội dung Học phần 1.4 mà chưa được giải đáp hoặc chưa hiểu rõ qua bài kiểm tra. GV giải đáp chi tiết.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giúp HS hiểu rõ đáp án đúng, nhận ra lỗi sai của mình, và giải quyết triệt để các thắc mắc còn lại về kiến thức học phần.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Đánh giá qua bài kiểm tra:</strong> Kết quả bài kiểm tra là cơ sở chính để đánh giá mức độ đạt được mục tiêu kiến thức của HS. GV có thể đưa ra nhận xét chung về kết quả của lớp (không cần công bố điểm cá nhân).</li>
<li><strong>Đánh giá qua hỏi đáp:</strong> Mức độ tham gia đặt câu hỏi và khả năng trả lời các câu hỏi ôn tập của HS cũng phản ánh sự hiểu bài.</li>
<li><strong>Tự đánh giá:</strong> GV khuyến khích HS tự nhìn lại kết quả bài làm và phần giải đáp để xác định điểm mạnh, điểm yếu của bản thân trong học phần này.</li>
<li>GV đưa ra nhận xét tổng kết về quá trình học tập của lớp trong học phần, động viên HS.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá tổng thể mức độ hoàn thành mục tiêu học phần của lớp và từng cá nhân, khuyến khích tinh thần tự đánh giá và học hỏi liên tục.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tổng kết lại các nội dung chính đã được kiểm tra và ôn tập.</li>
<li>Thông báo về kế hoạch tiếp theo (ví dụ: bắt đầu học phần mới, tiếp tục phát triển dự án, thực hiện bài thực hành…).</li>
<li>Khuyến khích HS xem lại bài kiểm tra và các tài liệu để củng cố kiến thức nếu cần.</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.10-project---tạo-ra-các-phần-thưởng-ngẫu-nhiên-thêm-yếu-tố-ngẫu-nhiên">Giáo án Buổi học 1.4.10: Project - Tạo ra các Phần thưởng Ngẫu nhiên (Thêm Yếu tố Ngẫu nhiên)</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest (Memory Match)<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.7 (hoặc đã có logic game cơ bản) và buổi 1.4.9 (kiểm tra lý thuyết, củng cố kiến thức C# cơ bản).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS giải thích được mục đích của việc thêm yếu tố ngẫu nhiên vào game (tăng tính bất ngờ, khả năng chơi lại).</li>
<li>HS sử dụng được lớp <code>UnityEngine.Random</code> và các phương thức phổ biến của nó: <code>Random.Range()</code> (cho cả int và float), <code>Random.value</code>.</li>
<li>HS áp dụng được <code>Random.Range()</code> để sinh số nguyên hoặc số thực ngẫu nhiên trong một khoảng xác định.</li>
<li>HS áp dụng được <code>Random.value</code> để đưa ra quyết định dựa trên xác suất.</li>
<li>HS tích hợp được logic ngẫu nhiên vào các hàm C# hiện có trong dự án “Puzzle Quest” để tạo ra một cơ chế ngẫu nhiên đơn giản (ví dụ: điểm thưởng ngẫu nhiên, hiệu ứng hình ảnh ngẫu nhiên).</li>
<li>HS kiểm tra và đánh giá được hiệu quả của yếu tố ngẫu nhiên vừa thêm vào gameplay.</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity, VS Code/Visual Studio và có dự án “Puzzle Quest” với logic gameplay cơ bản hoạt động.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Thêm Gia vị Bất ngờ: Sử dụng Random trong Puzzle Quest” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Một vài ý tưởng cụ thể về cách áp dụng tính ngẫu nhiên vào game Memory Match (ngoài điểm thưởng).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Thêm Gia vị Bất ngờ: Sử dụng Random trong Puzzle Quest"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Game sẽ trở nên thú vị hơn nếu có những yếu tố bất ngờ. Sự ngẫu nhiên (Randomness) là một cách tuyệt vời để tạo ra sự đa dạng và tăng khả năng chơi lại. Hôm nay, chúng ta sẽ học cách sử dụng công cụ tạo số ngẫu nhiên của Unity để thêm “gia vị” bất ngờ vào game “Puzzle Quest”.</li>
<li><strong>Bước 1: Tìm hiểu <code>UnityEngine.Random</code>:</strong>
<ul>
<li>Unity cung cấp một lớp tĩnh (static class) tên là <code>Random</code> để giúp chúng ta tạo ra các giá trị ngẫu nhiên một cách dễ dàng. Vì là lớp tĩnh, bạn không cần tạo đối tượng mới mà có thể gọi trực tiếp các phương thức của nó (ví dụ: <code>Random.Range(...)</code>).</li>
<li><strong>Các Phương thức Phổ biến:</strong>
<ul>
<li><code>Random.Range(int minInclusive, int maxExclusive)</code>: Trả về một số <strong>nguyên</strong> ngẫu nhiên bắt đầu từ <code>minInclusive</code> và nhỏ hơn <code>maxExclusive</code>. Ví dụ: <code>Random.Range(1, 7)</code> sẽ trả về các số 1, 2, 3, 4, 5, hoặc 6.</li>
<li><code>Random.Range(float minInclusive, float maxInclusive)</code>: Trả về một số <strong>thực</strong> (float) ngẫu nhiên nằm giữa <code>minInclusive</code> và <code>maxInclusive</code> (bao gồm cả hai đầu). Ví dụ: <code>Random.Range(0.5f, 2.0f)</code> có thể trả về 0.5, 1.234, 2.0, …</li>
<li><code>Random.value</code>: Trả về một số <strong>thực</strong> (float) ngẫu nhiên nằm trong khoảng từ 0.0 đến 1.0 (bao gồm cả 0.0 và 1.0). Rất hữu ích để kiểm tra xác suất (ví dụ: 30% cơ hội xảy ra điều gì đó).</li>
</ul>
</li>
<li><strong>Thực hành nhanh (trong <code>GameManager.cs</code>, hàm <code>Start</code> hoặc <code>Update</code> để test):</strong><pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token comment">// ... code cũ ...</span>
     <span class="token keyword">int</span> randomDiceRoll <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tung xúc xắc 6 mặt</span>
     Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Random Dice Roll: "</span> <span class="token operator">+</span> randomDiceRoll<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token keyword">float</span> randomScaleFactor <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">1.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Random Scale Factor: "</span> <span class="token operator">+</span> randomScaleFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token keyword">float</span> randomChance <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Giá trị từ 0.0 đến 1.0</span>
     Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Random Chance Value: "</span> <span class="token operator">+</span> randomChance<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>randomChance <span class="token operator">&lt;</span> <span class="token number">0.3f</span><span class="token punctuation">)</span> <span class="token comment">// 30% cơ hội</span>
     <span class="token punctuation">{</span>
         Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Something special happened! (30% chance)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>Lưu script, chạy game và xem kết quả trong Console. Chạy lại vài lần để thấy giá trị thay đổi. Xóa code test này sau khi hiểu.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Bước 2: Brainstorm Ý tưởng Ngẫu nhiên cho Puzzle Quest:</strong>
<ul>
<li>Chúng ta có thể thêm ngẫu nhiên vào đâu để game thú vị hơn?
<ul>
<li><strong>Điểm thưởng ngẫu nhiên:</strong> Thay vì luôn cộng 10 điểm khi tìm đúng cặp, có thể cộng một số điểm ngẫu nhiên trong một khoảng (ví dụ: 5 đến 15 điểm).</li>
<li><strong>Phần thưởng đặc biệt:</strong> Có một tỷ lệ nhỏ (ví dụ: 10%) cơ hội nhận được gấp đôi điểm khi tìm đúng cặp.</li>
<li><strong>Màu nền ngẫu nhiên:</strong> Thay đổi màu nền của màn chơi mỗi khi bắt đầu game mới.</li>
<li><strong>Hiệu ứng âm thanh ngẫu nhiên:</strong> Khi tìm đúng cặp, phát một trong hai hoặc ba âm thanh thành công khác nhau một cách ngẫu nhiên.</li>
<li><strong>(Nâng cao hơn)</strong> Bố cục thẻ bài hơi khác một chút mỗi lần chơi (ví dụ: thay đổi vị trí một vài cặp).</li>
</ul>
</li>
<li>Hãy chọn 1 hoặc 2 ý tưởng đơn giản để thực hiện trong buổi hôm nay. Ví dụ: <strong>Điểm thưởng ngẫu nhiên</strong> và <strong>Cơ hội nhân đôi điểm</strong>.</li>
</ul>
</li>
<li><strong>Bước 3: Triển khai Điểm thưởng Ngẫu nhiên:</strong>
<ul>
<li>Mở script <code>GameManager.cs</code>.</li>
<li>Tìm hàm xử lý khi tìm đúng cặp (ví dụ: <code>HandleMatch()</code> hoặc nơi bạn gọi <code>UpdateScore()</code>).</li>
<li>Thay vì gọi <code>UpdateScore(10);</code> một cách cố định, hãy sửa lại:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">HandleMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hoặc nơi bạn xử lý khi khớp</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ... (Đánh dấu isMatched = true cho thẻ) ...</span>
    pairsFound<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token comment">// --- Tính điểm thưởng ngẫu nhiên ---</span>
    <span class="token keyword">int</span> pointsAwarded <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Ngẫu nhiên từ 5 đến 15 điểm</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Awarding random points: "</span> <span class="token operator">+</span> pointsAwarded<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// --- Kết thúc tính điểm thưởng ---</span>

    <span class="token function">UpdateScore</span><span class="token punctuation">(</span>pointsAwarded<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Gọi hàm cộng điểm với số điểm ngẫu nhiên</span>
    <span class="token function">CheckWinCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li>Lưu script. Chạy game và chơi thử. Quan sát Console hoặc UI điểm số để thấy số điểm cộng mỗi lần tìm đúng cặp là khác nhau.</li>
</ul>
</li>
<li><strong>Bước 4: Triển khai Cơ hội Nhân đôi Điểm:</strong>
<ul>
<li>Vẫn trong hàm <code>HandleMatch()</code> (hoặc nơi tương đương), ngay sau khi tính <code>pointsAwarded</code>, thêm đoạn kiểm tra xác suất:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">HandleMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    pairsFound<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> pointsAwarded <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Base points awarded: "</span> <span class="token operator">+</span> pointsAwarded<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// --- Kiểm tra cơ hội nhân đôi điểm (ví dụ: 20% cơ hội) ---</span>
    <span class="token keyword">float</span> doubleChance <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Số ngẫu nhiên từ 0.0 đến 1.0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>doubleChance <span class="token operator">&lt;</span> <span class="token number">0.2f</span><span class="token punctuation">)</span> <span class="token comment">// Nếu nhỏ hơn 0.2 (tức là 20%)</span>
    <span class="token punctuation">{</span>
         pointsAwarded <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// Nhân đôi số điểm</span>
         Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"DOUBLE POINTS BONUS! New points: "</span> <span class="token operator">+</span> pointsAwarded<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment">// (Tùy chọn) Có thể thêm hiệu ứng đặc biệt ở đây (âm thanh, hình ảnh)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// --- Kết thúc kiểm tra ---</span>

    <span class="token function">UpdateScore</span><span class="token punctuation">(</span>pointsAwarded<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CheckWinCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li>Lưu script. Chạy game và chơi thử nhiều lần. Quan sát xem thỉnh thoảng bạn có nhận được thông báo “DOUBLE POINTS BONUS” và số điểm cộng có được nhân đôi không.</li>
</ul>
</li>
<li><strong>Bước 5: Kiểm tra và Đánh giá:</strong>
<ul>
<li>Chơi game nhiều lần để trải nghiệm yếu tố ngẫu nhiên vừa thêm.</li>
<li>Nó có làm game thú vị hơn không?</li>
<li>Tỷ lệ ngẫu nhiên (khoảng điểm, % nhân đôi) có hợp lý không hay cần điều chỉnh?</li>
<li>Yếu tố ngẫu nhiên có dễ nhận biết không hay cần thêm phản hồi (âm thanh, hình ảnh)?</li>
</ul>
</li>
<li><strong>Kết luận:</strong> Sử dụng <code>UnityEngine.Random</code> là một cách đơn giản nhưng hiệu quả để thêm sự bất ngờ và đa dạng vào game của bạn. Chỉ với vài dòng code, bạn đã làm cho việc tính điểm trong “Puzzle Quest” trở nên khó đoán và hấp dẫn hơn!</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV: “Game Puzzle Quest của chúng ta đã hoạt động tốt, nhưng liệu có cách nào làm nó bớt ‘đều đều’ và thêm chút bất ngờ không? Ví dụ, nếu mỗi lần tìm đúng cặp, điểm số nhận được lại khác nhau một chút thì sao?”</li>
<li>Thảo luận nhanh: “Yếu tố ngẫu nhiên có vai trò gì trong các game các bạn hay chơi?” (HS kể ví dụ: vật phẩm rơi ngẫu nhiên, quái xuất hiện ngẫu nhiên, hiệu ứng khác nhau…).</li>
<li>GV: “Sự ngẫu nhiên giúp game khó đoán hơn, thử thách hơn và khiến người chơi muốn chơi lại để xem lần này có gì khác. Hôm nay, chúng ta sẽ học cách ‘gieo xúc xắc’ trong code bằng công cụ <code>Random</code> của Unity để thêm yếu tố bất ngờ vào Puzzle Quest.”</li>
<li>Nêu mục tiêu: Tìm hiểu cách dùng <code>UnityEngine.Random</code> và áp dụng nó để tạo điểm thưởng ngẫu nhiên hoặc các hiệu ứng ngẫu nhiên khác trong game.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo nhu cầu về việc làm game bớt đơn điệu, giới thiệu vai trò của yếu tố ngẫu nhiên, và nêu mục tiêu học cách sử dụng <code>Random</code>.</li>
</ul>
<p><strong>2. Explore (Khám phá - 45 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Thêm Gia vị Bất ngờ: Sử dụng Random trong Puzzle Quest”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li><strong>Tìm hiểu <code>Random</code>:</strong> Đọc và hiểu các phương thức <code>Random.Range()</code> (int/float) và <code>Random.value</code>. Chạy code test trong <code>Start()</code> để xem kết quả ngẫu nhiên trong Console.</li>
<li><strong>Brainstorm:</strong> Đọc các ý tưởng áp dụng ngẫu nhiên, chọn 1-2 ý tưởng để thực hiện (ví dụ: điểm ngẫu nhiên, % nhân đôi).</li>
<li><strong>Triển khai Điểm ngẫu nhiên:</strong> Sửa code trong hàm <code>HandleMatch</code> (hoặc tương đương) để sử dụng <code>Random.Range(min, max)</code> tính điểm thay vì số cố định.</li>
<li><strong>Triển khai % Nhân đôi:</strong> Thêm code sử dụng <code>Random.value</code> và <code>if</code> để kiểm tra xác suất và nhân đôi điểm nếu điều kiện thỏa mãn.</li>
<li><strong>Play Test:</strong> Chạy game nhiều lần, quan sát Console và điểm số để kiểm tra xem logic ngẫu nhiên có hoạt động đúng như mong đợi không (điểm thay đổi, thỉnh thoảng có nhân đôi).</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Giải thích lại cách hoạt động của <code>Random.Range</code> (đặc biệt là <code>maxExclusive</code> cho int) và <code>Random.value</code>.</li>
<li>Giúp HS xác định đúng vị trí trong code để thêm logic ngẫu nhiên (ví dụ: trong hàm xử lý khi tìm đúng cặp).</li>
<li>Hỗ trợ sửa lỗi cú pháp hoặc logic khi triển khai.</li>
<li>Khuyến khích HS thử thay đổi các giá trị min/max hoặc tỷ lệ % để xem ảnh hưởng.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp việc sử dụng các hàm của <code>UnityEngine.Random</code>, áp dụng vào logic tính điểm của game, và kiểm tra kết quả của yếu tố ngẫu nhiên.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu lại các đoạn code đã sửa đổi trong <code>GameManager.cs</code>.</li>
<li><strong><code>UnityEngine.Random</code>:</strong>
<ul>
<li>Nhấn mạnh lại đây là lớp <strong>tĩnh</strong>, cách gọi trực tiếp <code>Random. tenPhuongThuc()</code>.</li>
<li>Giải thích kỹ sự khác biệt giữa <code>Range(int, int)</code> (maxExclusive) và <code>Range(float, float)</code> (maxInclusive). Khi nào dùng cái nào.</li>
<li>Phân tích cách dùng <code>Random.value</code> để kiểm tra xác suất (ví dụ: <code>randomValue &lt; 0.2f</code> tương ứng 20% cơ hội).</li>
</ul>
</li>
<li><strong>Tích hợp vào Logic Game:</strong>
<ul>
<li>Thảo luận về vị trí đặt code ngẫu nhiên: Tại sao đặt trong <code>HandleMatch</code> mà không phải <code>Update</code>? (Vì chỉ cần tính điểm ngẫu nhiên khi sự kiện tìm đúng cặp xảy ra).</li>
<li>Cách kết hợp <code>Random</code> với các biến và hàm đã có (<code>pointsAwarded</code>, <code>UpdateScore</code>).</li>
</ul>
</li>
<li><strong>Ý nghĩa của Ngẫu nhiên trong Thiết kế Game:</strong>
<ul>
<li>Thảo luận rộng hơn về ưu điểm (bất ngờ, chơi lại) và nhược điểm (khó cân bằng, có thể gây khó chịu nếu quá ngẫu nhiên) của việc sử dụng yếu tố ngẫu nhiên.</li>
<li>Khi nào nên và không nên dùng ngẫu nhiên? (Ví dụ: không nên dùng cho các cơ chế cốt lõi yêu cầu sự chính xác, nhưng tốt cho phần thưởng, sự kiện phụ, trang trí…).</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Cung cấp giải thích sâu hơn về cách sử dụng lớp <code>Random</code>, cách tích hợp vào logic game, và mở rộng tư duy về vai trò của yếu tố ngẫu nhiên trong thiết kế game.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thử nghiệm &amp; Thảo luận):</strong>
<ul>
<li>GV yêu cầu HS: “Hãy thử thay đổi khoảng điểm thưởng ngẫu nhiên (ví dụ: 1 đến 5, hoặc 10 đến 20) và tỷ lệ nhân đôi điểm (ví dụ: 5% hoặc 50%). Chơi thử và cảm nhận xem thay đổi đó ảnh hưởng đến độ khó/hấp dẫn của game như thế nào?”</li>
<li>Thảo luận nhanh trong lớp: “Với game lật hình này, các bạn nghĩ thêm yếu tố ngẫu nhiên nào khác sẽ phù hợp?” (Ví dụ: thỉnh thoảng có thẻ bom (- điểm), thẻ cộng thời gian…).</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS tự điều chỉnh tham số ngẫu nhiên, đánh giá ảnh hưởng đến gameplay và suy nghĩ sáng tạo về các ứng dụng khác của yếu tố ngẫu nhiên.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh Code &amp; Gameplay:</strong> GV yêu cầu HS chạy game, tìm vài cặp thẻ và chỉ ra bằng chứng cho thấy điểm số đang được cộng ngẫu nhiên (qua Console log hoặc UI). Yêu cầu HS chỉ ra đoạn code sử dụng <code>Random.Range</code> và <code>Random.value</code>.</li>
<li><strong>Câu hỏi nhanh (Miệng):</strong>
<ol>
<li>Lớp nào trong Unity dùng để tạo số ngẫu nhiên? (<code>UnityEngine.Random</code>)</li>
<li>Để lấy số nguyên ngẫu nhiên từ 1 đến 10 (bao gồm cả 1 và 10), bạn dùng lệnh nào? (<code>Random.Range(1, 11)</code>)</li>
<li>Để lấy số thực ngẫu nhiên từ 0.0 đến 1.0, bạn dùng lệnh nào? (<code>Random.value</code>)</li>
<li>Làm thế nào để tạo ra 25% cơ hội xảy ra một việc gì đó? (Kiểm tra <code>if (Random.value &lt; 0.25f)</code>)</li>
<li>Việc thêm ngẫu nhiên vào game có lợi ích gì? (Tăng bất ngờ, khả năng chơi lại…)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng sử dụng các hàm <code>Random</code> cơ bản, tích hợp vào logic game và hiểu được mục đích của việc thêm yếu tố ngẫu nhiên.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV tóm tắt: “Hôm nay chúng ta đã thêm một chút ‘phép màu’ ngẫu nhiên vào game, làm cho nó trở nên khó đoán và thú vị hơn bằng cách sử dụng lớp Random.”</li>
<li>Nhấn mạnh: “Ngẫu nhiên là một công cụ mạnh mẽ trong thiết kế game, nhưng cần sử dụng một cách cân nhắc để không làm mất đi tính công bằng hoặc gây khó chịu.”</li>
<li>Giới thiệu buổi học tiếp theo: “Game của chúng ta đã gần hoàn chỉnh về mặt logic. Buổi sau, chúng ta sẽ tập trung vào việc hoàn thiện luồng chơi, thêm các màn hình cần thiết (như màn hình thắng) và đánh bóng các chi tiết cuối cùng.”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.11-project---thêm-chức-năng-và-hoàn-thiện-game">Giáo án Buổi học 1.4.11: Project - Thêm Chức năng và Hoàn Thiện Game</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest (Memory Match)<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.10 (thêm yếu tố ngẫu nhiên, logic game cơ bản đã hoàn chỉnh).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS sử dụng được <code>UnityEngine.SceneManagement.SceneManager.LoadScene()</code> để chuyển đổi giữa các Scene (từ Menu sang Gameplay và ngược lại).</li>
<li>HS liên kết được sự kiện <code>OnClick()</code> của Button trên UI với các hàm public trong script C#.</li>
<li>HS triển khai được việc hiển thị thông tin game (ví dụ: điểm số) lên thành phần UI Text/TextMeshPro một cách động.</li>
<li>HS thiết kế và triển khai được một màn hình hoặc panel đơn giản để thông báo kết thúc game (ví dụ: màn hình chiến thắng).</li>
<li>HS áp dụng được các kỹ thuật “đánh bóng” (polishing) cơ bản như thêm phản hồi âm thanh cho tương tác UI hoặc hiệu ứng hình ảnh đơn giản.</li>
<li>HS hoàn thiện được luồng chơi cơ bản của game từ đầu đến cuối (Menu -&gt; Chơi -&gt; Thắng -&gt; Chơi lại/Về Menu).</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính đã cài đặt Unity, VS Code/Visual Studio và có dự án “Puzzle Quest” với logic gameplay cơ bản hoạt động và yếu tố ngẫu nhiên đã thêm. Cần có sẵn <code>MenuScene</code> và <code>GameplayScene</code>.</li>
<li>Máy chiếu và máy tính cho GV.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Hoàn thiện Puzzle Quest: Kết nối Màn chơi và Đánh bóng Trải nghiệm” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
<li>(Tùy chọn) Các tài nguyên âm thanh/hình ảnh nhỏ bổ sung cho việc đánh bóng (ví dụ: âm thanh click nút, sprite cho panel thắng).</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Hoàn thiện Puzzle Quest: Kết nối Màn chơi và Đánh bóng Trải nghiệm"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Game của chúng ta đã có logic cốt lõi, nhưng vẫn còn rời rạc giữa các màn hình và thiếu đi sự mượt mà, phản hồi cần thiết. Hôm nay, chúng ta sẽ kết nối mọi thứ lại với nhau, thêm các chức năng hoàn thiện như hiển thị điểm số, màn hình kết thúc, và “đánh bóng” game bằng âm thanh, hiệu ứng để tạo ra một sản phẩm hoàn chỉnh hơn.</li>
<li><strong>Bước 1: Quản lý và Chuyển đổi Scene:</strong>
<ul>
<li>Để chuyển từ màn hình này sang màn hình khác (ví dụ: từ Menu vào Game), chúng ta cần sử dụng <code>SceneManager</code>.</li>
<li><strong>Quan trọng:</strong> Trước tiên, bạn cần thêm các Scene muốn chuyển đổi vào danh sách Build Settings. Vào menu <code>File</code> -&gt; <code>Build Settings...</code>. Kéo thả các file <code>MenuScene</code> và <code>GameplayScene</code> từ cửa sổ Project vào khu vực “Scenes In Build”. Đảm bảo <code>MenuScene</code> ở vị trí đầu tiên (index 0). Đóng cửa sổ Build Settings.</li>
<li><em>Hình ảnh minh họa cửa sổ Build Settings và cách thêm Scene.</em></li>
<li><strong>Viết Code Chuyển Scene:</strong>
<ul>
<li>Mở script <code>MenuController.cs</code> (nếu chưa có, hãy tạo script này và gắn vào một GameObject trong <code>MenuScene</code>, ví dụ: Canvas).</li>
<li>Thêm code sau:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>
<span class="token keyword">using</span> UnityEngine<span class="token punctuation">.</span>SceneManagement<span class="token punctuation">;</span> <span class="token comment">// Cần thêm dòng này để dùng SceneManager</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MenuController</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token comment">// Hàm này sẽ được gọi bởi nút Play</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PlayGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Loading Gameplay Scene..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        SceneManager<span class="token punctuation">.</span><span class="token function">LoadScene</span><span class="token punctuation">(</span><span class="token string">"GameplayScene"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tải Scene theo tên file</span>
        <span class="token comment">// Hoặc SceneManager.LoadScene(1); // Tải Scene theo index trong Build Settings (GameplayScene là index 1)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// (Tùy chọn) Hàm thoát game (chỉ hoạt động khi build thành file .exe)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">QuitGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
         Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Quitting Game..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         Application<span class="token punctuation">.</span><span class="token function">Quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li>Mở script <code>GameManager.cs</code> (trong <code>GameplayScene</code>). Thêm hàm để quay về Menu:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">.</span>SceneManagement<span class="token punctuation">;</span> <span class="token comment">// Đảm bảo có dòng này ở trên cùng</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameManager</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token comment">// ... (code khác) ...</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">GoToMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Loading Menu Scene..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        SceneManager<span class="token punctuation">.</span><span class="token function">LoadScene</span><span class="token punctuation">(</span><span class="token string">"MenuScene"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tải lại MenuScene (index 0)</span>
    <span class="token punctuation">}</span>

     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">RestartGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
          Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Restarting Gameplay Scene..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          SceneManager<span class="token punctuation">.</span><span class="token function">LoadScene</span><span class="token punctuation">(</span>SceneManager<span class="token punctuation">.</span><span class="token function">GetActiveScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tải lại Scene hiện tại</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Bước 2: Kết nối Nút bấm UI với Script:</strong>
<ul>
<li>Mở <code>MenuScene</code>.</li>
<li>Chọn Button “Play”. Trong <strong>Inspector</strong>, tìm component <code>Button</code>.</li>
<li>Tìm mục <code>On Click ()</code>. Đây là danh sách các hành động sẽ xảy ra khi nút được nhấn.</li>
<li>Nhấn vào nút <code>+</code> nhỏ ở góc dưới bên phải của mục <code>On Click ()</code>.</li>
<li>Một sự kiện mới sẽ được thêm vào. Kéo thả GameObject chứa script <code>MenuController</code> (ví dụ: Canvas) từ <strong>Hierarchy</strong> vào ô “None (Object)”.</li>
<li>Nhấp vào dropdown “No Function”. Tìm đến tên script của bạn (<code>MenuController</code>) -&gt; chọn hàm <code>PlayGame()</code> bạn vừa viết.</li>
<li><em>Hình ảnh minh họa các bước kết nối sự kiện OnClick của Button.</em></li>
<li><strong>Thực hành tương tự</strong> cho các nút khác (nếu có nút Quit trong Menu, hoặc nút “Chơi lại”, “Về Menu” sẽ tạo ở bước sau).</li>
</ul>
</li>
<li><strong>Bước 3: Hiển thị Điểm số Động trên UI:</strong>
<ul>
<li>Mở <code>GameplayScene</code>.</li>
<li>Đảm bảo bạn đã có một đối tượng UI Text/TextMeshPro để hiển thị điểm (ví dụ tên là <code>ScoreText</code>).</li>
<li>Mở script <code>GameManager.cs</code>.</li>
<li><strong>Thêm biến public</strong> để tham chiếu đến đối tượng Text:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">using</span> TMPro<span class="token punctuation">;</span> <span class="token comment">// Thêm dòng này nếu dùng TextMeshPro</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameManager</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> TextMeshProUGUI scoreText<span class="token punctuation">;</span> <span class="token comment">// Hoặc public Text scoreText; nếu dùng Text thường</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><strong>Gán tham chiếu trong Editor:</strong> Quay lại Unity, chọn GameObject <code>GameManager</code>. Kéo thả đối tượng <code>ScoreText</code> từ <strong>Hierarchy</strong> vào ô <code>Score Text</code> trong Inspector của GameManager.</li>
<li><strong>Cập nhật Text khi điểm thay đổi:</strong> Tìm hàm <code>UpdateScore(int pointsToAdd)</code> bạn đã viết. Sửa lại để cập nhật UI:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">UpdateScore</span><span class="token punctuation">(</span><span class="token keyword">int</span> pointsToAdd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    score <span class="token operator">+</span><span class="token operator">=</span> pointsToAdd<span class="token punctuation">;</span>
    <span class="token comment">// Cập nhật UI Text</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scoreText <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// Kiểm tra xem đã gán chưa</span>
    <span class="token punctuation">{</span>
         scoreText<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Score: "</span> <span class="token operator">+</span> score<span class="token punctuation">;</span> <span class="token comment">// Cập nhật nội dung text</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         Debug<span class="token punctuation">.</span><span class="token function">LogWarning</span><span class="token punctuation">(</span><span class="token string">"Score Text UI is not assigned in GameManager!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Score updated to: "</span> <span class="token operator">+</span> score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Giữ lại log để kiểm tra</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><strong>Cập nhật điểm ban đầu:</strong> Trong hàm <code>Start()</code> hoặc <code>SetupBoard()</code>, thêm dòng <code>scoreText.text = "Score: " + score;</code> để hiển thị điểm 0 lúc đầu.</li>
<li>Play test và kiểm tra xem điểm số trên UI có cập nhật đúng khi bạn tìm được cặp thẻ không.</li>
</ul>
</li>
<li><strong>Bước 4: Tạo Màn hình/Panel Kết thúc Game:</strong>
<ul>
<li>Trong <code>GameplayScene</code>, chọn <code>Canvas</code>.</li>
<li>Chuột phải vào <code>Canvas</code> -&gt; <code>UI</code> -&gt; <code>Panel</code>. Một Panel màu bán trong suốt sẽ được tạo. Đặt tên là <code>WinPanel</code>.</li>
<li><strong>Thiết kế Panel:</strong>
<ul>
<li>Thay đổi màu sắc, độ trong suốt của Panel trong component <code>Image</code> của nó nếu muốn.</li>
<li>Thêm các đối tượng con cho <code>WinPanel</code>:
<ul>
<li>Một <code>Text</code>/<code>TextMeshPro</code> lớn ghi “YOU WIN!” hoặc “Chúc mừng!”.</li>
<li>Một <code>Text</code>/<code>TextMeshPro</code> khác để hiển thị điểm số cuối cùng (sẽ cập nhật bằng code). Đặt tên ví dụ: <code>FinalScoreText</code>.</li>
<li>Một <code>Button</code> với chữ “Chơi lại” (Restart).</li>
<li>Một <code>Button</code> với chữ “Về Menu” (Main Menu).</li>
</ul>
</li>
</ul>
</li>
<li><strong>Ẩn Panel ban đầu:</strong> Chọn <code>WinPanel</code>. Trong <strong>Inspector</strong>, bỏ dấu tick ở ô vuông nhỏ bên cạnh tên GameObject để tắt nó đi (Set Active = false).</li>
<li><em>Hình ảnh minh họa thiết kế WinPanel và cách tắt GameObject.</em></li>
<li><strong>Hiện Panel khi Thắng:</strong> Mở <code>GameManager.cs</code>. Tìm hàm <code>CheckWinCondition()</code> hoặc nơi bạn xử lý khi thắng game.
<ul>
<li>Thêm biến public để tham chiếu đến Panel và Text điểm cuối:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">public</span> GameObject winPanel<span class="token punctuation">;</span>
<span class="token keyword">public</span> TextMeshProUGUI finalScoreText<span class="token punctuation">;</span> <span class="token comment">// Hoặc Text</span>
</code></pre>
</li>
<li>Gán <code>WinPanel</code> và <code>FinalScoreText</code> từ Hierarchy vào Inspector của GameManager.</li>
<li>Trong logic xử lý thắng, thêm code để kích hoạt Panel và cập nhật điểm cuối:<pre class=" language-csharp"><code class="prism  language-csharp"><span class="token keyword">void</span> <span class="token function">HandleWin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Giả sử có hàm riêng xử lý thắng</span>
<span class="token punctuation">{</span>
     Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Player Wins!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     isGameOver <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment">// Đặt trạng thái kết thúc</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>winPanel <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
          winPanel<span class="token punctuation">.</span><span class="token function">SetActive</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Kích hoạt Panel (làm nó hiện ra)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>finalScoreText <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
               finalScoreText<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Final Score: "</span> <span class="token operator">+</span> score<span class="token punctuation">;</span> <span class="token comment">// Hiển thị điểm cuối</span>
          <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// (Tùy chọn) Dừng bộ đếm thời gian nếu có</span>
<span class="token punctuation">}</span>

<span class="token comment">// Gọi HandleWin() từ CheckWinCondition() khi pairsFound == totalPairs</span>
<span class="token keyword">void</span> <span class="token function">CheckWinCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isGameOver <span class="token operator">&amp;&amp;</span> pairsFound <span class="token operator">==</span> totalPairs<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
          <span class="token function">HandleWin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
</ul>
</li>
<li><strong>Kết nối Nút trên Panel:</strong> Chọn các Button “Chơi lại” và “Về Menu” trên <code>WinPanel</code>. Sử dụng mục <code>On Click ()</code> trong Inspector để kết nối chúng lần lượt với các hàm <code>RestartGame()</code> và <code>GoToMenu()</code> của script <code>GameManager</code>.</li>
</ul>
</li>
<li><strong>Bước 5: Đánh bóng (Polishing) Cơ bản:</strong>
<ul>
<li><strong>Phản hồi Âm thanh:</strong>
<ul>
<li>Thêm âm thanh khi nhấn nút: Tìm hoặc tạo một file SFX tiếng click nút. Trong <code>MenuController.cs</code> và <code>GameManager.cs</code>, tạo một biến <code>public AudioClip buttonClickSound;</code> và một hàm <code>PlayButtonClickSound()</code>. Gọi hàm này ở đầu các hàm được gọi bởi nút bấm (<code>PlayGame</code>, <code>GoToMenu</code>, <code>RestartGame</code>). Gán file âm thanh vào Inspector. Đảm bảo có AudioSource để phát SFX.</li>
<li>Thêm âm thanh khi thắng: Đã có <code>SFX_GameWin.wav</code> từ buổi trước? Gọi hàm phát âm thanh này trong <code>HandleWin()</code>.</li>
</ul>
</li>
<li><strong>Phản hồi Hình ảnh:</strong>
<ul>
<li>Hiệu ứng nút bấm: Sử dụng các tùy chọn <code>Transition</code> (Color Tint, Sprite Swap) của component Button để nút thay đổi khi di chuột qua/nhấn.</li>
<li>(Nâng cao) Hiệu ứng khi tìm đúng cặp: Thêm một hiệu ứng particle nhỏ (<code>GameObject</code> -&gt; <code>Effects</code> -&gt; <code>Particle System</code>) xuất hiện tại vị trí thẻ khi tìm đúng cặp (sẽ cần code để <code>Instantiate</code> và <code>Destroy</code> hiệu ứng này).</li>
</ul>
</li>
<li><strong>Tinh chỉnh UI:</strong> Rà soát lại vị trí, kích thước, màu sắc, font chữ của các yếu tố UI cho hài hòa, dễ đọc.</li>
</ul>
</li>
<li><strong>Bước 6: Kiểm tra Luồng Chơi Hoàn chỉnh:</strong>
<ul>
<li>Chạy game từ <code>MenuScene</code>.</li>
<li>Nhấn nút “Play”. Game có chuyển sang <code>GameplayScene</code> không?</li>
<li>Chơi game, tìm tất cả các cặp thẻ. Điểm số có cập nhật trên UI không?</li>
<li>Khi thắng, <code>WinPanel</code> có hiện ra không? Điểm cuối có đúng không?</li>
<li>Nhấn nút “Chơi lại”. Game có tải lại màn chơi không?</li>
<li>Nhấn nút “Về Menu”. Game có quay lại <code>MenuScene</code> không?</li>
</ul>
</li>
<li><strong>Kết luận:</strong> Game “Puzzle Quest” của bạn giờ đây đã có luồng chơi hoàn chỉnh từ đầu đến cuối, hiển thị thông tin cần thiết và có những phản hồi cơ bản cho người chơi. Đây là một cột mốc quan trọng!</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV: “Game của chúng ta đã có thể chơi được logic chính rồi! Nhưng nó vẫn hơi ‘rời rạc’. Làm sao để từ màn hình Menu vào được màn chơi? Làm sao để biết mình được bao nhiêu điểm mà không cần nhìn Console? Khi thắng thì sao? Và làm sao để game ‘có hồn’ hơn với các phản hồi khi tương tác?”</li>
<li>Thảo luận nhanh về trải nghiệm người dùng: Tại sao cần chuyển cảnh mượt mà, hiển thị thông tin rõ ràng, có âm thanh/hiệu ứng phản hồi?</li>
<li>Nêu mục tiêu: “Hôm nay, chúng ta sẽ hoàn thiện ‘Puzzle Quest’ bằng cách kết nối các màn chơi lại với nhau, hiển thị điểm số lên giao diện, tạo màn hình chiến thắng, và thêm một vài hiệu ứng ‘đánh bóng’ cuối cùng.”</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Chỉ ra những thiếu sót hiện tại của game về luồng chơi và trải nghiệm, tạo nhu cầu hoàn thiện sản phẩm, giới thiệu các nhiệm vụ chính của buổi học.</li>
</ul>
<p><strong>2. Explore (Khám phá - 50 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Hoàn thiện Puzzle Quest: Kết nối Màn chơi và Đánh bóng Trải nghiệm”</strong>.</li>
<li>HS thực hiện theo các bước trong tài liệu:
<ul>
<li><strong>Chuyển Scene:</strong> Thêm Scene vào Build Settings. Viết code <code>SceneManager.LoadScene()</code> trong <code>MenuController</code> và <code>GameManager</code>.</li>
<li><strong>Kết nối Button:</strong> Kết nối sự kiện <code>OnClick()</code> của nút “Play” với hàm <code>PlayGame()</code>.</li>
<li><strong>Hiển thị Điểm:</strong> Thêm biến tham chiếu Text/TMP, gán trong Editor, cập nhật <code>.text</code> trong <code>UpdateScore()</code> và <code>Start()</code>.</li>
<li><strong>Tạo WinPanel:</strong> Tạo Panel, thêm Text, Button. Ẩn Panel ban đầu. Viết code trong <code>GameManager</code> để <code>SetActive(true)</code> Panel và cập nhật điểm cuối khi thắng. Kết nối các nút “Chơi lại”, “Về Menu” trên Panel với hàm tương ứng trong <code>GameManager</code>.</li>
<li><strong>Đánh bóng:</strong> Thêm code gọi hàm phát âm thanh click nút, âm thanh thắng game. Thử nghiệm với <code>Transition</code> của Button.</li>
<li><strong>Kiểm tra Luồng:</strong> Chạy game từ Menu, chơi đến khi thắng, thử các nút Chơi lại/Về Menu.</li>
</ul>
</li>
<li>GV hỗ trợ:
<ul>
<li>Hướng dẫn thêm Scene vào Build Settings.</li>
<li>Giúp HS kết nối đúng sự kiện <code>OnClick()</code> của Button.</li>
<li>Hỗ trợ gán tham chiếu UI vào script và cập nhật <code>.text</code>.</li>
<li>Giúp thiết kế WinPanel và xử lý việc <code>SetActive</code>.</li>
<li>Gợi ý cách thêm âm thanh/hiệu ứng đơn giản.</li>
<li>Quan sát và giúp HS debug nếu luồng chơi không hoạt động đúng.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS thực hành trực tiếp các kỹ năng hoàn thiện game: quản lý scene, kết nối UI-script, cập nhật UI động, quản lý trạng thái UI (ẩn/hiện), và thêm các yếu tố đánh bóng cơ bản.</li>
</ul>
<p><strong>3. Explain (Giải thích - 25 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tập hợp lớp, chiếu code và giao diện liên quan.</li>
<li><strong>Scene Management:</strong>
<ul>
<li>Giải thích vai trò của Build Settings. Sự khác biệt giữa <code>LoadScene(string sceneName)</code> và <code>LoadScene(int sceneIndex)</code>.</li>
<li>Nhấn mạnh việc cần <code>using UnityEngine.SceneManagement;</code>.</li>
</ul>
</li>
<li><strong>UI Event Handling (<code>OnClick()</code>):</strong> Giải thích cơ chế hoạt động của hệ thống sự kiện UI: Button phát ra sự kiện, bạn đăng ký một hoặc nhiều “hàm lắng nghe” (listener functions) để thực thi khi sự kiện xảy ra. Hàm được gọi phải là <code>public</code>.</li>
<li><strong>Cập nhật UI Động:</strong> Giải thích cách lấy tham chiếu đến component UI (Text/TMP) và cập nhật thuộc tính <code>.text</code> của nó từ script để hiển thị dữ liệu thay đổi. Tầm quan trọng của việc kiểm tra <code>!= null</code> trước khi truy cập.</li>
<li><strong>Quản lý Trạng thái GameObject (<code>SetActive()</code>):</strong> Giải thích cách dùng <code>gameObject.SetActive(true/false)</code> để ẩn/hiện GameObject và tất cả các con của nó. Đây là cách phổ biến để quản lý các panel, cửa sổ trong game.</li>
<li><strong>Khái niệm “Đánh bóng” (Polish):</strong> Thảo luận về tầm quan trọng của các chi tiết nhỏ (âm thanh phản hồi, hiệu ứng chuyển tiếp, hoạt ảnh…) trong việc nâng cao cảm nhận của người chơi về chất lượng game.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Cung cấp giải thích chi tiết về cơ chế quản lý scene, xử lý sự kiện UI, cập nhật UI động, quản lý trạng thái GameObject, và tầm quan trọng của việc đánh bóng sản phẩm.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động (Thảo luận &amp; Thử nghiệm nhanh):</strong>
<ul>
<li>GV: “Nếu chúng ta muốn thêm màn hình ‘Game Over’ khi hết giờ thì sao?” (Tương tự WinPanel, tạo GameOverPanel, kích hoạt khi timer &lt;= 0).</li>
<li>“Làm sao để thêm hiệu ứng mờ dần (fade in) khi WinPanel hiện ra?” (Gợi ý về việc dùng Animation hoặc Coroutine để thay đổi Alpha của Panel theo thời gian - phần nâng cao).</li>
<li>Yêu cầu HS thử thay đổi âm thanh click nút.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Khuyến khích HS suy nghĩ về việc mở rộng các chức năng tương tự và tìm hiểu các kỹ thuật đánh bóng nâng cao hơn.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Kiểm tra nhanh Luồng Chơi:</strong> GV yêu cầu HS chạy game từ Menu, chơi thắng và thử các nút trên WinPanel. Quan sát xem luồng chơi có thông suốt không, điểm số có cập nhật không.</li>
<li><strong>Câu hỏi nhanh (Miệng):</strong>
<ol>
<li>Để chuyển sang màn chơi khác, ta dùng lệnh nào? (<code>SceneManager.LoadScene()</code>)</li>
<li>Cần làm gì trước khi có thể load một Scene bằng code? (Thêm Scene vào Build Settings)</li>
<li>Làm thế nào để một nút bấm trên UI gọi một hàm trong script? (Dùng sự kiện <code>OnClick()</code> trong Inspector)</li>
<li>Làm thế nào để thay đổi chữ hiển thị trên một đối tượng Text từ script? (Lấy tham chiếu component Text/TMP và gán giá trị cho thuộc tính <code>.text</code>)</li>
<li>Làm thế nào để ẩn/hiện một Panel hoặc GameObject? (Dùng <code>gameObject.SetActive(false/true)</code>)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá khả năng hoàn thiện luồng chơi, kết nối UI và script, cập nhật UI động, và quản lý trạng thái GameObject của HS.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV chúc mừng HS: “Vậy là chúng ta đã cùng nhau hoàn thiện một vòng đời sản phẩm game mini ‘Puzzle Quest’, từ ý tưởng, quản lý tài nguyên, lập trình logic cốt lõi đến việc hoàn thiện luồng chơi và đánh bóng!”</li>
<li>Tóm tắt các kỹ năng chính đã học trong buổi: Scene Management, UI Event, Dynamic UI Update, SetActive, Polishing.</li>
<li>Giới thiệu buổi học tiếp theo: “Buổi cuối cùng của học phần, chúng ta sẽ dành thời gian để ‘showcase’ sản phẩm của mình, nhìn lại toàn bộ quá trình và tổng kết những gì đã học được.”</li>
</ul>
<hr>
<h3 id="giáo-án-buổi-học-1.4.12-tổng-kết-dự-án-và-showcase">Giáo án Buổi học 1.4.12: Tổng kết Dự án và Showcase</h3>
<p><strong>Học phần:</strong> 1.4 - Quản lý Tài nguyên &amp; Lập trình Gameplay với Hàm/Phương thức C#<br>
<strong>Dự án:</strong> Puzzle Quest (Memory Match) - Phiên bản hoàn thiện của HS<br>
<strong>Thời lượng:</strong> 100 phút<br>
<strong>Đối tượng:</strong> Học sinh 15+, đã hoàn thành buổi 1.4.11 (hoàn thiện game cơ bản).<br>
<strong>Mục tiêu buổi học:</strong></p>
<ol>
<li>HS có cơ hội rà soát và hoàn thiện những chi tiết nhỏ cuối cùng trong dự án “Puzzle Quest” của mình.</li>
<li>HS tự tin trình bày (showcase) sản phẩm game của mình trước lớp, giới thiệu các tính năng chính và chia sẻ về quá trình phát triển.</li>
<li>HS phản ánh (reflect) về những kiến thức và kỹ năng đã học được trong suốt Học phần 1.4 (quản lý tài nguyên, C# cơ bản, hàm/phương thức, UI, debugging…).</li>
<li>HS nhận được phản hồi mang tính xây dựng từ giáo viên và các bạn về sản phẩm của mình.</li>
<li>HS thảo luận về các hướng phát triển tiếp theo có thể thực hiện cho dự án hoặc cho kỹ năng làm game của bản thân.</li>
<li>HS biết cách lưu trữ và đóng gói (build) dự án Unity cơ bản (tùy chọn).</li>
</ol>
<p><strong>Chuẩn bị:</strong></p>
<ul>
<li>Máy tính của HS với dự án “Puzzle Quest” phiên bản hoàn thiện nhất.</li>
<li>Máy chiếu và máy tính cho GV để trình chiếu sản phẩm của HS.</li>
<li>(Tùy chọn) Bảng trắng hoặc công cụ ghi chú để tổng kết kiến thức và hướng phát triển.</li>
<li>(Tùy chọn) Một vài phần quà nhỏ hoặc lời khen ngợi đặc biệt để khuyến khích HS.</li>
<li><strong>Tài liệu đọc/hướng dẫn:</strong> “Hướng dẫn Showcase và Đóng gói Dự án Puzzle Quest” (file PDF hoặc trang web nội bộ) - Chi tiết nội dung bên dưới.</li>
</ul>
<p><strong>Tài liệu đọc/hướng dẫn: "Hướng dẫn Showcase và Đóng gói Dự án Puzzle Quest"</strong><br>
<em>(Nội dung cốt lõi cần có trong tài liệu này)</em></p>
<ol>
<li><strong>Giới thiệu:</strong> Chúc mừng bạn đã hoàn thành hành trình xây dựng game “Puzzle Quest” trong Học phần 1.4! Hôm nay là cơ hội để bạn tự hào giới thiệu thành quả của mình, chia sẻ kinh nghiệm và nhìn lại những gì đã học được. Chúng ta cũng sẽ tìm hiểu sơ qua cách “đóng gói” game để có thể chia sẻ với người khác.</li>
<li><strong>Bước 1: Rà soát và Hoàn thiện Lần cuối (Checklist):</strong>
<ul>
<li>Hãy dành ít phút để kiểm tra lại game của bạn lần cuối:
<ul>
<li><strong>Luồng chơi:</strong> Game có chạy mượt từ Menu -&gt; Gameplay -&gt; Màn hình kết thúc -&gt; Chơi lại/Về Menu không?</li>
<li><strong>Logic chính:</strong> Việc lật thẻ, kiểm tra trùng khớp, cộng điểm, kiểm tra thắng có hoạt động đúng không?</li>
<li><strong>Yếu tố ngẫu nhiên:</strong> Điểm thưởng ngẫu nhiên hay các yếu tố khác có hoạt động như mong đợi?</li>
<li><strong>UI:</strong> Giao diện có rõ ràng, dễ nhìn? Điểm số có cập nhật? Các nút bấm có hoạt động? Panel thắng/thua có hiện đúng lúc?</li>
<li><strong>Âm thanh:</strong> Nhạc nền, SFX (lật thẻ, đúng, sai, thắng, click nút) có phát đúng lúc không?</li>
<li><strong>Lỗi:</strong> Có lỗi nào rõ ràng hoặc thông báo đỏ nào trong Console không?</li>
</ul>
</li>
<li>Sửa nhanh những lỗi nhỏ hoặc tinh chỉnh cuối cùng nếu cần.</li>
</ul>
</li>
<li><strong>Bước 2: Chuẩn bị cho Showcase (Trình bày sản phẩm):</strong>
<ul>
<li>Mỗi bạn sẽ có khoảng 3-5 phút để giới thiệu game của mình. Hãy chuẩn bị trước những điểm chính bạn muốn nói:
<ul>
<li><strong>Giới thiệu nhanh về game:</strong> Tên game (nếu bạn có đặt tên riêng), thể loại, cách chơi cơ bản.</li>
<li><strong>Chơi thử (Live Demo):</strong> Chơi một đoạn ngắn để mọi người thấy được gameplay chính.</li>
<li><strong>Tính năng nổi bật:</strong> Bạn tự hào nhất về phần nào? Có thể là logic kiểm tra khớp, yếu tố ngẫu nhiên bạn thêm vào, phần UI bạn thiết kế, hoặc cách bạn tổ chức code bằng hàm. Hãy chỉ ra nó!</li>
<li><strong>Thách thức đã vượt qua:</strong> Bạn gặp khó khăn gì trong quá trình làm (ví dụ: lỗi khó sửa, khái niệm khó hiểu)? Bạn đã giải quyết nó như thế nào?</li>
<li><strong>(Tùy chọn) Kế hoạch tương lai:</strong> Nếu có thêm thời gian, bạn muốn phát triển thêm gì cho game này?</li>
</ul>
</li>
<li>Hãy tự tin và chia sẻ một cách rõ ràng!</li>
</ul>
</li>
<li><strong>Bước 3: (Tùy chọn) Tìm hiểu về Build Game:</strong>
<ul>
<li>Build game là quá trình đóng gói dự án Unity thành một ứng dụng độc lập (ví dụ: file <code>.exe</code> trên Windows, <code>.app</code> trên macOS) để người khác có thể chơi mà không cần cài Unity.</li>
<li><strong>Cách Build cơ bản:</strong>
<ul>
<li>Đảm bảo bạn đã thêm các Scene cần thiết vào Build Settings (<code>File</code> -&gt; <code>Build Settings...</code>).</li>
<li>Trong cửa sổ Build Settings:
<ul>
<li>Chọn <strong>Platform</strong> bạn muốn build cho (ví dụ: “PC, Mac &amp; Linux Standalone”). Nếu chưa cài đặt module cho platform đó, Unity sẽ yêu cầu cài (có thể mất thời gian).</li>
<li>Nhấn nút <strong>“Switch Platform”</strong> nếu cần chuyển sang platform khác.</li>
<li>(Tùy chọn) Nhấn “Player Settings…” để tùy chỉnh thêm (icon game, tên công ty, độ phân giải mặc định…).</li>
<li>Nhấn nút <strong>“Build”</strong>.</li>
<li>Chọn một thư mục trống trên máy tính để chứa file build. Đặt tên cho file thực thi (ví dụ: <code>PuzzleQuestGame</code>). Nhấn “Save”.</li>
</ul>
</li>
<li>Unity sẽ bắt đầu quá trình build. Chờ cho đến khi hoàn tất.</li>
<li>Sau khi build xong, vào thư mục bạn đã chọn, bạn sẽ thấy file thực thi và một thư mục Data đi kèm. Chạy file thực thi để chơi game độc lập.</li>
</ul>
</li>
<li><em>Hình ảnh minh họa các bước trong Build Settings.</em></li>
<li><strong>Lưu ý:</strong> Quá trình build có thể mất vài phút tùy thuộc vào độ phức tạp của dự án và cấu hình máy. Build cho các nền tảng khác (Mobile, WebGL) có thể cần cài đặt SDK và cấu hình phức tạp hơn. Hôm nay chúng ta chỉ tìm hiểu quy trình cơ bản cho PC.</li>
</ul>
</li>
<li><strong>Kết luận:</strong> Showcase là cơ hội tuyệt vời để chia sẻ thành quả và học hỏi lẫn nhau. Biết cách build game cơ bản cũng giúp bạn dễ dàng chia sẻ sản phẩm của mình hơn. Hãy tự hào về những gì bạn đã làm được trong học phần này!</li>
</ol>
<hr>
<p><strong>Tiến trình bài học (Mô hình 5E)</strong></p>
<p><strong>1. Engage (Gắn kết - 5 phút)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV: “Vậy là chúng ta đã đi đến buổi học cuối cùng của Học phần 1.4! Các bạn đã làm việc rất chăm chỉ để tạo ra game Puzzle Quest của riêng mình. Hôm nay chính là ngày hội để chúng ta cùng chiêm ngưỡng thành quả của nhau!”</li>
<li>Tạo không khí hào hứng: “Hãy chuẩn bị sẵn sàng để giới thiệu ‘đứa con tinh thần’ của mình và xem các bạn khác đã sáng tạo những gì!”</li>
<li>Nêu mục tiêu: Hoàn thiện nhỏ cuối cùng, trình bày (showcase) sản phẩm, phản ánh quá trình học, và tổng kết học phần.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo không khí vui vẻ, tự hào về thành quả, giới thiệu hoạt động showcase và mục tiêu tổng kết.</li>
</ul>
<p><strong>2. Explore (Khám phá - 25 phút - Hoàn thiện &amp; Chuẩn bị Showcase)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV giới thiệu <strong>Tài liệu đọc/hướng dẫn: “Hướng dẫn Showcase và Đóng gói Dự án Puzzle Quest”</strong>, tập trung vào Checklist hoàn thiện và các gợi ý chuẩn bị showcase.</li>
<li>HS dành thời gian tự rà soát lại dự án của mình theo checklist: kiểm tra lỗi, luồng chơi, UI, âm thanh… Sửa các lỗi nhỏ cuối cùng.</li>
<li>HS chuẩn bị phần trình bày của mình (khoảng 3-5 phút/người): nghĩ xem sẽ nói gì, demo phần nào, điểm nhấn là gì. Có thể ghi chú nhanh ra giấy.</li>
<li>GV đi vòng quanh hỗ trợ HS kiểm tra lỗi hoặc gợi ý về phần trình bày.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> HS có thời gian cuối để đảm bảo sản phẩm ổn định và chuẩn bị tâm lý, nội dung cho phần trình bày của mình.</li>
</ul>
<p><strong>3. Explain (Giải thích - 50 phút - Showcase &amp; Phản hồi)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>GV tổ chức buổi showcase. Mỗi HS lần lượt lên trình bày dự án của mình (kết nối máy tính với máy chiếu nếu cần).</li>
<li><strong>Trong mỗi phần trình bày của HS:</strong>
<ul>
<li>HS giới thiệu và demo game (3-5 phút).</li>
<li>Sau khi demo, GV và các HS khác đưa ra phản hồi ngắn gọn, mang tính xây dựng:
<ul>
<li>Điểm ấn tượng/thích nhất?</li>
<li>Có góp ý gì để game tốt hơn không? (Về gameplay, UI, âm thanh…)</li>
<li>Có câu hỏi nào cho bạn trình bày không?</li>
</ul>
</li>
</ul>
</li>
<li>GV điều phối thời gian, khuyến khích các HS khác tham gia đặt câu hỏi và nhận xét lịch sự. GV cũng đưa ra nhận xét của mình, tập trung vào sự tiến bộ và những điểm làm tốt của từng HS.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Tạo không gian để HS chia sẻ sản phẩm, thực hành kỹ năng trình bày, nhận và đưa phản hồi, học hỏi từ sản phẩm của các bạn khác.</li>
</ul>
<p><strong>4. Elaborate (Mở rộng/Áp dụng - 5 phút - Hướng dẫn Build (Tùy chọn))</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li>Nếu thời gian cho phép và HS quan tâm, GV giới thiệu nhanh các bước cơ bản để Build game cho PC như trong tài liệu hướng dẫn (mở Build Settings, thêm scene, chọn platform, nhấn Build).</li>
<li>GV giải thích mục đích của việc build game.</li>
<li><em>Lưu ý:</em> Không nhất thiết phải thực hiện build ngay tại lớp nếu không đủ thời gian, chỉ cần giới thiệu quy trình.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Giới thiệu khái niệm và quy trình cơ bản để đóng gói game thành sản phẩm độc lập.</li>
</ul>
<p><strong>5. Evaluate (Đánh giá - 10 phút - Tổng kết &amp; Phản ánh)</strong></p>
<ul>
<li><strong>Hoạt động:</strong>
<ul>
<li><strong>Đánh giá qua Showcase:</strong> Mức độ hoàn thiện của sản phẩm, khả năng trình bày, sự tự tin và hiểu biết về dự án của HS là cơ sở để đánh giá tổng kết.</li>
<li><strong>Tổng kết kiến thức:</strong> GV cùng HS nhìn lại và liệt kê nhanh các kiến thức, kỹ năng chính đã học trong Học phần 1.4 (Quản lý tài nguyên: Audio, Asset, Package, Sprite; UI: Canvas, Rect Transform, Image, Text, Button, Anchors; C#: Script, MonoBehaviour, Biến, If/Else, Debug.Log, Hàm void/tham số/trả về, Scope; Tối ưu/Debug: Caching, Profiler, Breakpoints; Random; Scene Management; UI Events…).</li>
<li><strong>Phản ánh:</strong> GV đặt câu hỏi để HS tự phản ánh:
<ul>
<li>Bạn hài lòng nhất về điều gì mình làm được trong học phần này?</li>
<li>Bạn gặp khó khăn lớn nhất ở đâu?</li>
<li>Kỹ năng nào bạn muốn tìm hiểu sâu hơn sau học phần này?</li>
</ul>
</li>
<li><strong>Thảo luận hướng phát triển:</strong> Có ý tưởng nào để phát triển tiếp game Puzzle Quest không? Hoặc muốn thử làm thể loại game nào khác với kiến thức đã học?</li>
<li>GV đưa ra lời nhận xét cuối cùng, khen ngợi sự nỗ lực và tiến bộ của cả lớp.</li>
</ul>
</li>
<li><strong>Mục tiêu:</strong> Đánh giá tổng thể quá trình học tập và kết quả dự án, hệ thống hóa kiến thức, khuyến khích HS tự phản ánh và suy nghĩ về các bước học tập tiếp theo.</li>
</ul>
<p><strong>Kết thúc buổi học:</strong></p>
<ul>
<li>GV chúc mừng HS đã hoàn thành Học phần 1.4 và dự án “Puzzle Quest”.</li>
<li>Khuyến khích HS tiếp tục khám phá Unity và lập trình game.</li>
<li>Thông báo về kế hoạch cho học phần tiếp theo hoặc các hoạt động khác (nếu có).</li>
<li>Nhắc nhở HS lưu trữ cẩn thận project của mình.</li>
</ul>
<hr>
<p>Tuyệt vời! Dưới đây là phụ lục hướng dẫn cài đặt các công cụ cần thiết để học sinh có thể bắt đầu lập trình C# với Unity, sử dụng Visual Studio Code (VS Code) làm IDE chính.</p>
<hr>
<h2 id="phụ-lục">Phụ lục</h2>
<h3 id="hướng-dẫn-cài-đặt-công-cụ-lập-trình-c-với-unity--visual-studio-code">Hướng dẫn Cài đặt Công cụ Lập trình C# với Unity &amp; Visual Studio Code</h3>
<p>Chào mừng các bạn đến với thế giới lập trình game bằng Unity và ngôn ngữ C#! Để có thể viết và chỉnh sửa code một cách hiệu quả, chúng ta cần cài đặt một số công cụ cần thiết. Hướng dẫn này sẽ giúp bạn cài đặt Unity Hub, Unity Editor và cấu hình Visual Studio Code (VS Code) để làm việc mượt mà với Unity.</p>
<p><strong>Các bước chính:</strong></p>
<ol>
<li><strong>Cài đặt Unity Hub:</strong> Công cụ quản lý các phiên bản Unity Editor và dự án của bạn.</li>
<li><strong>Cài đặt Unity Editor:</strong> Phiên bản cụ thể của Unity mà chúng ta sẽ sử dụng để làm game.</li>
<li><strong>Cài đặt Visual Studio Code (VS Code):</strong> Trình soạn thảo code nhẹ nhàng, mạnh mẽ và miễn phí.</li>
<li><strong>Cài đặt .NET SDK:</strong> Cần thiết để VS Code có thể hiểu và làm việc với C#.</li>
<li><strong>Cài đặt các Extension cần thiết cho VS Code:</strong> Các tiện ích mở rộng giúp VS Code hiểu và hỗ trợ tốt hơn cho việc lập trình Unity C#.</li>
<li><strong>Cấu hình Unity để sử dụng VS Code:</strong> Đảm bảo Unity biết và mở đúng VS Code khi bạn muốn sửa script.</li>
</ol>
<p><strong>Chi tiết từng bước:</strong></p>
<p><strong>Bước 1: Cài đặt Unity Hub</strong></p>
<ol>
<li>Truy cập trang web chính thức của Unity: <a href="https://unity.com/download">https://unity.com/download</a></li>
<li>Nhấn nút “Download Unity Hub”.</li>
<li>Chạy file cài đặt vừa tải về và làm theo các hướng dẫn trên màn hình để hoàn tất cài đặt Unity Hub.</li>
<li>Mở Unity Hub lên. Bạn sẽ được yêu cầu đăng nhập hoặc tạo một tài khoản Unity ID mới (miễn phí). Hãy đăng nhập hoặc tạo tài khoản nhé, vì nó cần thiết để quản lý license và truy cập Asset Store.</li>
</ol>
<ul>
<li><em>Hình ảnh minh họa: Giao diện Unity Hub sau khi cài đặt và đăng nhập.</em></li>
</ul>
<p><strong>Bước 2: Cài đặt Unity Editor</strong></p>
<ol>
<li>Trong Unity Hub, chuyển đến mục “Installs” ở thanh bên trái.</li>
<li>Nhấn nút “Install Editor”.</li>
<li>Unity Hub sẽ đề xuất một phiên bản LTS (Long-Term Support) mới nhất. Đây thường là lựa chọn ổn định và tốt nhất cho việc học. Hãy chọn phiên bản LTS được đề xuất (ví dụ: 2022.3.x LTS, 2021.3.x LTS…).
<ul>
<li><em>Quan trọng:</em> Nếu giáo viên yêu cầu sử dụng một phiên bản cụ thể, hãy chọn đúng phiên bản đó từ danh sách hoặc tab “Archive”.</li>
</ul>
</li>
<li>Nhấn “Install”.</li>
<li>Trong cửa sổ “Add modules to your install”, đảm bảo các mục sau được chọn:
<ul>
<li><strong>Microsoft Visual Studio Community [Version]</strong> (Nếu bạn <em>chưa</em> cài Visual Studio trước đó - <em>Lưu ý: Chúng ta sẽ dùng VS Code, nhưng module này thường đi kèm các thành phần cần thiết khác. Nếu có tùy chọn bỏ qua Visual Studio mà vẫn đảm bảo đủ thành phần cho VS Code thì có thể bỏ qua. Tuy nhiên, cách an toàn là cứ chọn</em>).</li>
<li><strong>Documentation</strong> (Luôn hữu ích để tra cứu).</li>
<li><strong>(Tùy chọn)</strong> Các module cho nền tảng khác nếu bạn muốn build game cho chúng sau này (Android Build Support, iOS Build Support, WebGL Build Support…). Tạm thời có thể bỏ qua nếu chỉ học làm game cho PC.</li>
</ul>
</li>
<li>Nhấn “Continue” hoặc “Install”. Quá trình tải và cài đặt Unity Editor cùng các module có thể mất khá nhiều thời gian tùy thuộc vào tốc độ mạng và cấu hình máy.</li>
</ol>
<ul>
<li><em>Hình ảnh minh họa: Cửa sổ chọn phiên bản Editor và cửa sổ chọn Modules trong Unity Hub.</em></li>
</ul>
<p><strong>Bước 3: Cài đặt Visual Studio Code (VS Code)</strong></p>
<ol>
<li>Truy cập trang web chính thức của VS Code: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></li>
<li>Trang web thường sẽ tự động phát hiện hệ điều hành của bạn và đề xuất phiên bản phù hợp. Nhấn nút “Download for [Your OS]”.</li>
<li>Chạy file cài đặt vừa tải về.</li>
<li>Trong quá trình cài đặt, hãy <strong>đặc biệt lưu ý</strong> và <strong>đánh dấu tick</strong> vào các tùy chọn sau (nếu có):
<ul>
<li><strong>Add “Open with Code” action to Windows Explorer file context menu.</strong> (Rất tiện lợi)</li>
<li><strong>Add “Open with Code” action to Windows Explorer directory context menu.</strong> (Rất tiện lợi)</li>
<li><strong>Register Code as an editor for supported file types.</strong></li>
<li><strong>Add to PATH (requires shell restart).</strong> (Cực kỳ quan trọng!)</li>
</ul>
</li>
<li>Hoàn tất các bước cài đặt còn lại.</li>
</ol>
<ul>
<li><em>Hình ảnh minh họa: Các tùy chọn quan trọng cần chọn trong quá trình cài đặt VS Code.</em></li>
</ul>
<p><strong>Bước 4: Cài đặt .NET SDK</strong></p>
<p>VS Code cần .NET SDK (Software Development Kit) để có thể biên dịch, gỡ lỗi và cung cấp các tính năng thông minh (IntelliSense) cho code C#. Unity Editor thường đi kèm với một phiên bản .NET Runtime, nhưng để VS Code hoạt động tốt nhất với C#, việc cài đặt .NET SDK riêng là rất nên làm.</p>
<ol>
<li>Truy cập trang tải .NET của Microsoft: <a href="https://dotnet.microsoft.com/en-us/download">https://dotnet.microsoft.com/en-us/download</a></li>
<li>Tìm đến phiên bản <strong>.NET SDK</strong> mới nhất được đề xuất (Thường là phiên bản LTS hoặc phiên bản Standard Term Support mới nhất). Tránh tải bản “Runtime” vì nó không đủ cho việc phát triển.</li>
<li>Tải bộ cài đặt phù hợp với hệ điều hành của bạn (Windows x64, macOS Arm64/x64, Linux…).</li>
<li>Chạy file cài đặt và làm theo hướng dẫn để hoàn tất. Quá trình này thường khá nhanh.</li>
<li><strong>Kiểm tra cài đặt (Tùy chọn):</strong> Mở Command Prompt (Windows) hoặc Terminal (macOS/Linux) và gõ lệnh <code>dotnet --version</code>. Nếu hiển thị phiên bản bạn vừa cài là thành công.</li>
</ol>
<ul>
<li><em>Hình ảnh minh họa: Trang tải .NET SDK và cách kiểm tra phiên bản bằng lệnh.</em></li>
</ul>
<p><strong>Bước 5: Cài đặt các Extension cần thiết cho VS Code</strong></p>
<p>Extensions (Tiện ích mở rộng) giúp VS Code hiểu rõ hơn về Unity và C#, cung cấp các tính năng như gợi ý code, tô màu cú pháp, gỡ lỗi…</p>
<ol>
<li>Mở Visual Studio Code.</li>
<li>Nhấp vào biểu tượng Extensions ở thanh công cụ bên trái (trông giống như các ô vuông xếp chồng lên nhau) hoặc nhấn <code>Ctrl+Shift+X</code>.</li>
<li>Trong ô tìm kiếm, gõ và cài đặt các extension sau (nhấn nút “Install”):
<ul>
<li><strong>C#</strong> (Tên đầy đủ thường là “C# for Visual Studio Code (powered by OmniSharp)” hoặc tương tự, phát triển bởi Microsoft). Đây là extension quan trọng nhất.</li>
<li><strong>Debugger for Unity</strong> (Phát triển bởi Unity Technologies). Cần thiết cho việc Attach và Debug code Unity.</li>
<li><strong>Unity Code Snippets</strong> (Phát triển bởi Kleber Silva hoặc cộng đồng). Cung cấp các đoạn code mẫu nhanh cho các hàm Unity phổ biến. (Tùy chọn nhưng hữu ích)</li>
<li><strong>Unity Tools</strong> (Phát triển bởi Tobiah). Cung cấp thêm các tiện ích khác cho Unity. (Tùy chọn)</li>
</ul>
</li>
<li>Sau khi cài đặt, VS Code có thể yêu cầu khởi động lại. Hãy khởi động lại nếu được yêu cầu.</li>
</ol>
<ul>
<li><em>Hình ảnh minh họa: Giao diện Extensions trong VS Code và các extension cần cài đặt.</em></li>
</ul>
<p><strong>Bước 6: Cấu hình Unity để sử dụng VS Code</strong></p>
<p>Bây giờ, bạn cần cho Unity biết rằng bạn muốn sử dụng VS Code làm trình soạn thảo script mặc định.</p>
<ol>
<li>Mở Unity Hub và mở một dự án Unity bất kỳ (hoặc tạo một dự án mới nếu chưa có).</li>
<li>Trong Unity Editor, vào menu <code>Edit</code> (trên Windows) hoặc <code>Unity</code> (trên macOS) -&gt; <code>Preferences</code>.</li>
<li>Trong cửa sổ Preferences, chọn mục <code>External Tools</code> ở danh sách bên trái.</li>
<li>Tìm đến dòng <code>External Script Editor</code>. Nhấp vào menu thả xuống.</li>
<li>Nếu bạn thấy “Visual Studio Code” trong danh sách, hãy chọn nó.</li>
<li>Nếu <strong>không</strong> thấy, hãy chọn “Browse…” và điều hướng đến vị trí bạn đã cài đặt VS Code (thường là trong <code>C:\Users\[YourUsername]\AppData\Local\Programs\Microsoft VS Code\Code.exe</code> trên Windows hoặc trong thư mục Applications trên macOS), chọn file thực thi <code>Code.exe</code> (hoặc <code>Visual Studio Code.app</code>).</li>
<li><strong>Quan trọng:</strong> Đảm bảo các ô check dưới <code>External Script Editor Args</code> hoặc các tùy chọn liên quan đến “Generate .csproj files for:” được chọn bao gồm “Registry packages” và “Built-in packages” (hoặc chọn “Everything”). Điều này giúp VS Code hiểu cấu trúc dự án Unity.</li>
<li>Đóng cửa sổ Preferences. Unity có thể cần một chút thời gian để tạo lại các file project.</li>
<li><strong>Kiểm tra:</strong> Trong cửa sổ Project của Unity, tạo một C# script mới. Nhấp đúp vào script đó. Unity bây giờ sẽ tự động mở script bằng Visual Studio Code.</li>
</ol>
<ul>
<li><em>Hình ảnh minh họa: Cửa sổ Preferences -&gt; External Tools trong Unity và cách chọn VS Code.</em></li>
</ul>
<p><strong>Xong!</strong> Bây giờ bạn đã có một môi trường hoàn chỉnh để bắt đầu lập trình C# cho game Unity bằng Visual Studio Code. Chúc bạn học tập hiệu quả và tạo ra những sản phẩm game thú vị!</p>
<p><strong>Troubleshooting (Gỡ rối thường gặp):</strong></p>
<ul>
<li><strong>VS Code không gợi ý code (IntelliSense không hoạt động):</strong>
<ul>
<li>Kiểm tra đã cài .NET SDK chưa.</li>
<li>Kiểm tra extension C# đã được cài đặt và kích hoạt trong VS Code chưa.</li>
<li>Thử đóng cả Unity và VS Code rồi mở lại dự án Unity trước, sau đó mở script bằng cách nhấp đúp từ Unity.</li>
<li>Trong Unity, thử vào <code>Edit -&gt; Preferences -&gt; External Tools</code> và nhấn nút “Regenerate project files”.</li>
</ul>
</li>
<li><strong>Không Attach Debugger được:</strong>
<ul>
<li>Kiểm tra extension “Debugger for Unity” đã được cài chưa.</li>
<li>Đảm bảo đã bật “Editor Attaching” trong Unity (<code>Edit -&gt; Preferences -&gt; External Tools</code>).</li>
<li>Thử khởi động lại cả Unity và VS Code.</li>
</ul>
</li>
<li><strong>Unity không mở VS Code khi nhấp đúp script:</strong>
<ul>
<li>Kiểm tra lại cài đặt <code>External Script Editor</code> trong Preferences của Unity. Đảm bảo đã chọn đúng đường dẫn đến VS Code.</li>
</ul>
</li>
</ul>
<hr>

    </div>
  </div>
</body>

</html>
